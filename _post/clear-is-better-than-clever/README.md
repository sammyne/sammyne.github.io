---
title: 明确胜于聪明  
date: 2019-07-13
categories:
- programming language
tags:
- golang
---

> 原文：https://dave.cheney.net/2019/07/09/clear-is-better-than-clever

> 本文衍生于我在GopherCon Singapore 2019上的演讲。演讲引用了我关于[声明变量](https://dave.cheney.net/2014/05/24/on-declaring-variables)的博文和[GolangUK 2017 presentation on SOLID design](https://dave.cheney.net/2016/08/20/solid-go-design)的演讲。简洁起见，本文略掉演讲的那些部分，有需要的话，请回看[演讲的录像](https://www.youtube.com/watch?v=NwEuRO_w8HE)。

可读性被称为Go的核心教义之一的说法是我不敢苟同的。本文将会讨论明确性和可读性的区别，说明我所指的明确性和如何应用于Go代码，并安利Go程序在编程时追求可读性之余不忘明确性。

## 为啥我要读你的代码

辨别明确性和可读性之前，可能需要回答的问题是“为啥我要读您的代码？”更确切地说，我这里说的*我*是指你而不是我自己。当我提及*您的代码*时，我是以第三方的视角说你。所以，真正的问题是“为什么你要读其他人的代码？”

我认为Russ Cox转述Titus Winters的话是最能回答这个问题的：

> 软件工程是耗费时间和协同其他程序猿的编程活动。  
> -- Russ Cox，GopherCon Singapore 2018

“我为啥要读你的代码”是因为我们一条绳子上协作的蚂蚱。无关我们办公地点、所在城市、就职公司，我们合作开发一份代码，或者更加可能地是引用其作为依赖。

Russ和Titus所观察到的关键点就是这个。软件工程是软件工程师们的长期协作。我得读你的代码，你读我的代码。如此一来，我才能理解你的代码，而你才可以维护我的代码。简而言之，随便抓个人都能改变这些代码。

Russ是明确区分软件编程和软件工程的区别的。前者是你写给自己的程序，而后者是多人长期不懈贡献的一个程序、项目、服务或产品。工程师会有所变动，团队会变大或缩小，需求会变更，特性会不断添加，bug得到修复。这是软件工程的本质。

## 我们不是读代码，而是在解码它

> 我是在演讲后某个时间点才清晰地意识到：代码不是文学作品。我们不是在读它，而是在解码它。  
> -- [Peter Seibel](http://www.gigamonkeys.com/code-reading/)

Peter Seibel认为程序不是用来读的，而是用来解码的。事后回看显而易见，毕竟我们都叫它源代码而不是源文学。程序的源代码是一种中间形式，介于我们脑海萦绕的概念和计算机可执行的符号之间。

多年经验告诉我，面对一个第三方代码库时最常见的抱怨是代码读不懂。你也应该有所体会吧？

但是可读性是一个主观的概念而已。可读性让我们对单行字符数和变量吹毛求疵，为括号的位置唇枪舌战，不惜为关于空格的编码风格和代码审查规则拳脚相向。

## 明确性不等于可读性  

明确性则是被关注代码的属性之一。清晰的代码不依赖与函数名或缩进等深层次的细节，因为它只描述代码要做什么不是怎么做的。

你或我说某个第三方代码库不可读时，我觉得我们真正的意思是*我都不懂呐*。因为我们的目的不是代码读得快而是理解得快，本所以文后续部分将会试着探究明确的代码和只是可读的代码之间的区别。

## 把代码都保持在左手边

Go程序风格往往都偏向于防卫判断和前提条件语句。这促使成功执行的流程逐步平坦地流转，而不是在条件子块中拼命缩进。因为函数的主体部分不会右移超出屏幕视野，Mat Ryer称之为[line of sight coding](https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88)。

保持条件代码块的短小，且避免对异常情况采用嵌套代码块或可能会很复杂的值遮盖方式。成功流程顺着页面向下执行。在一系列语句的任意一条，一旦执行到了就可肯定不断增加的前提条件是满足的。

```go
func ReadConfig(path string) (*Config, error) {
    f, err := os.Open(path)
    if err != nil {
            return nil, err
    }
    defer f.Close()
    // ...
 } 
```

权威案例是经典的Go常用模式：`if err != nil` 然后返回调用源头，否则继续往下执行。稍作泛化可得如下模式的伪代码

```go
if some condition {
    // true: cleanup
    return
}
// false: continue 
```

如果`some condition`为真，返回给调用者，否则继续执行直至函数末尾。

这种形式适用于所有前提判断、错误检查、字典查询和长度检查等情形。前提检查形式也许会变，但是模式永不变：后续清理代码在嵌套在代码块里，以`return`结束，而成功情况对应的逻辑则在代码块之外且仅当前提条件满足时可达。

即使你不确定前提和成功分别对应的代码功能、前提条件是如何设定的、后处理逻辑是怎样工作的，你也知道这是一个防卫判断条款。

## 结构化编程  

以下`comp`函数接收两个`int`并返回一个`int`

```go
func comp(a, b int) int {
    if a < b {
            return -1
    }
    if a > b {
            return 1
    }
    return 0
} 
```

`comp`函数的写法类似前面提到的防卫条款模式。如果`a`小于`b`，`return -1`分支执行。如果`a`大于`b`，`return 1`分支执行。否则`a`和`b`相等，最后的`return 0`分支执行。

```go
func comp(a, b int) int {
    if condition A {
        body A
    }
    if condition B {
        body B
    }
    return 0
} 
```

不同于防卫条款模式，`comp`如其字面所示，负责维护的同学必须把代码都读了。为了弄清楚什么时候返回0，读者必须遍历所有条件分支。对于一页幻灯片就能容下的函数问题不大，但是现实世界中为我们获利的、需以专业知识维护的复杂函数很少会是这种规模的，且它们条件分支也没那么简单。

让我们处理调整一下，使得返回0的情况更加明确：

```go
func comp(a, b int) int {
    if a < b {
        return -1
    } else if a > b {
        return 1
    } else {
        return 0
    }
} 
```

尽管部分人觉得上述代码可读性不高--Go相当反对一长串`if else if`语句，但现在读者清楚地知道当且仅当其他条件都不满足时才会返回0.

何以见得？Go标准文档声明每个返回值的函数必须以一条返回值的终止语句结束。也就是说，所有条件分支的主体必须返回一个值。所以，下面代码是无法通过编译的：

```go
func comp(a, b int) int {
    if a > b {
        a = b // does not compile
    } else if a < b {
        return 1
    } else {
        return 0
    }
}
```

再者，读者这份代码其实想要表达式不是一系列条件判断，而是一个条件选择的例子。只有一条分支会被执行。基于不同输入，返回值总会是-1、0或1中某一个。

```go
func comp(a, b int) int {
    if a < b {
        return -1
    } else if a > b {
        return 1
    } else {
        return 0
    }
} 
```

但是由于每个条件的写法都不一样，所以读起来有点困难，首先是个简单的`if a < b`，然后是不常见的`else if a > b`，最后其实是没有明确条件的。

好在有一个可用于清楚表达意图的语句：`switch`。

```go
func comp(a, b int) int {
    switch {
    case a < b:
        return -1
    case a > b:
        return 1
    default:
        return 0
    }
} 
```

现在读者应该能够明确知道这是个选择了。每个选择分支都在对应`case`内描述，没有了多变的`else`或`else if`子句。

将默认条件分支移到`switch`内，读者只需考虑符合他们要求的情形，因为`default`分支的存在保证没有case能够跳出`switch`块[1]。

> 结构化编程隐藏结构而强调行为。  
> -- Richard Bircher, [The limits of software](https://www.amazon.com/Limits-Software-People-Projects-Perspectives/dp/0201433230)

我是最近看到这个语录的，觉得它比较贴切。我推崇明确性是有事实支撑的，旨在强调代码的行为，而不是结构本身的细枝末节。换种说法就是：关注代码想要实现的功能而不是*它实现这个功能的方式*。

## 指导方针  

我开篇讨论可读性和明确性，并暗示还有优秀的Go代码遵循的其他原则。以其他原则来结束本篇讨论看起来是合适的样子。

上一年Bryan Cantrill作了一个关于操作系统原则的精彩演讲，其中强调不同操作系统注重不同原则。这些操作系统的区别不是所忽略的原则，也不是内部的芯片，而是各自专注的核心原则集合。那么Go的核心原则的集合又是啥呢？

### 明确 

如果你觉得是可读性，我给你提供了另一种说法。

> 程序必须为让人能看懂而写，且让机器能够执行即可。  
> -- Hal Abelson and Gerald Sussman. Structure and Interpretation of Computer Programs

代码被阅读的次数远多于编写的次数。一段代码在其生命周期内的阅读次数会不下百次甚至千次。反复的阅读为了理解这段代码。因为不只是Go程序，所有软件都是人写的且被其他人阅读，所以明确性是重要的。而软件会被机器编译执行则是次要的。

> 程序猿最重要的技巧是能够有效地交互思想。  
> -- Gastón Jorquera

法律文献有两个空格缩进是为了引起读者注意，但对帮助外行人理解其内容没有任何用处。可读性是用于描述从屏幕上读字的容易长度的属性。而另一方面，明确性想要回答“你懂刚才读的材料了么”的问题。

程序写给自己的可能只会跑一次，或者只会被我们自己看到，它会为我们自己处理一些事。但是对于多人共同开发的、或被长期使用且需求、特性和环境等会变化的软件，我们就必须着眼于确保程序是可维护的。

编写可维护代码的第一步就是明确表达代码的意图。

## 简洁  

下一个原则明显就是简洁了。某些人可能会觉得任何编程语言最重要的原则就是到此为止= =

为什么我们应该追求简洁？为什么Go程序应该简洁？

> 能够简化的能力是指消除不必要代码而使得必要部分凸显出来。  
> -- Hans Hofmann  

我们都遇到过哀嚎“我看不懂这份代码”的情形。参与某个项目，实施变更时瑟瑟发抖生怕它会搞崩程序的其他部分--那些你不懂也不知道如何修复的部分。

这就是复杂性。复杂性把软件从可靠变成不可靠。复杂性导致不可维护的软件。复杂性毁坏软件项目。明确和简洁才是催生可维护软件的两大交错的动力。

## 生产力

我想强调的最后一项Go原则是生产力。开发者的生产力归结为：你进行有效工作的时间对比等待工具帮忙或无助地徘徊于第三方代码的时间。Go程序猿应该有Go可以帮他做很多工作的感觉。

> 我开始抱怨，椅子转过去面对Robert，讨论一些关键问题。编译结束之前，我们把Ken也拉上了，觉得做点啥。  
> -- Rob Pike, [Less is Exponentially more](https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html)

这个笑话是说Go是在等待C++程序编译时设计的。快速的编译时是Go的关键特性，也是吸引新开发者的主要驱动力。虽然速度是永恒的战场，但是我们可以大胆说其他语言需要花费分钟级别的编译在Go这里只需秒级。这让Go程序猿觉得获得了同类动态语言的高效性而没有引入那些语言固有的问题。

> 设计是门编写今天能跑而且拥抱变化的代码的艺术。  
> -- Sandi Metz

开发效率更深层次的是，Go程序猿意识到代码写出来是要读的，所以相比于写代码，更加注重于读代码的艺术。Go做得如此严格：通过工具或传统习惯强制按特定风格格式化代码。这样做消除了学习项目专用风格的阻力，且有助于发现看起来就不对的错误。

Go程序猿无须花费大量时间调试高深莫测的编译错误，也不会浪费好几天处理负责的构建脚本或者把代码部署到生产环境。最重要的是：他们不需要把时间浪费在理解他们同事写的代码上面。

> 复杂性囊括任何使得软件难以理解或修改的东西。  
> -- John Ousterhout, [A Philosophy of Software Design](https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201/ref=sr_1_3?ie=UTF8&qid=1524677319&sr=8-3&keywords=john+ousterhout)

对于每个正在读这篇博文的人，就我所知，你们最终都会离开现在的雇主。可能是换个职位，也可能是升职，或者换城市了，或者追随小伙伴海外发展。无论理由是啥，我们必须考虑所创造程序的可维护性的连贯转移。

如果我们都追求明确、简洁的程序，关注同事的生产力，所有Go程序猿都会感觉好很多。

如果我们没有这样做，工作一换，之前的程序撒手不管就会得不到维护，无法更新，难以招募新成员，让负责它的其他人感觉非常难受。

如果软件得不到维护，他就得重写；这也会减弱你公司对Go青睐度。

- [1] `fallthrough`关键是会使得分析复杂化，因此`fallthrough`并不建议在`switch`语句中使用。

## 相关博文  

1. [Accidental method value](https://dave.cheney.net/2014/05/19/accidental-method-value)
2. [Unhelpful abstractions](https://dave.cheney.net/2016/02/06/unhelpful-abstractions)
3. [What is the zero value, and why is it useful?](https://dave.cheney.net/2013/01/19/what-is-the-zero-value-and-why-is-it-useful)
4. [Let's talk about logging](https://dave.cheney.net/2015/11/05/lets-talk-about-logging)
