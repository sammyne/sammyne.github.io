<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>[blog os] 12. Async/Await | sammyne</title>
    <meta name="generator" content="VuePress 1.8.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="Just playing around :)">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.a1b76618.css" as="style"><link rel="preload" href="/assets/js/app.460084d6.js" as="script"><link rel="preload" href="/assets/js/3.df7e20a8.js" as="script"><link rel="preload" href="/assets/js/1.7ac9a612.js" as="script"><link rel="preload" href="/assets/js/18.1dfec45f.js" as="script"><link rel="prefetch" href="/assets/js/10.af14b39e.js"><link rel="prefetch" href="/assets/js/11.99ba64c8.js"><link rel="prefetch" href="/assets/js/12.34332094.js"><link rel="prefetch" href="/assets/js/13.1704bbed.js"><link rel="prefetch" href="/assets/js/14.11859fd4.js"><link rel="prefetch" href="/assets/js/15.d43300c2.js"><link rel="prefetch" href="/assets/js/16.3249b7d3.js"><link rel="prefetch" href="/assets/js/17.a01809f8.js"><link rel="prefetch" href="/assets/js/19.f412f4f3.js"><link rel="prefetch" href="/assets/js/20.55e15a5f.js"><link rel="prefetch" href="/assets/js/21.c69cd7e0.js"><link rel="prefetch" href="/assets/js/22.cbffd43e.js"><link rel="prefetch" href="/assets/js/23.8b16fdf0.js"><link rel="prefetch" href="/assets/js/24.201c83d8.js"><link rel="prefetch" href="/assets/js/25.b41a1a47.js"><link rel="prefetch" href="/assets/js/26.0ed3e66c.js"><link rel="prefetch" href="/assets/js/27.7efc701f.js"><link rel="prefetch" href="/assets/js/28.72e1cd8a.js"><link rel="prefetch" href="/assets/js/29.0dced9b2.js"><link rel="prefetch" href="/assets/js/30.ab09489f.js"><link rel="prefetch" href="/assets/js/31.8c87f1ae.js"><link rel="prefetch" href="/assets/js/32.9007a3fd.js"><link rel="prefetch" href="/assets/js/33.f5646ecf.js"><link rel="prefetch" href="/assets/js/34.30466f73.js"><link rel="prefetch" href="/assets/js/35.5f43a455.js"><link rel="prefetch" href="/assets/js/36.605c0762.js"><link rel="prefetch" href="/assets/js/37.49a6b29b.js"><link rel="prefetch" href="/assets/js/38.9c0ceed6.js"><link rel="prefetch" href="/assets/js/39.833e25b8.js"><link rel="prefetch" href="/assets/js/4.33345026.js"><link rel="prefetch" href="/assets/js/40.62164fd4.js"><link rel="prefetch" href="/assets/js/41.6780bccd.js"><link rel="prefetch" href="/assets/js/42.a299958f.js"><link rel="prefetch" href="/assets/js/43.d7eb41dd.js"><link rel="prefetch" href="/assets/js/44.d2732739.js"><link rel="prefetch" href="/assets/js/45.26690fbb.js"><link rel="prefetch" href="/assets/js/46.9bafaf20.js"><link rel="prefetch" href="/assets/js/47.a788ae84.js"><link rel="prefetch" href="/assets/js/48.53199aae.js"><link rel="prefetch" href="/assets/js/49.93080943.js"><link rel="prefetch" href="/assets/js/5.da215b11.js"><link rel="prefetch" href="/assets/js/50.e2b156f3.js"><link rel="prefetch" href="/assets/js/51.7ca05ae4.js"><link rel="prefetch" href="/assets/js/52.8459aac5.js"><link rel="prefetch" href="/assets/js/53.7d8293f9.js"><link rel="prefetch" href="/assets/js/54.0e93b6fe.js"><link rel="prefetch" href="/assets/js/55.46fc1714.js"><link rel="prefetch" href="/assets/js/56.c8f25f54.js"><link rel="prefetch" href="/assets/js/57.cd09ca2f.js"><link rel="prefetch" href="/assets/js/58.810d1d6b.js"><link rel="prefetch" href="/assets/js/59.5e1237fd.js"><link rel="prefetch" href="/assets/js/6.0f93370d.js"><link rel="prefetch" href="/assets/js/60.4176824e.js"><link rel="prefetch" href="/assets/js/61.a7fe6954.js"><link rel="prefetch" href="/assets/js/62.7f7e45b1.js"><link rel="prefetch" href="/assets/js/63.ed2ba3d1.js"><link rel="prefetch" href="/assets/js/64.752309f8.js"><link rel="prefetch" href="/assets/js/65.18257448.js"><link rel="prefetch" href="/assets/js/66.47af013f.js"><link rel="prefetch" href="/assets/js/67.79be0219.js"><link rel="prefetch" href="/assets/js/68.1a70d0ba.js"><link rel="prefetch" href="/assets/js/69.899d158c.js"><link rel="prefetch" href="/assets/js/7.505b693a.js"><link rel="prefetch" href="/assets/js/70.a3db0124.js"><link rel="prefetch" href="/assets/js/71.7911f9d8.js"><link rel="prefetch" href="/assets/js/72.ca1b110f.js"><link rel="prefetch" href="/assets/js/73.78e18e89.js"><link rel="prefetch" href="/assets/js/74.5ff67c9e.js"><link rel="prefetch" href="/assets/js/75.aef53f06.js"><link rel="prefetch" href="/assets/js/76.e5510aea.js"><link rel="prefetch" href="/assets/js/77.abf8082a.js"><link rel="prefetch" href="/assets/js/78.a514a13d.js"><link rel="prefetch" href="/assets/js/79.c6fa750e.js"><link rel="prefetch" href="/assets/js/8.a4375844.js"><link rel="prefetch" href="/assets/js/80.9a33cbfe.js"><link rel="prefetch" href="/assets/js/81.c11dd67c.js"><link rel="prefetch" href="/assets/js/82.8648179e.js"><link rel="prefetch" href="/assets/js/83.2085ad68.js"><link rel="prefetch" href="/assets/js/84.a3c855af.js"><link rel="prefetch" href="/assets/js/85.2be7c107.js"><link rel="prefetch" href="/assets/js/86.ae61a023.js"><link rel="prefetch" href="/assets/js/87.da256952.js"><link rel="prefetch" href="/assets/js/88.63158169.js"><link rel="prefetch" href="/assets/js/89.cd89167a.js"><link rel="prefetch" href="/assets/js/9.acef0cc1.js"><link rel="prefetch" href="/assets/js/90.44315479.js"><link rel="prefetch" href="/assets/js/91.942e3147.js"><link rel="prefetch" href="/assets/js/92.5e611347.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a1b76618.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>sammyne</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>Just playing around :)</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>sammyne</span>
            
          <span data-v-4e82dffc>2020 - </span>
          2021
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.svg" alt="sammyne" class="logo"> <span class="site-name">sammyne</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/dev/" class="nav-link"><i class="undefined"></i>
  dev
</a></li><li class="dropdown-item"><!----> <a href="/categories/crypto/" class="nav-link"><i class="undefined"></i>
  crypto
</a></li><li class="dropdown-item"><!----> <a href="/categories/programming/" class="nav-link"><i class="undefined"></i>
  programming
</a></li><li class="dropdown-item"><!----> <a href="/categories/tee/" class="nav-link"><i class="undefined"></i>
  tee
</a></li><li class="dropdown-item"><!----> <a href="/categories/os/" class="nav-link"><i class="undefined"></i>
  os
</a></li><li class="dropdown-item"><!----> <a href="/categories/engineering/" class="nav-link"><i class="undefined"></i>
  engineering
</a></li><li class="dropdown-item"><!----> <a href="/categories/tool/" class="nav-link"><i class="undefined"></i>
  tool
</a></li><li class="dropdown-item"><!----> <a href="/categories/language/" class="nav-link"><i class="undefined"></i>
  language
</a></li><li class="dropdown-item"><!----> <a href="/categories/decentralization/" class="nav-link"><i class="undefined"></i>
  decentralization
</a></li><li class="dropdown-item"><!----> <a href="/categories/architecture/" class="nav-link"><i class="undefined"></i>
  architecture
</a></li><li class="dropdown-item"><!----> <a href="/categories/network/" class="nav-link"><i class="undefined"></i>
  network
</a></li><li class="dropdown-item"><!----> <a href="/categories/software engineering/" class="nav-link"><i class="undefined"></i>
  software engineering
</a></li><li class="dropdown-item"><!----> <a href="/categories/notes/" class="nav-link"><i class="undefined"></i>
  notes
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://github.com/sammyne" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    sammyne
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>82</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>43</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/dev/" class="nav-link"><i class="undefined"></i>
  dev
</a></li><li class="dropdown-item"><!----> <a href="/categories/crypto/" class="nav-link"><i class="undefined"></i>
  crypto
</a></li><li class="dropdown-item"><!----> <a href="/categories/programming/" class="nav-link"><i class="undefined"></i>
  programming
</a></li><li class="dropdown-item"><!----> <a href="/categories/tee/" class="nav-link"><i class="undefined"></i>
  tee
</a></li><li class="dropdown-item"><!----> <a href="/categories/os/" class="nav-link"><i class="undefined"></i>
  os
</a></li><li class="dropdown-item"><!----> <a href="/categories/engineering/" class="nav-link"><i class="undefined"></i>
  engineering
</a></li><li class="dropdown-item"><!----> <a href="/categories/tool/" class="nav-link"><i class="undefined"></i>
  tool
</a></li><li class="dropdown-item"><!----> <a href="/categories/language/" class="nav-link"><i class="undefined"></i>
  language
</a></li><li class="dropdown-item"><!----> <a href="/categories/decentralization/" class="nav-link"><i class="undefined"></i>
  decentralization
</a></li><li class="dropdown-item"><!----> <a href="/categories/architecture/" class="nav-link"><i class="undefined"></i>
  architecture
</a></li><li class="dropdown-item"><!----> <a href="/categories/network/" class="nav-link"><i class="undefined"></i>
  network
</a></li><li class="dropdown-item"><!----> <a href="/categories/software engineering/" class="nav-link"><i class="undefined"></i>
  software engineering
</a></li><li class="dropdown-item"><!----> <a href="/categories/notes/" class="nav-link"><i class="undefined"></i>
  notes
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://github.com/sammyne" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>[blog os] 12. Async/Await</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>sammyne</span>
            
          <span data-v-4e82dffc>2020 - </span>
          2021
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">[blog os] 12. Async/Await</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>sammyne</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>8/3/2020</span></i> <i class="iconfont reco-eye" data-v-1ff7123e><span id="/_post/blog-os/blog-os-12-async-await/" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-1ff7123e><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>blog_os</span><span class="tag-item" data-v-1ff7123e>rust</span></i></div></div> <div class="theme-reco-content content__default"><p>本文研究 <em>合作式多任务</em> 和 Rust 的 <em>async/await</em>。我们将会仔细了解 Rust 的 async/await 的工作原理，包括 <code>Future</code> trait 的设计，状态机转换和 <em>pinning</em>。然后创建异步的键盘任务和一个基础的执行器，从而为内核添加 async/await 的基本支持。</p> <p>这文章开源在 <a href="https://github.com/phil-opp/blog_os" target="_blank" rel="noopener noreferrer">Github<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 上。如果你有任何问题或疑问的话，请在那里打开一个 issue。这篇文章的完整源代码参见 @TODO（补充地址）。</p> <h2 id="多任务"><a href="#多任务" class="header-anchor">#</a> 多任务</h2> <p>多任务 是多数操作系统的基本功能之一，是一种并发执行多个任务的能力。例如，你先在阅读这篇文章的时候可能也打开了其他程序，例如一个文本编辑器或终端窗口。即使只打开了一个浏览器窗口，后台很可能有多个任务管理你的桌面窗口，检查更新或者索引文件等。</p> <p>虽然看起来所有任务都在并发运行，但是 CPU 内核每次只能执行一个任务。为了创造多个任务并发运行的假象，操作系统快速地切换活跃的任务，使得每个都能小步往前。由于计算机非常快速，我们大多数时间不会注意到这些切换。</p> <p>虽然单核 CPU 每次只能执行单个任务，但是多核 CPU 可以真正并行地运行多个任务。例如，8 核的 CPU 可以同时运行 8 个任务。后续文章会讲解如何搭建多核 CPU。为了简单起见，本文将会专注于单核 CPU。（值得注意的是所有多核 CPU 都是从一个单个活跃内核启动的，所以我们可以暂且把它们看作单核 CPU。）</p> <p>多任务有两种形式：<em>合作式</em> 多任务要求任务定期放弃 CPU 的控制权，使得其他任务能够进行。<em>抢占式</em> 多任务使用操作系统的功能来强制停止进程从而在任意时间点切换线程。后续部分将会更加细致地探究两种多任务形式，并讨论它们各自的优缺点。</p> <h3 id="抢占式多任务"><a href="#抢占式多任务" class="header-anchor">#</a> 抢占式多任务</h3> <p>抢占式多任务的思想是操作系统控制切换任务的时机。为此，它的实现基于这样的事实--操作系统在每次中断时都能重获 CPU 的控制权。这使得么每次系统有新输入时，切换任务变得可能。例如，鼠标移动或者网络包达到时切换任务。通过设置硬件计时器在指定时候后发送中断，操作系统能够决定任务允许运行的确切时间。</p> <p>下图描述了硬件中断时的任务切换流程：</p> <p><img src="/assets/img/regain-control-on-interrupt.fc28167f.svg" alt=""></p> <p>第一行，CPU 正在执行程序 <code>A</code> 的任务 <code>A1</code>。其他所有任务都被暂停了。第二行，硬件中断到达 CPU。如 <a href="/_post/blog-os/blog-os-12-async-await/@/second-edition/posts/07-hardware-interrupts/"><em>硬件中断</em></a> 文章描述的那样，CPU 立即停止执行任务 <code>A1</code>，并跳转到中断描述符表（IDT）定义的中断处理函数。通过这个中断处理函数，操作系统现在重新获得了 CPU 的控制权，从而允许切换到任务 <code>B1</code> 而不是继续执行任务 <code>A1</code>。</p> <h4 id="状态保存"><a href="#状态保存" class="header-anchor">#</a> 状态保存</h4> <p>由于任务会在任意时间点被中断，它们那时可能在某个计算的中间。为了能够后续还原它们，操作系统必须备份任务的全部状态，包括 <a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener noreferrer">调用栈<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和所有 CPU 寄存器的值。这个过程称为 <a href="https://en.wikipedia.org/wiki/Context_switch" target="_blank" rel="noopener noreferrer"><em>上下文切换</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>由于调用栈会非常大，操作系统通常会为每个任务配置独立的栈空间，而不是每次任务切换时备份所有栈的内核。这个拥有独立栈空间的任务称为 <a href="https://en.wikipedia.org/wiki/Thread_(computing)" target="_blank" rel="noopener noreferrer"><em>执行的线程</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或者简称 <em>线程</em>。为每个任务使用独立的栈空间，只有寄存器的内容需要在上下文切换时保存（包括程序计数器和栈指针）。这个方法最小化了上下文切换的性能损耗。因为上下文切换通常每秒回触发 100 多次，所以这点是非常重要的。</p> <h4 id="讨论"><a href="#讨论" class="header-anchor">#</a> 讨论</h4> <p>抢占式多任务的主要优点时操作系统能够完全控制任务允许的执行时间。这样，他能保证每个任务公平地得到 CPU 时间，不需要相信任务会合作。这点对于运行第三方任务或者多用户共享一个系统尤其重要。</p> <p>抢占的缺点是每个任务都需要自己的栈空间。和共享栈相比，这会使得每个任务占用更多内存，通常会限制整个系统的任务个数。另一个缺点是即使任务只是用了少数的寄存器，操作系统在每次任务切换时总得保存完整的 CPU 寄存器状态。</p> <p>抢占式多任务和线程时操作系统的核心组件，它们使得运行不可信的用户空间程序成为可能。后续文章会完整地讨论到这些概念。然而本文会聚焦于合作式多任务，它也会为我们的内核提供有用的能力。</p> <h3 id="合作式多任务"><a href="#合作式多任务" class="header-anchor">#</a> 合作式多任务</h3> <p>合作式多任务让每个任务一直运行直至它资源放弃 CPU 的控制权，而不是在任意时间点暂停正在运行的任务。这使得任何可以在合适的时间点暂停，例如它需要等待 I/O 操作。</p> <p>合作式多任务通常是编程语言级别使用，例如以 <a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener noreferrer">协程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或 <a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html" target="_blank" rel="noopener noreferrer">async/await<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的形式。思想是程序猿或者编译器在程序中插入 <a href="https://en.wikipedia.org/wiki/Yield_(multithreading)" target="_blank" rel="noopener noreferrer"><em>yield</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 操作，这个操作会放弃 CPU 的控制权，允许其他任务运行。例如，yield 可以插入到一个复杂循环的每轮迭代末尾。</p> <p>合作式多任务常常和 <a href="https://en.wikipedia.org/wiki/Asynchronous_I/O" target="_blank" rel="noopener noreferrer">异步操作<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 结合使用。与其等待直至操作结束并阻止其他在期间运行，异步操作会在操作没有完成时返回一个 &quot;not ready&quot; 状态。这种情况下，等待的任务可以执行一个 yield 操作让其他任务得以运行。</p> <h4 id="保存状态"><a href="#保存状态" class="header-anchor">#</a> 保存状态</h4> <p>由于任务自己定义暂停点，它们不需要操作系统为他们保存状态。而且，他们可以在暂停之前保存继续执行需要的确切状态，这样通常能够实现更好的性能。例如，由于再也不需要保存中间结果，一个刚完成复杂计算的任务只需要备份计算的最后结果即可。</p> <p>编程语言级别的合作式任务实现经常甚至能够在暂停之前备份好调用栈需要的部分。例如，Rust 的 async/await 把所有仍然需要的局部变量保存到一个自动生成的结构体（往下看）。暂停之前备份好调用栈的相关部分，任务可以共享一个单一的调用栈，这样一来每个任务占用的内存要小很多。这样做使得创建几乎任意数目的合作式任务而不会触发内存溢出成为可能。</p> <h4 id="讨论-2"><a href="#讨论-2" class="header-anchor">#</a> 讨论</h4> <p>合作式多任务的缺点是不合作的任务可能会持续运行任意长的时间。因此，恶意或有 bug 的任务可以阻止其他任务的运行，减慢甚至堵塞整个系统。所以只有当所有任务都配合的情况下，才采用合作式多任务。举个反例，让操作系统依赖任意用户程序就不是一个好主意。</p> <p>然而，合作式多任务的强劲性能和内存优势让其成为程序 <em>内部</em> 使用的好工具，尤其是和异步操作结合使用。由于操作系统内核是和异步硬件交互的、性能要求贼高的程序，合作式多任务看起来像是一个实现并发的好方法。</p> <h2 id="rust-的-async-await"><a href="#rust-的-async-await" class="header-anchor">#</a> Rust 的 Async/Await</h2> <p>Rust 语言以 async/await 的形式为合作式任务提供了一级的支持。开始探索什么是 async/await 和它们的工作原理之前，我们需要理解 Rust 里面的 <em>futures</em> 和异步编程的工作原理。</p> <h3 id="特性"><a href="#特性" class="header-anchor">#</a> 特性</h3> <p><em>future</em> 代表一个可能尚未可用的值。例如可以是其他任务计算的一个整数或者从网络下载的文件。与其一直等待直到值可用，future 使得继续执行直到值需要为止成为可能。</p> <h4 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h4> <p>future 的概念用一个小例子形容最为形象：</p> <p><img src="/assets/img/async-example.d59b884c.svg" alt="流程图：main 调用 read_file()，在返回被阻塞；然后调用 foo()，也被阻塞直至返回。同样的过程重复一次，但是这次调用 async_read_file 直接返回一个 future，然后 foo() 再次被调用，并发地执行直至文件加载完毕。这个文件在 foo() 返回前可用"></p> <p>时序图显示 <code>main</code> 函数从文件系统读取一个文件，然后调用函数 <code>foo</code>。同样的流程重复两次：一次调用同步的 <code>read_file</code>，一次调用异步的 <code>async_read_file</code>。</p> <p>使用同步调用，<code>main</code> 函数需要一直等待直至文件从文件系统加载完毕。只有那之后，它才可以调用 <code>foo</code> 函数，再次要求其等待结果。</p> <p>异步调用 <code>async_read_file</code> 时，文件系统直接返回一个 future，在后台异步地加载文件。这允许 <code>main</code> 函数更早地调用 <code>foo</code>，然后这个 <code>foo</code> 会和文件加载并发执行。在这个例子里面，文件加载甚至在 <code>foo</code> 返回前结束，所以 <code>main</code> 可以直接处理文件而不需要等待 <code>foo</code> 返回。</p> <h4 id="rust-的-futures"><a href="#rust-的-futures" class="header-anchor">#</a> Rust 的 Futures</h4> <p>Rust 的 futures 用 <a href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html" target="_blank" rel="noopener noreferrer"><code>Future</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 表示，结构如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token class-name">Future</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> <span class="token class-name">Output</span><span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">poll</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Output</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types" target="_blank" rel="noopener noreferrer">关联类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <code>Output</code> 注明异步值得类型。例如，上图的 <code>async_read_file</code> 函数会返回一个 <code>Output</code> 设置为 <code>File</code> 的 <code>Future</code> 实例。</p> <p><a href="https://doc.rust-lang.org/nightly/core/task/enum.Poll.html" target="_blank" rel="noopener noreferrer"><code>poll</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法可以用于检查值是否已经可用。它返回一个如下形式的 <a href="https://doc.rust-lang.org/nightly/core/task/enum.Poll.html" target="_blank" rel="noopener noreferrer"><code>Poll</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 枚举值：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">Poll</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Pending</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>值已经可用后（例如，文件已经完全从磁盘加载），它会返回一个包装在 <code>Ready</code> 里面的枚举值。否则，返回的是枚举值 <code>Pending</code>，提示调用者需要的值尚未可用。</p> <p><code>poll</code> 方法接收两个参数：<code>self: Pin&lt;&amp;mut Self&gt;</code> 和 <code>cx: &amp;mut Context</code>。前者和常规的 <code>&amp;mut self</code> 引用行为类似，只是 <code>Self</code> 值被 <a href="https://doc.rust-lang.org/nightly/core/pin/index.html" target="_blank" rel="noopener noreferrer"><em>pinned</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 到内存位置。没有理解 async/await 的工作原理之前，参透 <code>Pin</code> 及其必要性比较困难。因此我们会稍后再解释它。</p> <p><code>cx: &amp;mut Context</code> 参数的用途是为异步任务传递一个 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html" target="_blank" rel="noopener noreferrer"><code>Waker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 实例，例如文件系统加载。这个 <code>Waker</code> 允许异步任务通告它（或它的一部分）已经完成，例如文件已经从磁盘加载。由于主任务直到 <code>Future</code> 完毕时自己会被通知，所以它不需要不断地调用 <code>poll</code>。后续实现我们自己的 waker 类型时，我们将会更加细致地讲解这个过程。</p> <h3 id="使用-futures"><a href="#使用-futures" class="header-anchor">#</a> 使用 Futures</h3> <p>我们现在知道了 future 的定义以及 TODO 方法背后的基本思想。然而，我们仍然不知道如何有效地使用 futures。问题在于 futures 表示尚未可用的异步任务结果。然而实践中我们通常直接需要这个值用于进一步计算。所以问题来了：我们得如何在需要的时候高效地拿到 future 的值呢？</p> <h4 id="等待-futures"><a href="#等待-futures" class="header-anchor">#</a> 等待 Futures</h4> <p>一个可能得方式是等待直至 future 完成。相关代码如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> future <span class="token operator">=</span> <span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;foo.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> file_content <span class="token operator">=</span> <span class="token keyword">loop</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> future<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">break</span> value<span class="token punctuation">,</span>
        <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// do nothing</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这里我们在循环里面不断调用 <code>poll</code> 来 <em>积极</em> 地等待 future。<code>poll</code> 的参数不重要，所以我们忽略了它。虽然这个方式可以运行，但是因为我们等待值可用期间一直保持 CPU 繁忙，所以是非常低效的。</p> <p>一个更加有效的方式是 <em>阻塞</em> 当前线程直至 future 变得可用。当然只有能用到线程时这个方法才是可能的，所以这个方法不适用于我们的内核，至少现在不行。即使在支持阻塞的系统上，这通常也是不好的，因为它再次把异步任务转化成了同步任务，从而屏蔽了所有并行任务带来的性能提升。</p> <h4 id="future-组合器"><a href="#future-组合器" class="header-anchor">#</a> Future 组合器</h4> <p>等待的一种可选方式是使用 future 组合器。future 组合器是类似 <code>map</code> 的方法，允许串联和组合 future 到一起，和 <a href="https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html" target="_blank" rel="noopener noreferrer"><code>Iterator</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的方法类似。这些组合器返回一个 future，对 <code>poll</code> 应用映射操作，而不是一直等待 future。</p> <p>举个例子，一个将 <code>Future&lt;Output = String&gt;</code> 转化为 <code>Future&lt;Output = usize&gt;</code> 简单的 <code>string_len</code>  组合器代码如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">StringLen</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    inner_future<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token operator">&gt;</span> <span class="token class-name">Future</span> <span class="token keyword">for</span> <span class="token class-name">StringLen</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token operator">&gt;</span> <span class="token keyword">where</span> <span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> <span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">poll</span><span class="token punctuation">(</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'_</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">match</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner_future<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=&gt;</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">string_len</span><span class="token punctuation">(</span>string<span class="token punctuation">:</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
    <span class="token punctuation">-&gt;</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token keyword">usize</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token class-name">StringLen</span> <span class="token punctuation">{</span>
        inner_future<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Usage</span>
<span class="token keyword">fn</span> <span class="token function-definition function">file_len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token keyword">usize</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> file_content_future <span class="token operator">=</span> <span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;foo.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">string_len</span><span class="token punctuation">(</span>file_content_future<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>因为 <a href="https://doc.rust-lang.org/stable/core/pin/index.html" target="_blank" rel="noopener noreferrer"><em>pinning</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 问题尚未处理，这份代码还跑不通，但是作为例子够用了。基本思想是 <code>string_len</code> 函数把一个给定的 <code>Future</code> 实例包装到一个新的 <code>StringLen</code> 结构体，这个结构体也实现了 <code>Future</code>。当被包装的 future 被轮询时，它会轮询内部的 future。如果值尚未可用，被包装的 future 也会返回 <code>Poll::Pending</code>。如果值可用了，字符串会从 <code>Poll::Ready</code> 枚举值中抽离出来，计算其长度。然后，再次被包装到 <code>Poll::Ready</code> 并返回。</p> <p>借助这个 <code>string_len</code> 函数，我们能够计算异步字符串的长度而不需要等待它可用。由于函数再次返回一个 <code>Future</code>，调用者无法直接使用返回值，而是需要再次使用组合起函数。这样，整个调用图就会变成异步形式，我们可以一次性地等到多个 future，例如在 main 函数里面。</p> <p>手码组合起函数比较困难，因此它们通常由库提供支持。虽然 Rust 的标准库自身尚未提供任何组合器方法，半官方的（也 <code>no_std</code> 兼容）的 <a href="https://docs.rs/futures/0.3.4/futures/" target="_blank" rel="noopener noreferrer"><code>futures</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包提供了。它的 <a href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html" target="_blank" rel="noopener noreferrer"><code>FutureExt</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 提供诸如 <a href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.map" target="_blank" rel="noopener noreferrer"><code>map</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或 <a href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.then" target="_blank" rel="noopener noreferrer"><code>then</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 之类的高级组合器方法，可用于调用任意闭包操作结果。</p> <h5 id="优势"><a href="#优势" class="header-anchor">#</a> 优势</h5> <p>future 组合器的大优势时保持操作的异步性。和异步 I/O 接口组合到一起，这个方法可以实现非常高的性能。future 组合器实现为满足 trait 的常规结构体的事实允许编译其对其大范围地优化。更多详情参见 <a href="https://aturon.github.io/blog/2016/08/11/futures/" target="_blank" rel="noopener noreferrer"><em>Zero-cost futures in Rust</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 博文，这篇文章宣告 future 加入到 Rust 的生态。</p> <h5 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h5> <p>虽然 future 组合器使得编写非常高效的代码成为可能，但是因为类型系统和闭包驱动的接口，他们在某些情况下非常难用。例如以下代码：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">example</span><span class="token punctuation">(</span>min_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;foo.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>content<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> content<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> min_len <span class="token punctuation">{</span>
            <span class="token class-name">Either</span><span class="token punctuation">::</span><span class="token class-name">Left</span><span class="token punctuation">(</span><span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;bar.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>s<span class="token closure-punctuation punctuation">|</span></span> content <span class="token operator">+</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">Either</span><span class="token punctuation">::</span><span class="token class-name">Right</span><span class="token punctuation">(</span><span class="token namespace">future<span class="token punctuation">::</span></span><span class="token function">ready</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=91fc09024eecb2448a85a7ef6a97b8d8" target="_blank" rel="noopener noreferrer">在 playground 上小试身手<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <p>这里我们读取文件 <code>foo.txt</code>，然后使用 <a href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.then" target="_blank" rel="noopener noreferrer"><code>then</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 组合器串联基于文件内容的另一个 future。如果内容长度小于给定的 <code>min_len</code>，我们读取另一个 <code>bar.txt</code> 文件，借助 <a href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.map" target="_blank" rel="noopener noreferrer"><code>map</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 组合器把它拼接到 <code>content</code>。否则我们只返回 <code>foo.txt</code> 的内容。</p> <p>我们需要为传给 <code>then</code> 的闭包使用 <a href="https://doc.rust-lang.org/std/keyword.move.html" target="_blank" rel="noopener noreferrer"><code>move</code> 关键字<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，否则 <code>min_len</code> 会触发生命期错误问题。<a href="https://docs.rs/futures/0.3.4/futures/future/enum.Either.html" target="_blank" rel="noopener noreferrer"><code>Either</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包装器之所以需要是因为 if 和 else 代码块必须总是返回相同类型。由于代码块返回不同的 future 类型，我们必须使用包装器把他们统一到单一类型。<a href="https://docs.rs/futures/0.3.4/futures/future/fn.ready.html" target="_blank" rel="noopener noreferrer"><code>ready</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数把一个值包装成值立即可用的 future。因为 <code>Either</code> 包装器期望被包装的值实现 <code>Future</code>，这个函数也是必要的。</p> <p>可以想到，更大的项目很快就会把这写成非常复杂的代码。如果涉及借用和不同的生命期，它会变得尤其复杂。因此，很多工作投入到了将 async/await 添加到 Rust，期望能够让异步代码的编写变得异常简单。</p> <h3 id="async-await-模式"><a href="#async-await-模式" class="header-anchor">#</a> Async/Await 模式</h3> <p>async/await 背后的思想是让程序猿编写的代码 <em>看起来</em> 像常规同步代码，但是编译器将其转化成异步代码。具体实现依赖 <code>async</code> 和 <code>await</code> 这两个关键字。<code>async</code> 关键字可以用在函数签名上，将一个同步函数转化成返回 future 的异步函数：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
    <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token comment">// the above is roughly translated by the compiler to:</span>
<span class="token keyword">fn</span> <span class="token function-definition function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token keyword">u32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token namespace">future<span class="token punctuation">::</span></span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>只有这个关键字的话用处不大。然而，在 <code>async</code> 函数内部，<code>await</code> 关键能够用于获取 future 的异步值：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">example</span><span class="token punctuation">(</span>min_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> content <span class="token operator">=</span> <span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;foo.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> content<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> min_len <span class="token punctuation">{</span>
        content <span class="token operator">+</span> <span class="token operator">&amp;</span><span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;bar.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        content
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d93c28509a1c67661f31ff820281d434" target="_blank" rel="noopener noreferrer">在 playground 上小试身手<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <p>这个函数是 <a href="#drawbacks">前面</a> 使用组合器函数的 <code>example</code> 函数的直接翻版。使用 <code>.await</code> 运算符，我们不需要任何闭包或者 <code>Either</code> 类型就可以拿到 future 的值。结果，我们可以像写同步代码那样编写代码，只是 <em>写出的仍然是异步代码</em>。</p> <h4 id="状态机转换"><a href="#状态机转换" class="header-anchor">#</a> 状态机转换</h4> <p>编译器内地里执行的操作是把 <code>async</code> 函数的函数体转化成一个 <a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener noreferrer"><em>状态机</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，其中每个 <code>.await</code> 调用代表一个不同的状态。对于上述 <code>example</code> 函数，编译创建以下四个状态的状态机：</p> <p><img src="/assets/img/async-state-machine-states.581f3651.svg" alt="四种状态：开始，等待 foo.txt，等待 bar.txt，结束"></p> <p>每个状态代表函数的不同暂停点。<em>&quot;Start&quot;</em> 和 <em>&quot;End&quot;</em> 状态表示函数的开始和结束。<em>&quot;Waiting on foo.txt&quot;</em> 状态代表函数当前正在等待第一个 <code>async_read_file</code> 的结果。类似的，<em>&quot;Waiting on bar.txt&quot;</em> 状态代表函数等待第二个 <code>async_read_file</code> 结果的暂停点。</p> <p>状态机通过把每个 <code>poll</code> 调用转化为一次状态转换的方式实现 <code>Future</code> trait：</p> <p><img src="/assets/img/async-state-machine-basic.64cda4e9.svg" alt="四种状态：启动，等待 foo.txt，等待 bar.txt，结束"></p> <p>上图使用箭头表示状态切换，菱形表示分叉。例如，如果 <code>foo.txt</code> 文件尚未可用，标记为 <em>&quot;no&quot;</em> 的路径执行，状态变为 <em>&quot;Waiting on foo.txt&quot;</em>。否则，<em>&quot;yes&quot;</em> 路径执行。没有标题的红色小菱形表示 <code>example</code> 函数的 <code>if content.len() &lt; 100</code> 分支。</p> <p>可以看懂第一个 <code>poll</code> 调用触发函数执行直至遇到一个尚未完成的 future。如果路径上的所有 future 都完成了，这个函数运行到 <em>&quot;End&quot;</em> 状态，把结果包装在 <code>Poll::Ready</code> 中返回。否则，状态机进入等待状态，返回 <code>Poll::Pending</code>。下一次 <code>poll</code> 调用时，状态机再从上一个等待状态开始执行，重试上一次的操作。</p> <h4 id="保存状态-2"><a href="#保存状态-2" class="header-anchor">#</a> 保存状态</h4> <p>为了能够从上一个等待状态继续执行，状态机必须内地里一直追踪当前状态。另外，它必须下一次调用 <code>poll</code> 时继续执行需要用到的所有变量。这是编译器大展身手的地方：由于直到到时需要用到的变量，它可以自动生成包含所需确切变量的结构体。</p> <p>举个例子，编译器会为 <code>example</code> 函数生成以下形式的结构体：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// The `example` function again so that you don't have to scroll up</span>
<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">example</span><span class="token punctuation">(</span>min_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> content <span class="token operator">=</span> <span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;foo.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> content<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> min_len <span class="token punctuation">{</span>
        content <span class="token operator">+</span> <span class="token operator">&amp;</span><span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;bar.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        content
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// The compiler-generated state structs:</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">StartState</span> <span class="token punctuation">{</span>
    min_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">WaitingOnFooTxtState</span> <span class="token punctuation">{</span>
    min_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>
    foo_txt_future<span class="token punctuation">:</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">WaitingOnBarTxtState</span> <span class="token punctuation">{</span>
    content<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
    bar_txt_future<span class="token punctuation">:</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">EndState</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>在 &quot;start&quot; 和 <em>&quot;Waiting on foo.txt&quot;</em> 状态，由于需要用于后续和 <code>content.len()</code> 比较，<code>min_len</code> 参数需要保存。<em>&quot;Waiting on foo.txt&quot;</em> 状态另外需要保存一个 <code>foo_txt_future</code>，代表 <code>async_read_file</code> 调用返回的 future。状态机继续执行时需要再次轮询这个 future，所以它需要保存。</p> <p>因为 <code>content</code> 变量需要拼接 <code>bar.txt</code> 加载的字符串，所以 <em>&quot;Waiting on bar.txt&quot;</em> 状态包含这个变量。它也保存一个 <code>bar_txt_future</code>，表示正在加载的 <code>bar.txt</code>。因为在和 <code>content.len()</code> 比较后就没用了，结构体没有包含 <code>min_len</code> 变量。在 <em>&quot;end&quot;</em> 状态，因为函数已经运行结束，所以不需要保存任何变量。</p> <p>记住了这只是编译器能为这份样例代码生成的。结构体名称和字段布局是实现细节，可能有所不同。</p> <h4 id="完整的状态机类型"><a href="#完整的状态机类型" class="header-anchor">#</a> 完整的状态机类型</h4> <p>虽然编译器的生成确切代码是实现细节，但是它有助于理解编译器为 <code>example</code> 函数生成的状态机代码 <em>可以</em> 长成什么样。我们已经定义表示不同状态的结构体，包含要求的变量。为了在它们的基础上创建一个状态机，我们需要把他们组合到一个 <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html" target="_blank" rel="noopener noreferrer"><code>enum</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 里面：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> <span class="token type-definition class-name">ExampleStateMachine</span> <span class="token punctuation">{</span>
    <span class="token class-name">Start</span><span class="token punctuation">(</span><span class="token class-name">StartState</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">WaitingOnFooTxt</span><span class="token punctuation">(</span><span class="token class-name">WaitingOnFooTxtState</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">WaitingOnBarTxt</span><span class="token punctuation">(</span><span class="token class-name">WaitingOnBarTxtState</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">End</span><span class="token punctuation">(</span><span class="token class-name">EndState</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们为每个状态定义不同的枚举值，并把相应的状态结构体添加为枚举值的字段。为了实现状态转换，编译器基于 <code>example</code> 函数生成 <code>Future</code> trait 的一份实现：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">impl</span> <span class="token class-name">Future</span> <span class="token keyword">for</span> <span class="token class-name">ExampleStateMachine</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> <span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// return type of `example`</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">poll</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Output</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">loop</span> <span class="token punctuation">{</span>
            <span class="token keyword">match</span> <span class="token keyword">self</span> <span class="token punctuation">{</span> <span class="token comment">// TODO: handle pinning</span>
                <span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">Start</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span>
                <span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">WaitingOnFooTxt</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span>
                <span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">WaitingOnBarTxt</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span>
                <span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">End</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>因为 <code>example</code> 函数的返回值类型是 <code>String</code>，future 的 <code>Output</code> 类型也是 <code>String</code>。为了实现 <code>poll</code> 函数，我们在一个 <code>loop</code> 里面对当前状态使用一个 match 语句。思想是一旦满足条件就切换到下一个状态，而无法继续时返回一个显式的 <code>return Poll::Pending</code>。</p> <p>为了简洁起见，我们只显示简化的代码，没有处理 <a href="https://doc.rust-lang.org/stable/core/pin/index.html" target="_blank" rel="noopener noreferrer">pinning<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、所有权和生命期等。所以这份和以下代码都应该看做伪代码，不要直接使用。当然，编译器生成的代码会正确处理好所有事，可能采用不同姿势而已。</p> <p>为了保持引用代码的简短，我们分别展示每个 match 情况的代码。从 <code>Start</code> 状态说起：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">Start</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// from body of `example`</span>
    <span class="token keyword">let</span> foo_txt_future <span class="token operator">=</span> <span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;foo.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// `.await` operation</span>
    <span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token class-name">WaitingOnFooTxtState</span> <span class="token punctuation">{</span>
        min_len<span class="token punctuation">:</span> state<span class="token punctuation">.</span>min_len<span class="token punctuation">,</span>
        foo_txt_future<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token keyword">self</span> <span class="token operator">=</span> <span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">WaitingOnFooTxt</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>刚开始执行函数时，状态处于 <code>Start</code> 状态。这种情况下，我们执行 <code>example</code> 函数的所有代码直至第一个 <code>.await</code>。为了处理 <code>.await</code> 操作，我们把 <code>self</code> 状态机的状态更新为 <code>WaitingOnFooTxt</code>，其中涉及构建 <code>WaitingOnFooTxtState</code> 结构体：</p> <p>由于 <code>match self {…}</code> 语句在一个循环内执行，下一步流程转到 <code>WaitingOnFooTxt</code> 情况：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">WaitingOnFooTxt</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> state<span class="token punctuation">.</span>foo_txt_future<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span><span class="token punctuation">,</span>
        <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// from body of `example`</span>
            <span class="token keyword">if</span> content<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> state<span class="token punctuation">.</span>min_len <span class="token punctuation">{</span>
                <span class="token keyword">let</span> bar_txt_future <span class="token operator">=</span> <span class="token function">async_read_file</span><span class="token punctuation">(</span><span class="token string">&quot;bar.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// `.await` operation</span>
                <span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token class-name">WaitingOnBarTxtState</span> <span class="token punctuation">{</span>
                    content<span class="token punctuation">,</span>
                    bar_txt_future<span class="token punctuation">,</span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token operator">*</span><span class="token keyword">self</span> <span class="token operator">=</span> <span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">WaitingOnBarTxt</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token operator">*</span><span class="token keyword">self</span> <span class="token operator">=</span> <span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">End</span><span class="token punctuation">(</span><span class="token class-name">EndState</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>这种情况下，我么首先调用 <code>foo_txt_future</code> 的 <code>poll</code> 函数。如果它尚未执行完毕，我们退出循环，并返回 <code>Poll::Pending</code>。由于这种情况下 <code>self</code> 保持在 <code>WaitingOnFooTxt</code> 状态，状态机的下一个 <code>poll</code> 调用会进入同样的 match 分支，并重试轮询 <code>foo_txt_future</code>。</p> <p><code>foo_txt_future</code> 满足时，我们把结果赋值给 <code>content</code> 变量，继续执行 <code>example</code> 函数的代码：如果 <code>content.len()</code> 小于结构体保存的 <code>min_len</code>，会执行异步读取 <code>bar.txt</code> 的操作。我们再次把 <code>.await</code> 操作翻译为一个不同的状态转换，这次是 <code>WaitingOnBarTxt</code> 状态。由于我们正在循环内执行 <code>match</code>，执行会直接跳转到新状态的 match 分支，开始轮询 <code>bar_txt_future</code>。</p> <p>如果进入 <code>else</code> 分支，没有出现其他 <code>.await</code> 操作。我们到了函数末尾，返回 <code>Poll::Ready</code> 包裹的 <code>content</code>。我们也把当前状态更新为 <code>End</code> 状态。</p> <p><code>WaitingOnBarTxt</code> 状态下执行的代码如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">WaitingOnBarTxt</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> state<span class="token punctuation">.</span>bar_txt_future<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span><span class="token punctuation">,</span>
        <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>bar_txt<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span><span class="token keyword">self</span> <span class="token operator">=</span> <span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">End</span><span class="token punctuation">(</span><span class="token class-name">EndState</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// from body of `example`</span>
            <span class="token keyword">return</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>content <span class="token operator">+</span> <span class="token operator">&amp;</span>bar_txt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>和 <code>WaitingOnFooTxt</code> 状态类似，我们先轮询 <code>bar_txt_future</code>。如果它仍然进行中，我们退出循环，返回 <code>Poll::Pending</code>。否则，我们执行 <code>example</code> 函数的最后一个操作：把 TODO 变量和 future 返回的结果拼接到一起。更新状态机状态为 <code>End</code>，然后返回 <code>Poll::Ready</code> 包裹的结果。</p> <p>最后，<code>End</code> 状态的代码如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">End</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token macro property">panic!</span><span class="token punctuation">(</span><span class="token string">&quot;poll called after Poll::Ready was returned&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>futures 变成 <code>Poll::Ready</code> 后，不应该再被轮询，因此已经处于 <code>End</code> 状态时还调用 <code>poll</code> 的话，会触发 panic。</p> <p>我们现在知道 <code>Future</code> trait 的编译器生成代码和它的实现 <em>可能</em> 长什么样了。实践中，编译器生成代码的姿势不大一样。（如果感兴趣的话，当前实现基于 <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/generators.html" target="_blank" rel="noopener noreferrer"><em>generators</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，但是这仅是个实现细节。）</p> <p>最后一个待解之谜是 <code>example</code> 函数自身的生成代码。没有忘记的话，函数的头部如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">example</span><span class="token punctuation">(</span>min_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>由于完整的函数体已经实现为状态机，函数需要做的唯一一件事时初始化状态机并返回它。生成的代码可能如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">example</span><span class="token punctuation">(</span>min_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">ExampleStateMachine</span> <span class="token punctuation">{</span>
    <span class="token class-name">ExampleStateMachine</span><span class="token punctuation">::</span><span class="token class-name">Start</span><span class="token punctuation">(</span><span class="token class-name">StartState</span> <span class="token punctuation">{</span>
        min_len<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>由于先在显示返回一个实现 <code>Future</code> trait 的 <code>ExampleStateMachine</code> 类型，这个函数不再有 <code>async</code> 修饰符。和预期的那样，状态机的开始状态为 <code>Start</code>，相应的状态结构体用 <code>min_len</code> 参数初始化。</p> <p>需要注意的是这个函数没有开始状态机的运行。这个 Rust 的future 的基本设计原则：它们在第一次轮询之前不会做任何事。</p> <h3 id="pinning"><a href="#pinning" class="header-anchor">#</a> Pinning</h3> <p>我们已经被 <em>pinning</em> 搞了好几次了。先在终于是时候研究一下什么是 pinning 及其必要性了。</p> <h4 id="自引用结构体"><a href="#自引用结构体" class="header-anchor">#</a> 自引用结构体</h4> <p>如前面解释的那样，状态机转换把每个暂停点的局部变量存储到一个结构体。对于像我们 <code>example</code> 函数一样的小样例，这是比较直观的，不会出现什么问题。但是，变量引用彼此的时候，处境就会变得更加难了。例如，考虑一下这么个函数：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">pin_example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> element <span class="token operator">=</span> <span class="token operator">&amp;</span>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">async_write_file</span><span class="token punctuation">(</span><span class="token string">&quot;foo.txt&quot;</span><span class="token punctuation">,</span> element<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>element
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这个函数创建内容为 <code>1</code>、<code>2</code> 和 <code>3</code> 的一个小 <code>array</code>。然后把数组的最后一个元素的引用保存到 <code>element</code> 变量。接下来，异步地把数值转化为字符串写入到 <code>foo.txt</code> 文件。最后返回 <code>element</code> 引用的数值。</p> <p>由于函数使用单个 <code>await</code> 操作，所得状态机有三个状态：start、end 和 &quot;waiting on write&quot;。这个函数没有任何入参，所以 start 状态的结构体为空。和之前类似，因为函数会在 end 状态结束，所以 end 状态的结构体也为空。&quot;waiting on write&quot; 状态的结构体也更加有意思一点：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">WaitingOnWriteState</span> <span class="token punctuation">{</span>
    array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    element<span class="token punctuation">:</span> <span class="token number">0x1001c</span><span class="token punctuation">,</span> <span class="token comment">// address of the last array element</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>因为返回值需要用到 <code>element</code>，而 <code>element</code> 引用 <code>array</code>，所以我们需要同时保存 <code>array</code> 和 <code>element</code> 变量。由于 <code>element</code> 是一个引用，它保存指向元素的一个 <em>指针</em>（即，一个内存地址）。这里使用 <code>0x1001c</code> 作为实例内存地址。真实情况下，这个地址需要是 <code>array</code> 字段的最后一个元素的地址，所以它取决于结构体在内存中的位置。因为他们用自己的另一个字段引用自身的其他字段，所以拥有这样内部指针得结构体称为 <em>自引用</em> 结构体。</p> <h4 id="自引用结构体的问题"><a href="#自引用结构体的问题" class="header-anchor">#</a> 自引用结构体的问题</h4> <p>自引用结构体的内部指针会导致一个严重问题，查看其内存布局时即可明显看到：</p> <p><img src="/assets/img/self-referential-struct.e3b97f81.svg" alt="0x10014 数组存储值 1、2 和 3；element 在地址 0x10020，指向数组在 0x1001c 的元素"></p> <p><code>array</code> 字段的起始地址为 0x10014，<code>element</code> 字段的地址为 0x10020。因为最后一个数组元素保存在这个地址，所以 <code>element</code> 指向地址 0x1001c。目前看上去，一切安好。然而，当我们把这个结构体移动到一个不同内存地址时，问题就显现出来了：</p> <p><img src="/assets/img/self-referential-struct-moved.85957930.svg" alt="0x10024 数组存储值 1、2 和 3；element 在地址 0x10030，仍然指向地址 0x1001c，尽管数组的最后一个元素现在 0x1002a"></p> <p>我们移动了结构体，使得它的起始地址现在变成了 <code>0x10024</code>。当我们把这个结构体作为函数参数或者赋值给一个不同的栈变量时，就会出现这个情景。问题出在即使 <code>array</code> 的最后一个元素现在地址 <code>0x1001c</code>，但是 <code>element</code> 字段依然指向地址 <code>0x1002a</code>。因此，这个指针悬空了，下一次调用 <code>poll</code> 时会触发未定义行为。</p> <h4 id="可能的解决方案"><a href="#可能的解决方案" class="header-anchor">#</a> 可能的解决方案</h4> <p>解决悬空指针问题有三种基本方法：</p> <ul><li><strong>移动时更新指针</strong>：思想是每次在内存移动结构体时，更新内部指针，这样指针移动后就会依然合法。不幸的是，这个方法会要求大幅修改 Rust，导致可能很大的性能损失。原因是某些运行时得追踪结构体的所有字段类型，在每次移动时检查一个指针是否需要更新</li> <li><strong>保存偏移量而不是自引用</strong>：为了避免更新指针，编译器可以试图把自引用保存为相对结构体起始地址的偏移量。例如，因为被引用的数组元素距离结构体起始地址 8 个字节，所以上述 TODO 结构体的 TODO 字段可以值为 8 的 TODO 字段的形式保存。结构体移动时，由于偏移量保持不变，所以没有字段需要更新。</li></ul> <p>这个方法的问题是要求编译器监测处所有自引用。因为引用可能取决于用户输入，这在编译时不可能实现，所以我们再次需要一个运行时系统来分析引用，正确地创建状态结构体。这不仅会引入运行时损耗，还会阻止某些编译器优化，从而再次带来大的性能损失。</p> <ul><li><strong>禁止移动结构体</strong>：如上所见，悬空指针只会在内存移动结构体时出现。通过完全禁止移动自引用结构体，问题就可以解决了。这个方法的最大优势时可以在类型系统级别实现，不需要额外的运行时损耗。缺点是把处理可能得自引用结构体的负担放到了程序猿肩上</li></ul> <p>由于坚持 <em>零代价抽象</em> 的原则，即抽线不应该带来额外的运行时损失，Rust 觉得采用第三种方法。为此，<a href="https://doc.rust-lang.org/stable/core/pin/index.html" target="_blank" rel="noopener noreferrer"><em>pinning</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> API 在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md" target="_blank" rel="noopener noreferrer">RFC 2349<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 被提了出来。后续部分，我们将会简要地过一下这个 API，并解释它是如何和 async/await 和 future 一起工作的。</p> <h4 id="堆值"><a href="#堆值" class="header-anchor">#</a> 堆值</h4> <p>第一个观察到的现象是 <a href="/_post/blog-os/blog-os-12-async-await/@/second-edition/posts/10-heap-allocation/">堆分配</a> 的值大部分时间都有了一个固定的内存地址。它们通过调用 <code>allocate</code> 创建，然后被例如 <code>Box&lt;T&gt;</code> 的指针引用。虽然移动指针类型是可能得，但是堆上的值会呆在同样的内存地址直至调用 <code>deallocate</code> 时被再次释放。</p> <p>使用堆分配，我们可以尝试创建一个自引用结构体：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> heap_value <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">SelfReferential</span> <span class="token punctuation">{</span>
        self_ptr<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> _<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token operator">*</span>heap_value <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token class-name">SelfReferential</span><span class="token punctuation">;</span>
    heap_value<span class="token punctuation">.</span>self_ptr <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;heap value at: {:p}&quot;</span><span class="token punctuation">,</span> heap_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;internal reference: {:p}&quot;</span><span class="token punctuation">,</span> heap_value<span class="token punctuation">.</span>self_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">SelfReferential</span> <span class="token punctuation">{</span>
    self_ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token keyword">Self</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ce1aff3a37fcc1c8188eeaf0f39c97e8" target="_blank" rel="noopener noreferrer">在 playground 上小试身手<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <p>我们创建一个名为 <code>SelfReferential</code> 的结构体，包含单个指针字段。首先，我们用一个空指针初始化这个结构体，然后调用 <code>Box::new</code> 在堆上为其分配内存。我们确定堆上分配结构体的内存地址，并将其保存在一个 <code>ptr</code> 变量中。最后，将 <code>ptr</code> 变量赋值给 <code>self_ptr</code> 使得结构体变成自引用。</p> <p>在 <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ce1aff3a37fcc1c8188eeaf0f39c97e8" target="_blank" rel="noopener noreferrer">playground<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 上运行这份代码时，可以看到堆值得地址和它的内部指针是相等的，这意味着 <code>self_ptr</code> 字段是一个合法的自引用。由于 <code>heap_value</code> 变量只是一个指针，移动它（例如，把它传给一个函数）不会改变结构体自身的地址，所以即使指针移动了，<code>self_ptr</code> 还会有效。</p> <p>然而，还是有办法破坏这个例子的：从 <code>Box&lt;T&gt;</code> 移出值或者替换它的值，</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> stack_value <span class="token operator">=</span> <span class="token namespace">mem<span class="token punctuation">::</span></span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token operator">*</span>heap_value<span class="token punctuation">,</span> <span class="token class-name">SelfReferential</span> <span class="token punctuation">{</span>
    self_ptr<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> _<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;value at: {:p}&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;internal reference: {:p}&quot;</span><span class="token punctuation">,</span> stack_value<span class="token punctuation">.</span>self_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e160ee8a64cba4cebc1c0473dcecb7c8" target="_blank" rel="noopener noreferrer">在 playground 上小试身手<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <p>这里调用 <a href="https://doc.rust-lang.org/nightly/core/mem/fn.replace.html" target="_blank" rel="noopener noreferrer"><code>mem::replace</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数把堆分配的值替换为一个新的结构体实例。这允许我们把原先的 <code>heap_value</code> 移动到栈上，然而结构体的 <code>self_ptr</code> 字段现在变成了悬空指针，仍然指向旧的堆地址。当我们试图在 playground 运行这个例子的时候，可以看到打印的 <em>&quot;value at:&quot;</em> 和 <em>&quot;internal reference:&quot;</em> 行确实显示了不懂得指针。所以堆分配值不足以使得自引用安全。</p> <p>触发上述破坏出现的核心缘由是 <code>Box&lt;T&gt;</code> 允许我们获得堆分配值的 <code>&amp;mut T</code> 引用。这个 <code>&amp;mut</code> 使得调用诸如 <a href="https://doc.rust-lang.org/nightly/core/mem/fn.replace.html" target="_blank" rel="noopener noreferrer"><code>mem::replace</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或 <a href="https://doc.rust-lang.org/nightly/core/mem/fn.swap.html" target="_blank" rel="noopener noreferrer"><code>mem::swap</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法来覆盖堆分配值成为可能。为了解决这个问题，我们必须避免创建自引用结构体的 <code>&amp;mut</code> 引用。</p> <h4 id="pin-box-t-和-unpin"><a href="#pin-box-t-和-unpin" class="header-anchor">#</a> <code>Pin&lt;Box&lt;T&gt;&gt;</code> 和 <code>Unpin</code></h4> <p>pinning API 解决的 <code>&amp;mut T</code> 问题的方式是提供一个 <a href="https://doc.rust-lang.org/stable/core/pin/struct.Pin.html" target="_blank" rel="noopener noreferrer"><code>Pin</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包装器类型和一个 <a href="https://doc.rust-lang.org/nightly/std/marker/trait.Unpin.html" target="_blank" rel="noopener noreferrer"><code>Unpin</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 标记 trait。这些类型背后的思想是把所有能够获得被 <code>Pin</code> 包装类型的 <code>&amp;mut</code> 引用的所有源自 <code>Unpin</code> trait 的方法（例如，<a href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.get_mut" target="_blank" rel="noopener noreferrer"><code>get_mut</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或 <a href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#impl-DerefMut" target="_blank" rel="noopener noreferrer"><code>deref_mut</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）。<code>Unpin</code> trait 是一个 <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits" target="_blank" rel="noopener noreferrer"><em>auto trait</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，会为所有类型实现除非显示的弃用。通过自引用结构体弃用 <code>Unpin</code>，这样就没有（安全的）方式能从 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 类型获得一个 <code>&amp;mut T</code>。这样一来，它们的内部引用就能确保一直有效。</p> <p>作为示例，让我们更新上面的 <code>SelfReferential</code>，使其弃用 <code>Unpin</code>：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>marker<span class="token punctuation">::</span></span><span class="token class-name">PhantomPinned</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">SelfReferential</span> <span class="token punctuation">{</span>
    self_ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token keyword">Self</span><span class="token punctuation">,</span>
    _pin<span class="token punctuation">:</span> <span class="token class-name">PhantomPinned</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们通过添加多一个类型为 <a href="https://doc.rust-lang.org/nightly/core/marker/struct.PhantomPinned.html" target="_blank" rel="noopener noreferrer"><code>PhantomPinned</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的 <code>_pin</code> 字段实现弃用。这是个零大小的标记类型，唯一的用途是 <em>不</em> 要实现 <code>Unpin</code> trait。由于 <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits" target="_blank" rel="noopener noreferrer">auto traits<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的工作方式，一个非 <code>Unpin</code> 的字段足以使得整个结构体弃用 <code>Unpin</code>。</p> <p>第二步是例子中的 <code>Box&lt;SelfReferential&gt;</code> 类型为 <code>Pin&lt;Box&lt;SelfReferential&gt;&gt;</code> 类型。最简单的方式是使用 <a href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.pin" target="_blank" rel="noopener noreferrer"><code>Box::pin</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数而不是 <a href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.new" target="_blank" rel="noopener noreferrer"><code>Box::new</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来创建堆分配的值。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> heap_value <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">pin</span><span class="token punctuation">(</span><span class="token class-name">SelfReferential</span> <span class="token punctuation">{</span>
    self_ptr<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> _<span class="token punctuation">,</span>
    _pin<span class="token punctuation">:</span> <span class="token class-name">PhantomPinned</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>除了把 <code>Box::new</code> 变为 <code>Box::pin</code>，我们还需要为结构体初始化函数添加新的 <code>_pin</code> 字段。由于 <code>PhantomPinned</code> 是零尺寸类型，我们只需要它的类型名即可初始化它。</p> <p>现在 [试图运行调整后的例子]https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=961b0db194bbe851ff4d0ed08d3bd98a)，可以看到会编译失败：</p> <p>In addition to changing <code>Box::new</code> to <code>Box::pin</code>, we also need to add the new <code>_pin</code> field in the struct initializer. Since <code>PhantomPinned</code> is a zero sized type, we only need its type name to initialize it.</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>error<span class="token punctuation">[</span>E0594<span class="token punctuation">]</span>: cannot assign to data <span class="token keyword">in</span> a dereference of <span class="token variable"><span class="token variable">`</span>std::pin::Pin<span class="token operator">&lt;</span>std::boxed::Box<span class="token operator">&lt;</span>SelfReferential<span class="token operator">&gt;&gt;</span><span class="token variable">`</span></span>
  --<span class="token operator">&gt;</span> src/main.rs:10:5
   <span class="token operator">|</span>
<span class="token number">10</span> <span class="token operator">|</span>     heap_value.self_ptr <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
   <span class="token operator">|</span>     ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
   <span class="token operator">|</span>
   <span class="token operator">=</span> help: trait <span class="token variable"><span class="token variable">`</span>DerefMut<span class="token variable">`</span></span> is required to modify through a dereference, but it is not implemented <span class="token keyword">for</span> <span class="token variable"><span class="token variable">`</span>std::pin::Pin<span class="token operator">&lt;</span>std::boxed::Box<span class="token operator">&lt;</span>SelfReferential<span class="token operator">&gt;&gt;</span><span class="token variable">`</span></span>

error<span class="token punctuation">[</span>E0596<span class="token punctuation">]</span>: cannot borrow data <span class="token keyword">in</span> a dereference of <span class="token variable"><span class="token variable">`</span>std::pin::Pin<span class="token operator">&lt;</span>std::boxed::Box<span class="token operator">&lt;</span>SelfReferential<span class="token operator">&gt;&gt;</span><span class="token variable">`</span></span> as mutable
  --<span class="token operator">&gt;</span> src/main.rs:16:36
   <span class="token operator">|</span>
<span class="token number">16</span> <span class="token operator">|</span>     <span class="token builtin class-name">let</span> stack_value <span class="token operator">=</span> mem::replace<span class="token punctuation">(</span><span class="token operator">&amp;</span>mut *heap_value, SelfReferential <span class="token punctuation">{</span>
   <span class="token operator">|</span>                                    ^^^^^^^^^^^^^^^^ cannot borrow as mutable
   <span class="token operator">|</span>
   <span class="token operator">=</span> help: trait <span class="token variable"><span class="token variable">`</span>DerefMut<span class="token variable">`</span></span> is required to modify through a dereference, but it is not implemented <span class="token keyword">for</span> <span class="token variable"><span class="token variable">`</span>std::pin::Pin<span class="token operator">&lt;</span>std::boxed::Box<span class="token operator">&lt;</span>SelfReferential<span class="token operator">&gt;&gt;</span><span class="token variable">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>因为 <code>Pin&lt;Box&lt;SelfReferential&gt;&gt;</code> 类型不再实现 <code>DerefMut</code> trait，所以触发了上述错误。这正是我们想要的：因为 <code>DerefMut</code> trait 会返回我们想要禁止的 <code>&amp;mut</code> 引用。这只会在我们同时弃用 <code>Unpin</code> 和把 <code>Box::new</code> 改为 <code>Box::pin</code> 后才会发生。</p> <p>现在的问题变成了编译不仅能够阻止第 16 行的类型移动，还禁止了第 10 行 <code>self_ptr</code> 字段的初始化。这是因为编译无法区分合法和非法 <code>&amp;mut</code> 引用的使用情况。为了让初始化能够再次工作，我们必须使用不安全的 <a href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.get_unchecked_mut" target="_blank" rel="noopener noreferrer"><code>get_unchecked_mut</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// safe because modifying a field doesn't move the whole struct</span>
<span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> mut_ref <span class="token operator">=</span> <span class="token class-name">Pin</span><span class="token punctuation">::</span><span class="token function">as_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> heap_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Pin</span><span class="token punctuation">::</span><span class="token function">get_unchecked_mut</span><span class="token punctuation">(</span>mut_ref<span class="token punctuation">)</span><span class="token punctuation">.</span>self_ptr <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b9ebbb11429d9d79b3f9fffe819e2018" target="_blank" rel="noopener noreferrer">在 playground 上小试身手<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <p><a href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.get_unchecked_mut" target="_blank" rel="noopener noreferrer"><code>get_unchecked_mut</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数对 <code>Pin&lt;&amp;mut T&gt;</code> 而不是 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 有效，所以我们必须先使用 <a href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.as_mut" target="_blank" rel="noopener noreferrer"><code>Pin::as_mut</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 转换值。然后借助 <code>get_unchecked_mut</code> 返回的 <code>&amp;mut</code> 引用设置 <code>self_ptr</code> 字段。</p> <p>现在剩下的唯一错误是 <code>mem::replace</code> 触发的预期错误了。这个操作试图把堆上的值移动到栈上，这会破坏自引用保存的 <code>self_ptr</code> 字段。通过主动弃用 <code>Unpin</code> 并使用 <code>Pin&lt;Box&lt;T&gt;&gt;</code>，我们可以在编译时阻止这个操作，从而安全地使用自引用结构体。可以看到编译器无法证明自引用的创建时合法的（到目前为止），所以我们需要使用一个 unsafe 代码块并自己检查正确性。</p> <h4 id="栈-pinning-和-pin-mut-t"><a href="#栈-pinning-和-pin-mut-t" class="header-anchor">#</a> 栈 Pinning 和 <code>Pin&lt;&amp;mut T&gt;</code></h4> <p>上一节我们学会了如何使用 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 来安全地创建一个堆分配的自引用值。虽然这个方法可以跑通且相对安全（除了不安全的构造函数），要求的堆分配是有性能损耗的。由于 Rust 总是想要尽可能地提供 <em>零代价抽象</em>，pinning API 也允许创建一个指向栈分配值的 <code>Pin&lt;&amp;mut T&gt;</code> 实例。</p> <p>和拥有被包装类型 <em>所有权</em> 的 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 实例不同的是，<code>Pin&lt;&amp;mut T&gt;</code> 实例只是临时借用被包裹的值。这让事情变得复杂，因为它要求程序猿提供额外的保证。最重要的是，<code>Pin&lt;&amp;mut T&gt;</code> 必须在被引用的 <code>T</code> 的整个生命期内保持 pinned，这对于栈上的值来说优点难以验证。为了缓解这个问题，出现了诸如 <a href="https://docs.rs/pin-utils/0.1.0-alpha.4/pin_utils/" target="_blank" rel="noopener noreferrer"><code>pin-utils</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这样的包，但是我依然不建议 pinning 到栈空间，除非我们非常清楚自己在干啥。</p> <p>更多资料参见 <a href="https://doc.rust-lang.org/nightly/core/pin/index.html" target="_blank" rel="noopener noreferrer"><code>pin</code> 模块<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的文档和 <a href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.new_unchecked" target="_blank" rel="noopener noreferrer"><code>Pin::new_unchecked</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法。</p> <h4 id="pinning-和-futures"><a href="#pinning-和-futures" class="header-anchor">#</a> Pinning 和 Futures</h4> <p>由前面可以看到，<a href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html#tymethod.poll" target="_blank" rel="noopener noreferrer"><code>Future::poll</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法以 <code>Pin&lt;&amp;mut Self&gt;</code> 参数的形式使用 pinning：</p> <h4 id="pinning-and-futures"><a href="#pinning-and-futures" class="header-anchor">#</a> Pinning and Futures</h4> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">poll</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Output</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个方法接收 <code>self: Pin&lt;&amp;mut Self&gt;</code> 而不是常规的 <code>&amp;mut self</code> 原因是 <a href="/_post/blog-os/blog-os-12-async-await/@/second-edition/posts/12-async-await/#self-referential-structs">前面</a>可以看到 async/await 创建的 future 实例通常是自引用的。把 <code>Self</code> 包装到 <code>Pin</code> 里面，让编译器为自引用的 futures 弃用 <code>Unpin</code>，这样就能保证 future 不会在调用 <code>poll</code> 时在内存里面移动。这确保所有内部引用依然有效。</p> <p>值得注意的是在第一次调用 <code>poll</code> 之前移动 future 是没有问题的。这是因为 future 是懒加载的，在第一次被轮询前不会做任何事。因此，生成状态机的 <code>start</code> 状态只包含函数实参，但是没有内部引用。为了调用 <code>poll</code>，调用者必须先把 future 包装到 <code>Pin</code>，这样能确保 future 不能在内存间移动。由于栈 pinning 要写正确难度不小，个人建议总是结合使用 <a href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.pin" target="_blank" rel="noopener noreferrer"><code>Box::pin</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.as_mut" target="_blank" rel="noopener noreferrer"><code>Pin::as_mut</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>如果感兴趣如何基于栈 pinning 安全地手码一个 future 组合器函数的话，可以看一下 <code>futures</code> 包精悍的 <a href="https://docs.rs/futures-util/0.3.4/src/futures_util/future/future/map.rs.html" target="_blank" rel="noopener noreferrer"><code>map</code> 组合器方法的源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 pin 文档的关于 <a href="https://doc.rust-lang.org/stable/std/pin/index.html#projections-and-structural-pinning" target="_blank" rel="noopener noreferrer">投影和结构化 pinning<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 相关小节。</p> <h3 id="执行器和唤醒器"><a href="#执行器和唤醒器" class="header-anchor">#</a> 执行器和唤醒器</h3> <p>借助 async/await，以完全异步的形式高效地使用 futures 变为可能。然而，如前面学到的，futures 在被轮询之前不会做任何事情。这意味着我们总得在某个时间点调用它们的 <code>poll</code>，否则的话，异步的代码永远都不会执行。</p> <p>只有一个 future 时，我们总能使用一个 <a href="#waiting-on-futures">上面描述的</a> 循环人为地等待每个 future。但是，这个方法是非常低效且对于创建大量 future 的程序是不现实的。这个问题的最常见解决方法是定义过全局的 <em>执行器</em>，让它负责轮询系统的所有 future 直至完成。</p> <h4 id="执行器"><a href="#执行器" class="header-anchor">#</a> 执行器</h4> <p>执行器的用途时允许把 future 创建为独立的任务，通常是借助 <code>spawn</code> 之类的方法。执行器负责轮询所有 future 直至它们完成。在中心化地方管理所有 future 最大好处是执行器可以在一个 future 返回 <code>Poll::Pending</code> 时切换到不同 future。因此，异步操作可以并发执行，CPU 也能一直保持繁忙。</p> <p>很多执行器实现也利用了多核 CPU 的系统。它们创建一个 <a href="https://en.wikipedia.org/wiki/Thread_pool" target="_blank" rel="noopener noreferrer">线程池<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，这个线程池能够在有任务执行时利用所有核，并利用诸如 <a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="noopener noreferrer">work stealing<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 等技巧来平衡不同核之间的载荷。嵌入式系统也有特殊的执行器实现，被优化到实现低时延和内存代价。</p> <h4 id="executors"><a href="#executors" class="header-anchor">#</a> Executors</h4> <p>为了避免不断轮询 futures 的代价，执行器通常也会利用 Rust future 支持的 <em>waker</em> API。</p> <h4 id="唤醒器"><a href="#唤醒器" class="header-anchor">#</a> 唤醒器</h4> <p>waker API 背后的思想是每次调用 <code>poll</code> 时传入一个特殊的 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html" target="_blank" rel="noopener noreferrer"><code>Waker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类似，包装在 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Context.html" target="_blank" rel="noopener noreferrer"><code>Context</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型中。这个 <code>Waker</code> 类型由执行器创建，被异步任务用于提示（局部）任务完毕。这样一来，执行器就不需要调用之前返回 <code>Poll::Pending</code> 的 future 的 <code>poll</code>，只需等待被相应的 waker 唤醒即可。</p> <p>用个小例子解释起来最快：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">write_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">async_write_file</span><span class="token punctuation">(</span><span class="token string">&quot;foo.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个函数异步地把字符串 &quot;Hello&quot; 写入 <code>foo.txt</code> 文件。由于硬盘写入需要一点时间，第一次调用这个 future 的 <code>poll</code> 很可能会返回 <code>Poll::Pending</code>。然而，硬盘驱动会内地里保存传给 <code>poll</code> 的 <code>Waker</code>，文件写入磁盘后用它通知执行器。这样在收到 waker 通知之前，执行器就不需要浪费任何时间来再次轮询 future 了。</p> <p>后续在实小节创建支持 waker 的执行器时，我们会看到 <code>Waker</code> 类型的工作细节。</p> <h3 id="合作式多任务-2"><a href="#合作式多任务-2" class="header-anchor">#</a> 合作式多任务？</h3> <p>本文开头我们谈到抢占式和合作式多任务。抢占式多任务依赖操作系统来强制切换运行的任务，而合作式多任务则要求任务日常通过 <em>yield</em> 操作自愿地放弃 CPU 的控制权。合作方式的最大好处是任务可以自己保存状态，从而实现更加高效的上下文切换和任务之间的栈空间的共享使用。</p> <p>一眼看上去可能不是那么明显，但是 future 和 async/await 其实时合作式多任务模式的一种实现：</p> <ul><li>每个添加到执行器的 future 都是一个合作式任务</li> <li>虽然没有使用显示的 yield 操作，但是 future 从通过返回 <code>Poll::Pending</code>（或者最后返回 <code>Poll::Ready</code>）的方式放弃 CPU 的控制权
<ul><li>没有其他事情能强制 future 放弃 CPU。如果想要的话，它们可以永远都不从 <code>poll</code> 返回，例如在一个循环里面自旋自嗨</li> <li>由于执行器的每个 future 可以阻塞其他 future 的执行，我们需要想起这些 future 不是恶意的</li></ul></li> <li>future 内地里会保存下次 <code>poll</code> 调用时继续执行所有需要的状态。借助 async/await，编译器自动检查所有需要的变量，把他们保存到一个生成的状态机里面
<ul><li>继续执行只需要保存最少的要求状态</li> <li>由于 <code>poll</code> 返回时放弃调用栈，同样的栈可用于轮询其他 future</li></ul></li></ul> <p>可以看到 future 和 async/await 和合作式多任务模式完美匹配，它们只是使用了一些不同的术语而已。往后部分，我们把任务和 future 看做一样的东西。</p> <h2 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h2> <p>理解基于 Rust 的 future 和 async/await 的合作式多任务之后，现在是时候把它添加到我们的内核中来了。由于 <a href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html" target="_blank" rel="noopener noreferrer"><code>Future</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 是 <code>core</code> 库的一部分，async/await 是语言本身的一个特性，<code>#![no_std]</code> 的内核使用它们不需要执行特别的操作。仅有的要求是因为 async/await 在 <code>2020-03-25</code> 之前尚未兼容 <code>no_std</code>，所以需要至少 <code>2020-03-25</code> 之后的 Rust 版本。</p> <p>使用足够新的 nightly 版 Rust，我们可以在 <code>main.rs</code> 中使用 async/await 了：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">async_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
    <span class="token number">42</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">example_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token function">async_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;async number: {}&quot;</span><span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>async_number</code> 函数是一个 <code>async fn</code>，所以编译器将其转换成实现 TODO 的状态机。由于函数只是返回 <code>42</code>，得到的 future 也就直接在第一次调用 <code>poll</code> 时返回 <code>Poll::Ready(42)</code>。和 <code>async_number</code> 类似，<code>example_task</code> 函数也是一个 <code>async fn</code>。它等待 <code>async_number</code> 返回的数值，然后调用 <code>println</code> 宏把它打印出来。</p> <p>为了运行 <code>example_task</code> 返回的 future，我们需要调用它的 <code>poll</code> 直至它返回 <code>Poll::Ready</code> 提示任务完毕。为此，我们需要创建一个简单的执行器类型。</p> <h3 id="任务"><a href="#任务" class="header-anchor">#</a> 任务</h3> <p>开始实现执行器之前，我们创建一个有 <code>Task</code> 类型的 <code>task</code> 模块：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/lib.rs</span>

<span class="token keyword">pub</span> <span class="token keyword">mod</span> <span class="token module-declaration namespace">task</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/mod.rs</span>

<span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token namespace">future<span class="token punctuation">::</span></span><span class="token class-name">Future</span><span class="token punctuation">,</span> <span class="token namespace">pin<span class="token punctuation">::</span></span><span class="token class-name">Pin</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">alloc<span class="token punctuation">::</span>boxed<span class="token punctuation">::</span></span><span class="token class-name">Box</span><span class="token punctuation">;</span>

<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Task</span> <span class="token punctuation">{</span>
    future<span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>Task</code> 结构体时一个新类型包装器，包裹一个 pinned、堆上分配的且动态分发的、以 <code>()</code> 为输出的 future。让我们细看一下：</p> <ul><li>我们要求和任务关联的 future 返回 <code>()</code>。这意味着任务不会返回任何值，它们的执行只为副作用。例如，上面定义的 <code>example_task</code> 函数没有任何返回值，但是往屏幕打印一些东西作为副作用</li> <li><code>dyn</code> 关键字表明我们在 <code>Box</code> 里面存储了一个 <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html" target="_blank" rel="noopener noreferrer"><em>trait object</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。这意味着 future 上的方法会 <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch" target="_blank" rel="noopener noreferrer"><em>动态分发</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，这样就能把不同类型的 future 保存到 <code>Task</code> 类型里面。因为每个 <code>async fn</code> 都有自己的类型，我们想要创建不同的任务，所以这一点是非常重要的</li> <li>如我们在 <a href="#pinning">关于 pinning</a> 节学到的那样，<code>Pin&lt;Box&gt;</code> 类型把值方法放到堆上，防止创建出其 <code>&amp;mut</code> 引用，从而保证这个值无法在内存里面移动。因为 async/await 生成的 future 可能是自引用的，即包含指向自身的指针，future 移动会使得这些指针变得不合法</li></ul> <p>为了基于 future 创建一个新的 <code>Task</code> 结构体，我们新建一个 <code>new</code> 函数：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/mod.rs</span>

<span class="token keyword">impl</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>future<span class="token punctuation">:</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">+</span> <span class="token lifetime-annotation symbol">'static</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>
        <span class="token class-name">Task</span> <span class="token punctuation">{</span>
            future<span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">pin</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这个函数接收任何输出类型为 <code>()</code> 的 future，并借助 <a href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.pin" target="_blank" rel="noopener noreferrer"><code>Box::pin</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数把它固定在内存里面。然后把打包的 future 包裹到 <code>Task</code> 结构体里面并返回。这里要求 <code>'static</code> 生命期是因为返回的 <code>Task</code> 可以存活任意长的时间，所以 future 也需要在这段时间内保持有效。</p> <p>我们也添加一个 <code>poll</code> 方法使得执行器可以轮询存储的 future：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/mod.rs</span>

<span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Context</span><span class="token punctuation">,</span> <span class="token class-name">Poll</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> context<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>future<span class="token punctuation">.</span><span class="token function">as_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>由于 <code>Future</code> trait 的 <a href="https://doc.rust-lang.org/nightly/core/task/enum.Poll.html" target="_blank" rel="noopener noreferrer"><code>poll</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法其他以 <code>Pin&lt;&amp;mut T&gt;</code> 类型调用，我们首先使用 <a href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.as_mut" target="_blank" rel="noopener noreferrer"><code>Pin::as_mut</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法转换 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 类型的 <code>self.future</code> 字段。然后，调用转换后 <code>self.future</code> 字段的 <code>poll</code>  方法，返回结果。由于 <code>Task::poll</code> 方法只会被我们后续创建的执行器调用，所以我们保持 <code>task</code> 模块的函数私有化。</p> <h3 id="简易执行器"><a href="#简易执行器" class="header-anchor">#</a> 简易执行器</h3> <p>由于执行可以非常复杂，我们特意先实现一个非常基础的执行，后续在实现一个功能更加强大的执行器。为此，我们首先创建一个 <code>task::simple_executor</code> 子模块：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/mod.rs</span>

<span class="token keyword">pub</span> <span class="token keyword">mod</span> <span class="token module-declaration namespace">simple_executor</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/simple_executor.rs</span>

<span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">::</span><span class="token class-name">Task</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">alloc<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token class-name">VecDeque</span><span class="token punctuation">;</span>

<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">SimpleExecutor</span> <span class="token punctuation">{</span>
    task_queue<span class="token punctuation">:</span> <span class="token class-name">VecDeque</span><span class="token operator">&lt;</span><span class="token class-name">Task</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">SimpleExecutor</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">SimpleExecutor</span> <span class="token punctuation">{</span>
        <span class="token class-name">SimpleExecutor</span> <span class="token punctuation">{</span>
            task_queue<span class="token punctuation">:</span> <span class="token class-name">VecDeque</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">spawn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> task<span class="token punctuation">:</span> <span class="token class-name">Task</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>task_queue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>这个结构体包含一个 <a href="https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html" target="_blank" rel="noopener noreferrer"><code>VecDeque</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型的 <code>task_queue</code> 字段，这个 <a href="https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html" target="_blank" rel="noopener noreferrer"><code>VecDeque</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型支持头尾的压入和弹出操作。这个类型背后的基本思想是我们借助 <code>spawn</code> 方法在尾部插入新人物，从头部弹出下一个要执行的任务。这样我们就会得到一个简单的 <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" target="_blank" rel="noopener noreferrer">FIFO 队列<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> （<em>先进先出</em>）。</p> <h4 id="dummy-waker"><a href="#dummy-waker" class="header-anchor">#</a> Dummy Waker</h4> <p>为了调用 <code>poll</code> 方法，我们需要创建一个 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Context.html" target="_blank" rel="noopener noreferrer"><code>Context</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型用来包装 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html" target="_blank" rel="noopener noreferrer"><code>Waker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>  类型。简单起见，我们首先会创建一个什么都不做的无聊 waker。为此，我们创建一个 <a href="https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html" target="_blank" rel="noopener noreferrer"><code>RawWaker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 实例，定义不同 <code>Waker</code> 方法的实现，然后使用 <a href="https://doc.rust-lang.org/stable/core/task/struct.Waker.html#method.from_raw" target="_blank" rel="noopener noreferrer"><code>Waker::from_raw</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数把它转化为一个 <code>Waker</code>：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/simple_executor.rs</span>

<span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Waker</span><span class="token punctuation">,</span> <span class="token class-name">RawWaker</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">dummy_raw_waker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">RawWaker</span> <span class="token punctuation">{</span>
    <span class="token macro property">todo!</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">dummy_waker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Waker</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token class-name">Waker</span><span class="token punctuation">::</span><span class="token function">from_raw</span><span class="token punctuation">(</span><span class="token function">dummy_raw_waker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>因为如果程序猿没有遵循 <code>RawWaker</code> 文档的要求会触发未定义行为，所以 <code>from_raw</code> 函数是不安全的。细看 <code>dummy_raw_waker</code> 函数的实现之前，我们首先尝试理解一下 <code>RawWaker</code> 类型是如何工作的。</p> <h5 id="rawwaker"><a href="#rawwaker" class="header-anchor">#</a> <code>RawWaker</code></h5> <p><a href="https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html" target="_blank" rel="noopener noreferrer"><code>RawWaker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型要求程序猿显示地定义 <a href="https://en.wikipedia.org/wiki/Virtual_method_table" target="_blank" rel="noopener noreferrer">虚函数表<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> （<em>vtable</em>），注明 <code>RawWaker</code> 被复制、唤醒或者清除时应该调用的函数。这个 vtable 的布局由 <a href="https://doc.rust-lang.org/stable/core/task/struct.RawWakerVTable.html" target="_blank" rel="noopener noreferrer"><code>RawWakerVTable</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型定义。每个函数接收一个 <code>*const ()</code> 参数，这个参数基本上是某个（例如堆上分配的）结构体 <em>类型擦除</em> 后的 <code>&amp;self</code> 指针。因为 <code>RawWaker</code> 类型应该是非泛型的，但仍能支持任意类型，所以使用的 <code>*const ()</code> 指针而不是一个合适的引用类型。创建函数的指针是传给 <a href="https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html#method.new" target="_blank" rel="noopener noreferrer"><code>RawWaker::new</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的 <code>data</code> 指针。</p> <p>通常 <code>RawWaker</code> 是为包装为 <a href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html" target="_blank" rel="noopener noreferrer"><code>Box</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或 <a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html" target="_blank" rel="noopener noreferrer"><code>Arc</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型的堆分配的某些结构体创建的。对于这些类型，例如 <a href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html#method.into_raw" target="_blank" rel="noopener noreferrer"><code>Box::into_raw</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的方法可用于把 <code>Box&lt;T&gt;</code> 转化为一个 <code>*const T</code> 指针。这个指针然后可以转换为一个匿名的 <code>*const ()</code> 指针，传给 <code>RawWaker::new</code>。由于每个 vtable 函数都接收同样的 <code>*const ()</code> 作为参数，所以这些函数可以安全地转换回一个 <code>Box&lt;T&gt;</code> 或 <code>&amp;T</code>，然后对其执行操作。可以想到，这个过程是高度危险的，很容易不经意间就会导致未定义行为。因此，除非逼不得已，否则非常不建议手动创建 <code>RawWaker</code>。</p> <h5 id="一个无聊的-rawwaker"><a href="#一个无聊的-rawwaker" class="header-anchor">#</a> 一个无聊的 <code>RawWaker</code></h5> <p>虽然不推荐手动创建 <code>RawWaker</code>，现在没有其他方法可以创建一个什么都不做的无聊的 <code>Waker</code>。好在，我们没想做什么事，所以实现 <code>dummy_raw_waker</code> 函数是相对安全的：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/simple_executor.rs</span>

<span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token class-name">RawWakerVTable</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">dummy_raw_waker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">RawWaker</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">no_op</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">clone</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">RawWaker</span> <span class="token punctuation">{</span>
        <span class="token function">dummy_raw_waker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> vtable <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token class-name">RawWakerVTable</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> no_op<span class="token punctuation">,</span> no_op<span class="token punctuation">,</span> no_op<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">RawWaker</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vtable<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>首先，我们定义两个名为 <code>no_op</code> 和 <code>clone</code> 的内部函数。<code>no_op</code> 函数接收一个 <code>*const ()</code> 指针，没有做任何事。<code>clone</code> 函数也接收一个 <code>*const ()</code> 指针，调用 <code>dummy_raw_waker</code> 返回一个新的 <code>RawWaker</code>。我们使用这两个函数创建一个最小化的 <code>RawWakerVTable</code>：<code>clone</code> 函数在执行克隆操作时使用，<code>no_op</code> 函数用作其他所有操作。由于 <code>RawWaker</code> 没有做什么事，所以没有克隆 <code>RawWaker</code> 而不在 <code>clone</code> 里面返回一个新的 <code>RawWaker</code> 问题也不大。</p> <p>创建 <code>vtable</code> 之后，我们使用 <a href="https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html#method.new" target="_blank" rel="noopener noreferrer"><code>RawWaker::new</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数创建 <code>RawWaker</code>。因为没有 vtable 函数使用它们，所以传入的 <code>*const ()</code> 不重要。因此，我们只要单纯传入一个空指针即可。</p> <h4 id="一个-run-方法"><a href="#一个-run-方法" class="header-anchor">#</a> 一个 <code>run</code> 方法</h4> <p>现在有了创建 <code>Waker</code> 实例的方法，我们可以用它为执行器实现一个 <code>run</code> 方法。最简单的 <code>run</code> 方法是在循环里面不断地轮询所有队列中的任务直到所有任务完成。因为没有利用 <code>Waker</code> 类型的提醒功能，所以这种方式不是非常高效，但是这是把东西跑起来最简单的方式：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/simple_executor.rs</span>

<span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Context</span><span class="token punctuation">,</span> <span class="token class-name">Poll</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">SimpleExecutor</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token keyword">mut</span> task<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>task_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> waker <span class="token operator">=</span> <span class="token function">dummy_waker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> <span class="token keyword">mut</span> context <span class="token operator">=</span> <span class="token class-name">Context</span><span class="token punctuation">::</span><span class="token function">from_waker</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waker<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">match</span> task<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// task done</span>
                <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=&gt;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>task_queue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这个函数使用一个 <code>while let</code> 循环处理 <code>task_queue</code> 里的所有任务。对于每个任务，它首先创建一个包裹 <code>dummy_waker</code> 函数返回的 <code>Waker</code> 实例的 <code>Context</code> 类型。然后以这个 <code>context</code> 调用 <code>Task::poll</code> 方法。如果 <code>poll</code> 方法返回 <code>Poll::Ready</code>，这个任务就完成了，我们继续执行下一个任务即可。如果任务仍然是 <code>Poll::Pending</code>，我们把它再次添加到队列末尾使得它能够在后续循环迭代中再次被轮询。</p> <h4 id="尝试一下"><a href="#尝试一下" class="header-anchor">#</a> 尝试一下</h4> <p>借助 <code>SimpleExecutor</code> 类型，我们现在可以在 <code>main.rs</code> 里面尝试运行 <code>example_task</code> 函数返回的任务了。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">use</span> <span class="token namespace">blog_os<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Task</span><span class="token punctuation">,</span> <span class="token namespace">simple_executor<span class="token punctuation">::</span></span><span class="token class-name">SimpleExecutor</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token comment">// […] initialization routines, including `init_heap`</span>

    <span class="token keyword">let</span> <span class="token keyword">mut</span> executor <span class="token operator">=</span> <span class="token class-name">SimpleExecutor</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token class-name">Task</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">example_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// […] test_main, &quot;it did not crash&quot; message, hlt_loop</span>
<span class="token punctuation">}</span>


<span class="token comment">// Below is the example_task function again so that you don't have to scroll up</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">async_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
    <span class="token number">42</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">example_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token function">async_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;async number: {}&quot;</span><span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>运行后，可以看到屏幕打印出预期的 <em>&quot;async number: 42&quot;</em> 信息：</p> <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAuQAAAHfCAYAAAAY8c2WAAAABHNCSVQICAgIfAhkiAAAABl0RVh0U29mdHdhcmUAZ25vbWUtc2NyZWVuc2hvdO8Dvz4AAAApdEVYdENyZWF0aW9uIFRpbWUARG8gMTkgTeRyIDIwMjAgMTY6NDM6MzIgQ0VUtAMXtwAAGrBJREFUeJzt3XmQleW94PHfgWZvEVmMBIxGwBJjbnmDTq7NuOaCOqIsdYEsU5q1MuVEU5OMk3vHLGPKTDLJpLSSDDEzVsqUSal4IaiIiDoZQ8ENKCGLcSN4NSIEaXZpu5umz/zR0tL7aTjNr5v+fKqoos953vd93qOlX16e9z0RAAAAAAAAAAAAAAAAAAAAAAAAAAA9otDN8aMjYnxEVEbEwPJPBwAA+qxDEfFWRGyNiN2lbtSdIH/f+8aPnzfz8un/fejQocMKhe62PAAAnLiKxWK8XVtb+/TaZ//Hn1999acR8ZdStiu1qkdPGD/++utmXnbHgbffjvr6g1EsFo9+tgAAcIIpFAoxeNCgGD58WDyy6v/9pze2bftZlHClvNQg/8ANC+atq6+vG9EoxAEAoEMDCoUYPHjwWz9b/Mu/i4g/dTm+xP1WNhYPDRfjAADQucZiMRqLjSOi6b7LLpUa5AMPHmywaBwAAErwTjuX9BCUUoPcmnEAAChRd9q55CAHAADKT5ADAECiiuwJAABAtkJEjBt2MEYOOhQREXvrK6K6tiKOx6JtQQ4AQL81ekhDXDlxX0wbeyBOHnyoxXt76gfGb6tHxONbRsauup7LZkEOAEC/NGPCvph75u4YNKD96+CjBh+KK967Ly4+bX8sffWUePKNkT0yD0EOAEC/84nJO+Oy8ftLGjtoQDEWnrUrxg1tiPs2jy77XNzUCQBAvzJjwr6SY/xIV7x3X3xkwr6yz8cVcoBk0y+5LK6YcWVMmHh6VO94M55Z9y/xyC+XRGNjY1QMGhR333t/m21++pNF8etfPRVfv/07cdbkKbFt6xvxT1+6OSIiZlx1TXzik5+OiIhvfePWqDlwIL71P++Mf31lc9z2X/9LREScMnp03LHo/7TYDqA/GD2kIeaeufuot5935u74bfXw2F3GNeWCHCDR1dfOjoWfuD7+unVrPLVqZZx9ztSYO/+jMfH098X/uvP7zePq6upiyf2/aP75T3/8Q0REjKg8KYrFYpw2/r0xYkRlHDjwVrx/0uQoFotRKBRiRGVl1Bw4cNzPC6C3umri3jZrxivm/TRi4KBoeOTmiNp3Yn3oKVFx3Q8jDtZGwy8/2zx28IBiXDlxX9xfxqUrlqwAJBlRWRnXzfuHqK+vj2/9t1vjwft+Ht/55tdj65YtceHfVcVZk6c0j62vr4tVjz3a/Gtn9Y6IiKg8qTK2vP6XKBQKcdbkyRERcdakyfH6X15rer+y8vifGEAvVYiIvx1b0/aNisFROPXcqJhzV8TQU5pifM5dURg3NWLQ0DbDp409EIUyzkuQAySZcvY5MWzY8HjxT8/F/n1NaxIPHToUG55dFxERH/jg33S6faFQiOHDR8Trr70WtbW1MWnK2TFs2LB4z/jxsenFFyIiYsSIk3r2JAD6kLFDG2JUq0cbRkQ0PHJTFHdtjsKYyVEx566mGB8zOYo7/xwNj9zUZvyowYdizNCGss1LkAMkGXfqeyIiYveunS1e37Nr9zvvn9b82kknjYx77l8S99y/JG7/3h0R0XSFvVAoRGPjodi86eWYNOXsOPOsSVEoFOLll15sHgNAk5MHdxDRb++Ohl9+Poo7N0VhzOSmGN/9ajQ8/B8j3m5/vfmojvZ1FKwhB0hSGND0F56tn35bfOeVgQPfvWZSV1cXi39xb0REHDjQ9GSAESPeje1NL70QM6+eFWdNmhI7q6ubl7QIcoBjcTy+p1OQA6TZsX17RESMOuWUFq+PGjUqIiLe3P7X5tfq6+viqVWPtRh3eH34wYMHY9NLL8acf1gYF118SWze9HLU19c3jykWm/6HMqji3f/kDxo0OCIiGhsby3lKAL3a3voO0vfwmvExk6O4a3NERBRGT4qK6xZFw7L/8O6NnkfY09G+joIlKwBJNm96Oerr6mLqBz7YfLW7UCjE+dMujMbGxli3dk2n2484qWl9eF1tbWze9HI0NjbGxNPfF6/8+eWoffvtpjGVJ8XO6h1RLBZj/ISJMXRo081Jk6acHRERO97c3lOnB9DrVNdWxJ76gW1er7juh80x3rDs89Gw7PPvrim/7odtxu+pHxg7az32EKDP27dvb6x89OG4bt78+MdvfDPWr10TZ089N05/3xlx/70/i79u2xoVgwZFRMTgwUNi5tXXNG+7edPLzVfIa2tro7a2Nl5+8YWYcPrpsenll6K2tjYimpas1NXVxTO/+Zf4NxdVxRdv+ad4ZfOmuOjfXhIREU8/9eRxPmuAPMWI+G31iLjiva2+3KehPoo7Xmi6gfOdNeMNyz4fFdf+MKKhrs1+NlSPKOtiFkEOkGjp4vtj3969cckVfx9z5i+MgQMHxt49e+I948fHBz74N/HSO09LGTJkSHz8hk83b7fsnx+IA281PV+8rq4pvr/zza83vz94yJCIiKisbLqK/tP/vSj27t0dfzvtwjhr8pTYvm1rLP7FvbFxwzPH5TwBeouVW0bGxaftb/Es8oaln2478O3d0bD437d5ub6xECtfP7mscyr1EYpVC2f/u87/7hSAYzJgwIAYM3ZsVF18aVw3b368uf2v8Y1//M/N68EBKI+/n7AvFp6166i2vW/z6Pi/W0eWNPaBh1ZMj4i1XY1zhRygl2hsbIwdb74ZDy15MF56/vnYt3+vGAfoAU++MTLGDW1ou3SlC09tHVlyjHeHIAfohV584U/ZUwA4od23eXTsqK2IeWfubrF8pT0HGwvxz/96So/EeIQgBwCgn3ryjZHx7I4RcdXpe2Pa2ANtvsVzT/3A2LBjRDy25eTY287TWcpFkAMA0G/tqR8Y928eHQ9sHh1jhzY0f5vn3vqKqK6tOC5fDSTIAQDo94oRsaO2InaU8fnipfLFQAAAkEiQAwBAIkEOAACJBDkAACQS5AAAkEiQAwBAIkEOAACJSn7Q4s5de3pyHgAA0C+VHOQPP/5kT84DAABOKMOHDy9pnCUrAACQSJADAEAiQQ4AAIkEOQAAJBLkAACQSJADAEAiQQ4AAInKGuQzZsyIGTNmRENDQ5v3PvWpT8W0adPi0KFDR73/PXv2xLRp02Lnzp1t3tu+fXtMmzYt9u/ff9T7P1Y33nhjfP/732/3vS9/+ctx22239Yp5AgDQe5T9CvmQIUPi17/+dYvXXn311di+fXu5D9XCuHHjYtWqVVFZWdmjx+nM/PnzY/ny5VFfX9/i9erq6li9enXMnz+/V8wTAIDeo+xBfvHFF8eyZctavLZs2bKYPn16i9fWr18fH//4x2PWrFlxzTXXxN1339383nPPPRfXX399XH311TF//vxYvXp1i21/85vfxIIFC+LSSy+Nm266KWpqamLHjh0xc+bMeOutt2LXrl0xbdq0eOKJJ+LGG2+MhQsXxhe+8IWoqamJiIgXXnghPvvZz8a8efNiwYIF8fOf/7ws537ppZfGsGHD4oknnmjx+kMPPRTnnHNOnHvuuS3m2dlcZs2aFevXr4+IiMbGxrjsssviu9/9bvM+b7vttvjxj39clnkDAJCn7EF++eWXx8aNG5uviDc0NMSKFSviqquuah5z8ODB+MpXvhLXX399LF++PBYtWhR33313/PGPf4yampr44he/GJ/73Ofisccei1tvvTVuueWWqK6ubt7+97//fdx3333x2GOPxRtvvBErVqxoeVIDmk7rpZdeikWLFsV9990XO3fujBUrVkRNTU3cfPPNce2118bSpUvjJz/5SSxevDiefvrpYz73AQMGxLx582LJkiXNrxWLxXjooYdi/vz5bcZ3NpeLLrooNmzYEBFN0T5p0qR49tlnm7d95pln2vwhBwCAvqfsQV5ZWRlXXHFFPPzwwxERsXr16nj/+98fEydObB4zaNCgWL58ecycOTMiIs4444yYOHFivPbaa7F+/foYPHhwXHzxxRERcf7558eqVatizJgxzdt/7GMfi4EDB8bw4cPjvPPOi61bt7Y7l2uvvbbpJAcMiClTpsTWrVtj/fr1USgUYvbs2RERccopp8SsWbNi5cqVZTn/uXPnxvPPPx+bN2+OiIh169bF/v3748orr2wztrO5VFVVNQf4unXr4rLLLovGxsbYtWtXbNmyJWpqauK8884ry5wBAMhT0RM7nTt3bnz1q1+Nz3zmM7Fs2bKYM2dOmzGPPvporFy5MhoaGqJQKMS2bduiWCxGdXV1nHzyyS3Gjhw5ssOfC4VChzeKHrlO+/C4nTt3xr59+2LWrFnN7x08eDAmT558VOfa2pgxY+Lyyy+PpUuXxi233BJLly6N2bNnx+DBg9uM7WwuH/7wh+NrX/ta1NXVxbp16+Lmm2+O119/PTZs2BD79++Piy66qPlvAgAA6Lt6JMjPP//8GDJkSPzqV7+K5557Lr73ve/F7t27m99fu3Zt/OhHP4p77703zjjjjIiImDdvXkREjB07ts1TVF577bUYN25cWeY2bty4GDt2bCxfvrws+2vP/Pnz40tf+lLccMMNsXr16njwwQePai5Tp06NZ555Jl555ZWYOnVqbNmyJZ599tnYu3dvXHLJJT02fwAAjp8eu8Q6d+7cuOOOO2LmzJltrg7v2rUrRo0aFRMmTIiIiCVLlsSuXbuipqYmLrzwwjh06FBzpP7hD3+Ij370o803ZB6rCy64IOrq6uLxxx+PiKYr0nfccUebG0ePxYc+9KE49dRT4/bbb48LLrigxXKd7sylqqoq7rnnnjjvvPNiwIABccEFF8SGDRti48aNUVVVVbb5AgCQp8eCfNasWVFdXd3ucpWPfOQjceaZZ8acOXNiwYIFUSwW45Of/GTcdddd8bvf/S7uvPPOWLx4ccyYMSNuu+22+Pa3vx1jx44ty7yGDx8eP/jBD+LBBx+M2bNnx9y5c2P//v0xbdq0suz/sAULFsSaNWvavZmz1LlUVVXFxo0b48ILL4yIpuUwxWIxTjvttBg1alRZ5wsAQI5CieOqampq1vToTAAA4AQyfPjw6RGxtqtx7goEAIBEghwAABIJcgAASCTIAQAgkSAHAIBEJX8x0LZt23pyHgAA0C+VHOSTJk3qyXkAAEC/ZMkKAAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkqih1YLG4MCIiCoUHOn2tu/vrbPtSxhyrjs7hWM6t1GN2tf/ufEY99fkAANCz0q6QlxKQJ2pklnpeXY07MtiP/D0AAH2HJSsAAJCo5CUrpWrvSm1PLzfpDcc6culIOZbauOINANA/dPsKebG4sPlXe+9FNEXo4V9Hvl5Ove1YrV87lvmUui78yPdP1OU9AAAnum5fIW/vqnBrffXqbrlukDyW7d2kCQDQv5R9yUqEmDzM5wAAQFd6JMj7or76xBLRDwDQt/X4U1Y6Wm/eW7Reh93X1mX39s8XAIDOlTXIj7yR8chQbC9sS7ki3dmY7hzrWJVyrO5cYe/OefXkzaoAAOQrlDiuKiLW9OREAADgBDM9ItZ2NcgXAwEAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJfDNTLHPl4w77wHPT2dPQIyvYe3dhXzxEAoFxcIe9l+nqgdvVM+cNfvuT56gAATVwhJyI6vqp9NPtoT1//gwYAQE8pe5B39M2TnY1pPa6zb8JsfWW1UHig02Ue5VgmUcqxOptfe3PpbFxH+2zvvSN1NJ/jsQymo+OVMh4AoD8r+5KVrpYklGvpwpHbdbSf43ms7ioWF7Y7146O23rbw+93NJ+Ogr+jOR+5n6M5lyOPUe7xAAAnsrIH+eHQ7Cz8Do878rXjFWfH81idzaG933c2tr3Ps6vPutRjlEspf8gQ4wAALZV1yUp3rsYeGW/i7Oh093Prqc+5o2VCpb4OANCfpT1lxZM2epdSrrQf6/4jxDgAQGtHFeTHEm+ttz3eUd7T4ZmlL55XX5wzAEC5lXXJSntLUQ7/fDi8W485ctuO9lOu+bR3rHIp5dy7q6Ono5RyXq3Xcpe6Vv1YdXVcAQ4A0FKhxHFVEbGmJyfSFUseAADoY6ZHxNquBvWJb+oU4wAAnKh65Td1luPLfAAAoC/olUEuvgEA6C/6xJIVAAA4UQlyAABI1O0lK6U+QvBYHvfX0fE6O1Zn75e6n+OpXJ9Pb9Ddz9ZNugAA7+r2FfLWz8NuTzmfNV2uaOtN8XeiPYu7O59t6+eUAwD0d73yps7u6k2xDQAA3VHWIG99xfNYlyaUcgW1O0tajlbrb9/s6HhdPa6xnJ9Pqcfq7pzbm0t3H0NpSQoAQOnKelNnofBAmyUtxxrjx/qV7+WIw8PbHl73feTP7R2nozHl+nxKPVbrsa3HdLWPUo/VenxnY0pZ8gQA0J/0yiUr5brC2p+u1HZ2jqXe7NrRtsXiwhahfbTHAgCgLY897EdaX5FvffW7s+0Oj3cjJgBAeQlySlLKcpWj2RcAQH/X40HuqmrnyvX59NTn3Hq/5Yhy/04AALyrUOK4qohYE9G9LwbqakxnWm/f0XrwruZT6n5KnU9HN0u2N5fOjlPOz6e9/RztP6ejOa9SbiZt75iukgMAJ7jpEbG2q0HdDnIAAKAkJQW5NeQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJBIkAMAQCJBDgAAiQQ5AAAkEuQAAJDoqIK8WFwYxeJCY4wxxhhjjDEG4Bi5Qg4AAIkKJY6riog1PTkRAAA4wUyPiLVdDXKFHAAAEglyAABIJMgBACBRRTfGTu+xWQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAsfr/wGyl1qVMUBoAAAAASUVORK5CYII=" alt="QEMU 显示 &quot;Hello World&quot;、&quot;async number: 42&quot; 和 &quot;It did not crash!&quot;"></p> <p>让我们小结一下这个例子涉及的多个步骤：</p> <ul><li>首先，我们用一个空的 <code>task_queue</code> 创建 <code>SimpleExecutor</code> 类型的实例</li> <li>然后，调用异步的 <code>example_task</code> 函数，得到一个 future。我们把这个 future 包装到 <code>Task</code> 类型里面，包装过程会把 future 移到堆上比固定它，然后调用 <code>spawn</code> 方法把任务添加到执行器的 <code>task_queue</code></li> <li>接下来调用 <code>run</code> 方法开始执行队列中单个任务的执行。这会涉及
<ul><li>从 <code>task_queue</code> 头部弹出任务</li> <li>为任务创建一个 <code>RawWaker</code>，转化为 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html" target="_blank" rel="noopener noreferrer"><code>Waker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 实例，然后基于它创建一个 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Context.html" target="_blank" rel="noopener noreferrer"><code>Context</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 实例</li> <li>以刚才创建的 <code>Context</code> 调用任务 future 的 <a href="https://doc.rust-lang.org/nightly/core/task/enum.Poll.html" target="_blank" rel="noopener noreferrer"><code>poll</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法</li> <li>由于 <code>example_task</code> 没有等待任何事，它会在第一次调用 <code>poll</code> 时直接结束。这时 <em>&quot;async number: 42&quot;</em> 行打印出来</li> <li>由于 <code>example_task</code> 直接返回 <code>Poll::Ready</code>，它不会再放回任务队列</li></ul></li> <li><code>run</code> 方法在 <code>task_queue</code> 变空之后返回。<code>kernel_main</code> 函数继续执行，打印出 <em>&quot;It did not crash!&quot;</em> 消息</li></ul> <h3 id="异步键盘输入"><a href="#异步键盘输入" class="header-anchor">#</a> 异步键盘输入</h3> <p>我们的简易执行器没有利用 <code>Waker</code> 的提醒功能，只是简单地遍历所有任务直至任务完毕。由于 <code>example_task</code> 可以在第一次 <code>poll</code> 调用时直接跑完，所以在这里还不是个问题。为了看一下合适 <code>Waker</code> 实现的性能优势，我们首先需要创建一个真正异步的任务，即很可能在第一次调用 <code>poll</code> 时返回 <code>Poll::Pending</code> 的任务。</p> <p>我们的系统已经存在了一定程度的异步性，可用于验证这个功能：硬件中断。在 <a href="/_post/blog-os/blog-os-12-async-await/@/second-edition/posts/07-hardware-interrupts/">中断</a> 那篇文章我们学到，硬件中断可以出现在任意时间点，由外部设备决定。例如，硬件时钟会在某个预订的时间后给 CPU 发送一个中断。当 CPU 接收到这个中断时，它会立即把控制权转交给中断描述符表（IDT）预定义的相应处理函数。</p> <p>往下部分，我们将会创建基于键盘中断创建一个异步任务。键盘中断既具有不确定性也要求超低延时，所以是一个非常好的候选。不确定性意味着因为完全取决于用户，所以没有途径能够预测下一次按键的时间。低延时意味着我们想要准时地处理键盘输入，否则用户会看到一个延时。为了高效地支持这个任务，执行器支持合理的 <code>Waker</code> 提醒功能就非常必要了。</p> <h4 id="扫描码队列"><a href="#扫描码队列" class="header-anchor">#</a> 扫描码队列</h4> <p>当前，我们直接在中断处理函数俩米直接处理键盘输入。长期来说这不是个好主意，因为中断处理函数可能会中断重要的工作，他们应该保持短小。中断处理函数应该只执行最少必要的工作（例如，读取键盘扫描码），而把剩下的工作（例如翻译扫描码）下放给后台任务。</p> <p>给后台任务分发工作的常见模式时创建某种队列。中断处理函数把工作单元添加到队列，后台进程处理队列的中国。应用到我们的键盘中断，这意味着中断处理函数只读取键盘输入的扫描码，把它添加到队列，然后返回。键盘任务在队列的另一端，翻译并处理传过来的每个扫描码：</p> <p><img src="/assets/img/scancode-queue.87b6871f.svg" alt="底部的扫描码队列有 8 个插槽。左边底部键盘中断处理函数通过 &quot;push scancode&quot; 箭头从队列左边添加扫描码。底部又变的键盘任务从队列的 &quot;pop scancode&quot; 箭头读取扫描码"></p> <p>那个队列的简单实现可以是一个 mutex 加持的 <a href="https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html" target="_blank" rel="noopener noreferrer"><code>VecDeque</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。然而，因为很容易会导致死锁，所以在中断处理函数里面使用 mutex 不是个好主意。例如，当键盘任务已经锁住队列时用户按下键盘，中断处理函数会试图再次获得锁而一直卡住。这种方法的另一个问题是 <code>VecDeque</code> 容量满时会自动扩容，触发新的堆内内存分配。因为我们的分配器内部也使用了 mutex，所以这也会再次导致死锁。还有问题是堆碎片化后堆内存分配可能会失败或者耗费大量时间。</p> <p>为了防止这个问题，我们需要一个 <code>push</code> 操作时不要求 mutex 或内存分配的队列实现。这样的队列可以借助无锁的 [原子操作] 来添加或者弹出元素。这样就可能创建只要求 <code>&amp;self</code> 引用的 <code>push</code> 和 <code>pop</code> 操作，从而可以没有 mutex 也可以使用。为了防止 TODO 时的内存分配，队列可以采用一个预分配的、固定大小的缓冲区。虽然这会使得队列 <em>有界</em>（即，有最大长度），但是实践中为队列长度定义合理的上界通常是可能的，所以这不是个大问题。</p> <h5 id="crossbeam-包"><a href="#crossbeam-包" class="header-anchor">#</a> <code>crossbeam</code> 包</h5> <p>正确且高效地实现这么个队列是非常困难的，所以个人建议使用现有的、测试全面的实现。<a href="https://github.com/crossbeam-rs/crossbeam" target="_blank" rel="noopener noreferrer"><code>crossbeam</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 正是这样实现多种无 mutex 并发编程的 Rust 项目之一。它提供名为 <a href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html" target="_blank" rel="noopener noreferrer"><code>ArrayQueue</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的类型正是我们当前场景需要的。而且我们非常幸运：这个类型借助分配支持能够兼容 <code>no_std</code> 包。</p> <p>为了使用这个类型，我们添加对 <code>crossbeam-queue</code> 的依赖：</p> <div class="language-toml line-numbers-mode"><pre class="language-toml"><code><span class="token comment"># in Cargo.toml</span>

<span class="token punctuation">[</span><span class="token table class-name">dependencies.crossbeam-queue</span><span class="token punctuation">]</span>
<span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">&quot;0.2.1&quot;</span>
<span class="token key property">default-features</span> <span class="token punctuation">=</span> <span class="token boolean">false</span>
<span class="token key property">features</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">&quot;alloc&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>默认情况下，这个包依赖标准库。为了兼容 <code>no_std</code>，我们需要禁用其默认特性，并开启 <code>alloc</code> 特性。<span class="gray">（需要注意的是依赖主 <code>crossbeam</code> 包行不通，因为它缺失 <code>no_std</code> 需要的 <code>queue</code> 模块。博主本人已经提交了一个 <a href="https://github.com/crossbeam-rs/crossbeam/pull/480" target="_blank" rel="noopener noreferrer">pull request<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 处理这个问题，但是尚未发布到 crates.io）</span></p> <h5 id="队列实现"><a href="#队列实现" class="header-anchor">#</a> 队列实现</h5> <p>借助 <code>ArrayQueue</code> 类型，我们现在可以在新的 <code>task::keyboard</code> 模块创建一个全局的扫描码队列：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/mod.rs</span>

<span class="token keyword">pub</span> <span class="token keyword">mod</span> <span class="token module-declaration namespace">keyboard</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/keyboard.rs</span>

<span class="token keyword">use</span> <span class="token namespace">conquer_once<span class="token punctuation">::</span>spin<span class="token punctuation">::</span></span><span class="token class-name">OnceCell</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">crossbeam_queue<span class="token punctuation">::</span></span><span class="token class-name">ArrayQueue</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token constant">SCANCODE_QUEUE</span><span class="token punctuation">:</span> <span class="token class-name">OnceCell</span><span class="token operator">&lt;</span><span class="token class-name">ArrayQueue</span><span class="token operator">&lt;</span><span class="token keyword">u8</span><span class="token operator">&gt;&gt;</span> <span class="token operator">=</span> <span class="token class-name">OnceCell</span><span class="token punctuation">::</span><span class="token function">uninit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>由于 <a href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html#method.new" target="_blank" rel="noopener noreferrer"><code>ArrayQueue::new</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 执行的堆内存分配在编译时是不可能的（<a href="https://github.com/rust-lang/const-eval/issues/20" target="_blank" rel="noopener noreferrer">至少目前为止<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>），我们无法直接初始化这个静态变量。而是使用了 <a href="https://docs.rs/conquer-once/0.2.0/conquer_once/index.html" target="_blank" rel="noopener noreferrer"><code>conquer_once</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包的 <a href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html" target="_blank" rel="noopener noreferrer"><code>OnceCell</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型，这个类型使得安全地一次性初始化静态变量的变为可能。为了包含这个包，我们在 <code>Cargo.toml</code> 中将其添加为依赖：</p> <div class="language-toml line-numbers-mode"><pre class="language-toml"><code><span class="token comment"># in Cargo.toml</span>

<span class="token punctuation">[</span><span class="token table class-name">dependencies.conquer-once</span><span class="token punctuation">]</span>
<span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">&quot;0.2.0&quot;</span>
<span class="token key property">default-features</span> <span class="token punctuation">=</span> <span class="token boolean">false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里我们也可以用 <a href="https://docs.rs/lazy_static/1.4.0/lazy_static/index.html" target="_blank" rel="noopener noreferrer"><code>lazy_static</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 宏替换 <a href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html" target="_blank" rel="noopener noreferrer"><code>OnceCell</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 基本类型。然而，<code>OnceCell</code> 类型的好处在于我们可以保证初始化不会发生在中断处理函数里面，从而防止中断处理函数执行堆内存分配。</p> <h4 id="填充队列"><a href="#填充队列" class="header-anchor">#</a> 填充队列</h4> <p>为了填充扫描码队列，我们创建一个新的 <code>add_scancode</code> 函数，这个函数会被中断处理函数调用：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/keyboard.rs</span>

<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>println</span><span class="token punctuation">;</span>

<span class="token comment">/// Called by the keyboard interrupt handler</span>
<span class="token comment">///</span>
<span class="token comment">/// Must not block or allocate.</span>
<span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function-definition function">add_scancode</span><span class="token punctuation">(</span>scancode<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">SCANCODE_QUEUE</span><span class="token punctuation">.</span><span class="token function">try_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Err</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;WARNING: scancode queue full; dropping keyboard input&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;WARNING: scancode queue uninitialized&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>我们使用 <a href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html#method.try_get" target="_blank" rel="noopener noreferrer"><code>OnceCell::try_get</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 获得初始化队列的引用。如果队列尚未初始化，我们忽略键盘扫描码，并打印一个警告。重要的是因为这个函数会被不应该执行堆内存分配的中断处理函数调用，我们没有试图在这个函数里面初始化队列。由于这个函数不应该被 <code>main.rs</code> 调用，所以我们使用 <code>pub(crate)</code> 可见度属性限制其只在 <code>lib.rs</code> 内可用。</p> <p><a href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html#method.push" target="_blank" rel="noopener noreferrer"><code>ArrayQueue::push</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法只要求 <code>&amp;self</code> 引用使得调用静态队列的方法变得非常简单。<code>ArrayQueue</code> 类型自己会执行所有必须的同步操作，所以我们不需要 mutex 包装器。如果队列满了，我们也打印一个警告。</p> <p>为了在键盘中断时调用 <code>add_scancode</code> 函数，<code>interrupts</code> 模块的 <code>keyboard_interrupt_handler</code> 函数更新如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/interrupts.rs</span>

<span class="token keyword">extern</span> <span class="token string">&quot;x86-interrupt&quot;</span> <span class="token keyword">fn</span> <span class="token function-definition function">keyboard_interrupt_handler</span><span class="token punctuation">(</span>
    _stack_frame<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">InterruptStackFrame</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span>instructions<span class="token punctuation">::</span>port<span class="token punctuation">::</span></span><span class="token class-name">Port</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> <span class="token keyword">mut</span> port <span class="token operator">=</span> <span class="token class-name">Port</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> scancode<span class="token punctuation">:</span> <span class="token keyword">u8</span> <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> port<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">crate</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>task<span class="token punctuation">::</span>keyboard<span class="token punctuation">::</span></span><span class="token function">add_scancode</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new</span>

    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token constant">PICS</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">notify_end_of_interrupt</span><span class="token punctuation">(</span><span class="token class-name">InterruptIndex</span><span class="token punctuation">::</span><span class="token class-name">Keyboard</span><span class="token punctuation">.</span><span class="token function">as_u8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>我们从这个函数移除了所有键盘的处理代码，还添加了对 <code>add_scancode</code> 函数的调用。函数的的剩余部分和之前一样。</p> <p>和预期的那样，现在运行 <code>cargo run</code> 不会再看到按键打印到屏幕。而会在每次按键时看到扫描码队列未初始化的讲稿。</p> <h4 id="扫描码流"><a href="#扫描码流" class="header-anchor">#</a> 扫描码流</h4> <p>为了初始化 <code>SCANCODE_QUEUE</code>，并从队列异步地读取扫描码，我们创建一个新的 <code>ScancodeStream</code> 类型：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/keyboard.rs</span>

<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">ScancodeStream</span> <span class="token punctuation">{</span>
    _private<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">ScancodeStream</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
        <span class="token constant">SCANCODE_QUEUE</span><span class="token punctuation">.</span><span class="token function">try_init_once</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token class-name">ArrayQueue</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">&quot;ScancodeStream::new should only be called once&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ScancodeStream</span> <span class="token punctuation">{</span> _private<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><code>_private</code> 字段的用途时防止模块外部构造这个结构体。这使得 <code>new</code> 函数成为构造这个类型的唯一方法。在函数里面，我们首先尝试初始化 <code>SCANCODE_QUEUE</code> 静态变量。如果队列已经初始化，触发 panic，从而确保只会创建一个 <code>ScancodeStream</code> 实例。</p> <p>为了异步任务能够用上扫描码，下一步时实现类似 <code>poll</code> 的方法，尝试每次从队列中弹出下一个扫描码。虽然这听起来像是我们应该为我们的类型实现 <a href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html" target="_blank" rel="noopener noreferrer"><code>Future</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait，但是这并不完全对。问题在于 <code>Future</code> trait 只对单个异步值进行了抽象，并期望返回 <code>Poll::Ready</code> 后不再调用 <code>poll</code> 方法。我们的扫描码队列则包含多个异步值，所以一直轮询它是没问题的。</p> <h5 id="stream-trait"><a href="#stream-trait" class="header-anchor">#</a> <code>Stream</code> trait</h5> <p>由于产出多个异步值的类型是常见的，所以 <a href="https://docs.rs/futures/0.3.4/futures/" target="_blank" rel="noopener noreferrer"><code>futures</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包为这种类型提供了有用的抽线：<a href="https://rust-lang.github.io/async-book/05_streams/01_chapter.html" target="_blank" rel="noopener noreferrer"><code>Stream</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait。这个 trait 的定义如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token class-name">Stream</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> <span class="token class-name">Item</span><span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">poll_next</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token punctuation">)</span>
        <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Item</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这个定义个 <a href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html" target="_blank" rel="noopener noreferrer"><code>Future</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 非常类似，但是有以下不同点：</p> <ul><li>关联类型为 <code>Item</code> 而不是 <code>Output</code></li> <li><code>Stream</code> trait 定义 <code>poll_next</code> 方法返回 <code>Poll&lt;Option&lt;Self::Item&gt;&gt;</code> 类型（注意额外的 <code>Option</code>），而不是 <code>poll</code> 方法返回 <code>Poll&lt;Self::Item&gt;</code></li></ul> <p>这里有个语义上的区别：<code>poll_next</code> 可以被反复调用，直至返回提示 stream 已经变空的 <code>Poll::Ready(None)</code>。从这种意义上讲，这和 <a href="https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html#tymethod.next" target="_blank" rel="noopener noreferrer"><code>Iterator::next</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法类似，它也会在最后一个值之后返回 <code>None</code>。</p> <h5 id="实现-stream"><a href="#实现-stream" class="header-anchor">#</a> 实现 <code>Stream</code></h5> <p>让我们为 <code>ScancodeStream</code> 实现 <code>Stream</code> trait，从而异步地提供 <code>SCANCODE_QUEUE</code> 队列的值。为此，我们首先需要添加对 <code>futures-util</code> 包的依赖，这里面包含 <code>Stream</code> 类型：</p> <div class="language-toml line-numbers-mode"><pre class="language-toml"><code><span class="token comment"># in Cargo.toml</span>

<span class="token punctuation">[</span><span class="token table class-name">dependencies.futures-util</span><span class="token punctuation">]</span>
<span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">&quot;0.3.4&quot;</span>
<span class="token key property">default-features</span> <span class="token punctuation">=</span> <span class="token boolean">false</span>
<span class="token key property">features</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">&quot;alloc&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们禁用了默认特性以兼容 <code>no_std</code>，并启用 <code>alloc</code> 特性来引入 allocation 支持的类型（我们后续会用到）。<span class="gray">（需要注意的是我们也可以把主 <code>futures</code> 包添加为依赖，这个包重新导出了 <code>futures-util</code> 包，但这样做会导致更多依赖和更长的编译时间。）</span></p> <p>现在我们可以导入和实现 <code>Stream</code> trait 了：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/keyboard.rs</span>

<span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token namespace">pin<span class="token punctuation">::</span></span><span class="token class-name">Pin</span><span class="token punctuation">,</span> <span class="token namespace">task<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Poll</span><span class="token punctuation">,</span> <span class="token class-name">Context</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">futures_util<span class="token punctuation">::</span>stream<span class="token punctuation">::</span></span><span class="token class-name">Stream</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">Stream</span> <span class="token keyword">for</span> <span class="token class-name">ScancodeStream</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> <span class="token class-name">Item</span> <span class="token operator">=</span> <span class="token keyword">u8</span><span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">poll_next</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">u8</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token constant">SCANCODE_QUEUE</span><span class="token punctuation">.</span><span class="token function">try_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">&quot;not initialized&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">match</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Ok</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token class-name">Some</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token namespace">crossbeam_queue<span class="token punctuation">::</span></span><span class="token class-name">PopError</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>我们首先使用 <a href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html#method.try_get" target="_blank" rel="noopener noreferrer"><code>OnceCell::try_get</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法获得已初始化扫描码队列的引用。由于我们在 <code>new</code> 函数里面初始化了队列，这应该不会失败，所以我们可以在没有初始化时安全地使用 <code>expect</code> 方法来处理 panic。接下来，我们使用 <a href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html#method.pop" target="_blank" rel="noopener noreferrer"><code>ArrayQueue::pop</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法尝试从队列读取下一个值。如果成功了，我们用 <code>Poll::Ready(Some(…))</code> 包装扫描码返回。如果失败了，这意味着队列为空。这种情况下，返回 <code>Poll::Pending</code>。</p> <h4 id="支持-waker"><a href="#支持-waker" class="header-anchor">#</a> 支持 Waker</h4> <p>和 <code>Futures::poll</code> 方法类似，<code>Stream::poll_next</code> 方法要求异步任务在返回 <code>Poll::Pending</code> 后变为完毕时通知执行器。这样执行器就不用被提醒后再次轮询同样的任务，这会极大地降低等待任务带来的性能损失。</p> <p>为了发送这个通知，任务需要从传入的 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Context.html" target="_blank" rel="noopener noreferrer"><code>Context</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 引用拿出 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html" target="_blank" rel="noopener noreferrer"><code>Waker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，保存它。任务完毕后，它应该调用保存的 <code>Waker</code> 的 <a href="https://doc.rust-lang.org/stable/core/task/struct.Waker.html#method.wake" target="_blank" rel="noopener noreferrer"><code>wake</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法通知执行器任务应该被再次轮询了。</p> <h5 id="atomicwaker"><a href="#atomicwaker" class="header-anchor">#</a> AtomicWaker</h5> <p>为了让 <code>ScancodeStream</code> 实现 <code>Waker</code> 通知功能，我们需要一个在多次轮询之间保存 <code>Waker</code> 的地方。因为需要 <code>add_scancode</code> 函数能够访问到，所以我们不能把它存为 <code>ScancodeStream</code> 自身的字段。解决方法时使用 TODO 包提供的类型为 <a href="https://docs.rs/futures-util/0.3.4/futures_util/task/struct.AtomicWaker.html" target="_blank" rel="noopener noreferrer"><code>AtomicWaker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的一个静态变量。和 <code>ArrayQueue</code> 类型相似，这个类型基于原子指令，可以安全地存到一个静态变量并被并发的修改。</p> <p>让我们使用 <a href="https://docs.rs/futures-util/0.3.4/futures_util/task/struct.AtomicWaker.html" target="_blank" rel="noopener noreferrer"><code>AtomicWaker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型定义个静态的 <code>WAKER</code>：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/keyboard.rs</span>

<span class="token keyword">use</span> <span class="token namespace">futures_util<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token class-name">AtomicWaker</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token constant">WAKER</span><span class="token punctuation">:</span> <span class="token class-name">AtomicWaker</span> <span class="token operator">=</span> <span class="token class-name">AtomicWaker</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>思路是 <code>poll_next</code> 实现把当前 waker 保存在这个静态变量中，<code>add_scancode</code> 函数在新的扫描码入列时调用它的 <code>wake</code> 函数。</p> <h5 id="保存-waker"><a href="#保存-waker" class="header-anchor">#</a> 保存 waker</h5> <p><code>poll</code>/<code>poll_next</code> 定义的合约要求任务在返回 <code>Poll::Pending</code> 时为传入的 <code>Waker</code> 注册一个唤醒操作。让我们更新 <code>poll_next</code> 的实现来满足这个要求：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/keyboard.rs</span>

<span class="token keyword">impl</span> <span class="token class-name">Stream</span> <span class="token keyword">for</span> <span class="token class-name">ScancodeStream</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> <span class="token class-name">Item</span> <span class="token operator">=</span> <span class="token keyword">u8</span><span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">poll_next</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">u8</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token constant">SCANCODE_QUEUE</span>
            <span class="token punctuation">.</span><span class="token function">try_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">&quot;scancode queue not initialized&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// fast path</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span> <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token class-name">Some</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token constant">WAKER</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cx<span class="token punctuation">.</span><span class="token function">waker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">match</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Ok</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token constant">WAKER</span><span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token class-name">Some</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token namespace">crossbeam_queue<span class="token punctuation">::</span></span><span class="token class-name">PopError</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>和之前类似，我们首先使用 <a href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html#method.try_get" target="_blank" rel="noopener noreferrer"><code>OnceCell::try_get</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数获得初始化的扫描码队列的引用。然后最优化地尝试从队列弹出一个值并在成功的情况下返回 <code>Poll::Ready</code>。这样，我们可以便面队列不为空时注册 waker 的性能损耗。</p> <p>如果第一次调用 <code>queue.pop()</code> 没有成功，队列有可能为空。原因只会是恰好在检查之后中断处理函数可能异步地填充了队列。由于这个竞争条件可能会在下一次检查再次出现，所以我们需要在第二次检查前把 <code>Waker</code> 注册到 <code>WAKER</code> 静态变量。这样，唤醒可能会发生在我们返回 <code>Poll::Pending</code> 之前，但是能够确保我们获得检查之后任何扫描码入列的提醒。</p> <p>借助 <a href="https://docs.rs/futures-util/0.3.4/futures_util/task/struct.AtomicWaker.html#method.register" target="_blank" rel="noopener noreferrer"><code>AtomicWaker::register</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数注册传入的 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Context.html" target="_blank" rel="noopener noreferrer"><code>Context</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 中的 <code>Waker</code> 后，我们尝试再次执行出列操作。如果现在成功了，我们返回 <code>Poll::Ready</code>。我们还会使用 <a href="https://docs.rs/futures/0.3.4/futures/task/struct.AtomicWaker.html#method.take" target="_blank" rel="noopener noreferrer"><code>AtomicWaker::take</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 再次移除注册的 waker，因为 waker 通知功能不再需要了。如果 <code>queue.pop()</code> 再次失败，我们和之前那样返回，但是这次伴随一个注册好的提醒。</p> <p>需要注意的是任务（到目前为止）没有返回 <code>Poll::Pending</code> 的任务得到唤醒的方式有两种。前面提到的唤醒发生在刚好返回 <code>Poll::Pending</code> 后出现的竞争条件。另一种方式是注册 waker 后队列非空了，返回 <code>Poll::Ready</code>。由于这些虚假的唤醒无法避免，但是只兴趣需要正确地处理它们。</p> <h5 id="唤醒保存的-waker"><a href="#唤醒保存的-waker" class="header-anchor">#</a> 唤醒保存的 waker</h5> <p>为了唤醒保存的 <code>Waker</code>，我们再 <code>add_scancode</code> 函数调用 <code>WAKER.wake()</code>：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/keyboard.rs</span>

<span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token function">add_scancode</span><span class="token punctuation">(</span>scancode<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">SCANCODE_QUEUE</span><span class="token punctuation">.</span><span class="token function">try_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Err</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;WARNING: scancode queue full; dropping keyboard input&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token constant">WAKER</span><span class="token punctuation">.</span><span class="token function">wake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;WARNING: scancode queue uninitialized&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>唯一的变化时如果扫描码入列成功，我们调用 <code>WAKER.wake()</code>。如果 waker 已经注册到了 <code>WAKER</code> 静态变量，这个方法会调用其同名的 <a href="https://doc.rust-lang.org/stable/core/task/struct.Waker.html#method.wake" target="_blank" rel="noopener noreferrer"><code>wake</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法，唤醒相应的执行器。否则，操作为空，即不会发生任何事。</p> <p>重要的是我们只有把扫描码加到队列后才调用 <code>wake</code>，否则任务可能会在队列为空时被过早唤醒。例如，使用多线程执行器在不同 CPU 内核并发低唤醒任务时就会触发这个问题。虽然现在还不支持线程，但是我们很快就会把它添加进来，不想那时把现状破坏了。</p> <h4 id="键盘任务"><a href="#键盘任务" class="header-anchor">#</a> 键盘任务</h4> <p>为 <code>ScancodeStream</code> 实现 <code>Stream</code> trait 之后，我们现在可以使用它来创建异步的键盘任务了：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/keyboard.rs</span>

<span class="token keyword">use</span> <span class="token namespace">futures_util<span class="token punctuation">::</span>stream<span class="token punctuation">::</span></span><span class="token class-name">StreamExt</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">pc_keyboard<span class="token punctuation">::</span></span><span class="token punctuation">{</span>layouts<span class="token punctuation">,</span> <span class="token class-name">DecodedKey</span><span class="token punctuation">,</span> <span class="token class-name">HandleControl</span><span class="token punctuation">,</span> <span class="token class-name">Keyboard</span><span class="token punctuation">,</span> <span class="token class-name">ScancodeSet1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>print</span><span class="token punctuation">;</span>

<span class="token keyword">pub</span> <span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">print_keypresses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> scancodes <span class="token operator">=</span> <span class="token class-name">ScancodeStream</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> keyboard <span class="token operator">=</span> <span class="token class-name">Keyboard</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token namespace">layouts<span class="token punctuation">::</span></span><span class="token class-name">Us104Key</span><span class="token punctuation">,</span> <span class="token class-name">ScancodeSet1</span><span class="token punctuation">,</span>
        <span class="token class-name">HandleControl</span><span class="token punctuation">::</span><span class="token class-name">Ignore</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span> <span class="token operator">=</span> scancodes<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token class-name">Some</span><span class="token punctuation">(</span>key_event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> keyboard<span class="token punctuation">.</span><span class="token function">add_byte</span><span class="token punctuation">(</span>scancode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">=</span> keyboard<span class="token punctuation">.</span><span class="token function">process_keyevent</span><span class="token punctuation">(</span>key_event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">match</span> key <span class="token punctuation">{</span>
                    <span class="token class-name">DecodedKey</span><span class="token punctuation">::</span><span class="token class-name">Unicode</span><span class="token punctuation">(</span>character<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">print!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> character<span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token class-name">DecodedKey</span><span class="token punctuation">::</span><span class="token class-name">RawKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">print!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>这份代码和本文修改前的 <a href="/_post/blog-os/blog-os-12-async-await/@/second-edition/posts/07-hardware-interrupts/#interpreting-the-scancodes">键盘中断处理函数</a> 非常类似。唯一的区别是，现在不从 I/O 端口读取扫描码，而从 <code>ScancodeStream</code> 获取。为此，我们首先创建一个 <code>Scancode</code> 流，然后不断地调用 <a href="https://docs.rs/futures-util/0.3.4/futures_util/stream/trait.StreamExt.html" target="_blank" rel="noopener noreferrer"><code>StreamExt</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 提供的 <a href="https://docs.rs/futures-util/0.3.4/futures_util/stream/trait.StreamExt.html#method.next" target="_blank" rel="noopener noreferrer"><code>next</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法来获取一个会读取流的下一个元素的 <code>Future</code>。通过对其应用 <code>await</code> 操作符，我们异步地等待 future 的结果。</p> <p>我们使用 <code>while let</code> 循环直至流返回 <code>None</code> 提示结束。由于我们的 <code>poll_next</code> 方法从不会返回 <code>None</code>，这实质上是一个无限循环，所以 <code>print_keypresses</code> 任务永不结束。</p> <p>让我们在 <code>main.rs</code> 里面把 <code>print_keypresses</code> 任务添加到执行器，使得键盘输入能够再次工作：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">use</span> <span class="token namespace">blog_os<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span>keyboard<span class="token punctuation">;</span> <span class="token comment">// new</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>

    <span class="token comment">// […] initialization routines, including init_heap, test_main</span>

    <span class="token keyword">let</span> <span class="token keyword">mut</span> executor <span class="token operator">=</span> <span class="token class-name">SimpleExecutor</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token class-name">Task</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">example_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token class-name">Task</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token namespace">keyboard<span class="token punctuation">::</span></span><span class="token function">print_keypresses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new</span>
    executor<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// […] &quot;it did not crash&quot; message, hlt_loop</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>现在执行 <code>cargo run</code>，可以看到键盘输入再次有效了：</p> <p><img src="data:image/gif;base64,R0lGODlh0AKoAfYBAP//VQAAAKOjo6urq7m5ubu7u83Nzd/f3+vr6+3t7fDw8PLy8pqamp+fn8bGxlVVVaWlpdTU1NnZ2dvb2+fn5+7u7vb29tLS0v///5CQkJKSkpOTk5SUlJWVlZaWlpiYmJmZmZycnJ2dnaCgoKKioqSkpKenp6mpqaqqqqysrK2tra6urq+vr7GxsbOzs7S0tLW1tba2tre3t7q6ury8vL6+vsDAwMPDw8TExMjIyMnJycvLy8zMzM/Pz9PT09XV1dbW1tfX19ra2uDg4OLi4uPj4+Xl5ebm5ujo6Ozs7O/v7/Hx8fPz8/T09PX19ZeXl5ubm56enqGhoaampqioqLCwsLKysr29vb+/v8LCwsXFxdDQ0NHR0djY2N3d3d7e3uHh4aqqVf//qgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hlPcHRpbWl6ZWQgdXNpbmcgZXpnaWYuY29tACH5BAQyAP8ALAAAAADQAqgBAAf/gBaCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6eriICBNhCYZ747yhAj1nQNXhVUy9wrrAgocSHBcux+DjoTA14ihKCBPmCTUAMZJkoIYM2rcuAxEARWDahCoN6FEiBA4BA2ZAkVKF0EZuJDwAPJfgpgpSKRYYoEIlQZSckiCwiUkhJ4kfwa1EGICzAKCZGThSLWq1augQEzogACml3pPLiAdsuTDyy8aLmYg8K4BD5tr/wUJeAuih9dIOKgMErEFKcC6XglMXUlC7gGsiBMrXnxIa4yUQFD8KzRiC0RDGY5ExQKXwubLgm64kETRr1/QFkRHTp1jRAIkHywynk27dkGtaJ2suDB5h4kpLC0XtofvcefPGk6e3BnJBQ0LLWoI+mcgufKdHBZIJhDBwAvb4MOLZ1excux/Ejx4Zio8Ic/iNY5DrxEkxKWvk0/b59fFnY8ZVhQ13oAEFhiNVqmhpN871e2ggFmmwSefcYA1Qd8kOoE0HVg+RPWSA1SwABMDFRho4okoCoNgBaVNpsJJPDgQ1gEQHHTXfBNK51MUIfgzCQ8xTQTQjj3yVESQTE2R4v+STDbp5JNQRinllFRWaeWVWGap5ZZcdunll2CGKeaYZJZp5ploquLFmmy26eabcMYp55x01mnnnXjmqeeefPbp55+ABirooIQWauihiCaq6KKMNuqongFEKumklFZq6aWYZqrpppx26umnoIYq6qiklmrqqaimquqqrLbq6quwxirrrLTWauutuOaq66689urrr8AGK+ywxBZr7LHIJqvsssw26+yz0EYr7bTUVmvttdhmq+223Hbr7bfghivuuOSWa+656Kar7rrstuvuu/DGK++89NZr77345qvvvvz26++/AAcs8MAEF2zwwQgnrPDCDDfs8MMQRyzxxBRXbPH/xRhnrPHGHHfs8ccghyzyyCSXbPLJKKes8sost+zyyzDHLPPMNNds880456zzzjz37PPPQAct9NBEF2300UgnrfTSTDft9NNQRy311FRXbfXVWGet9dZcd+3112CHLfbYZJdt9tlop6322my37fbbcMct99x012333XjnrffefPft99+ABy744IQXbvjhiCeu+OKMN+7445BHLvnklFdu+eWYZ6755px37vnnoIcu+uikl2766ainrvrqrLfu+uuwxy777LTXbvvtuOeu++689+7778AHL/zwxBdv/PHIJ6/88sw37/zz0Ecv/fTUV2/99dhnr/323Hfv/ffghy/+//jkl2/++einr/767Lfv/vvwxy///PTXb//9+Oev//789+///wAMoAAHSMACGvCACEygAhfIwAY68IEQjKAEJ0jBClrwghjMoAY3yMEOevCDIAyhCEdIwhKa8IQoTKEKV8jCFrrwhTCMoQxnSMMa2vCGOMyhDnfIwx768IdADKIQh0jEIhrxiEhMohKXyMQmOvGJUIyiFKdIxSpa8YpYzKIWt8jFLnrxi2AMoxjHSMYymvGMaEyjGtfIxja68Y1wjKMc50jHOtrxjnjMox73yMc++vGPgAykIAdJyEIa8pCITKQiF8nIRjrykZCMpCQnSclKWvKSmMykJjfJyU568v+ToAylKEdJylKa8pSoTKUqV8nKVrrylbCMpSxnScta2vKWuMylLnfJy1768pfADKYwh0nMYhrzmMhMpjKXycxmOvOZ0IymNKdJzWpa85rYzKY2t8nNbnrzm+AMpzjHSc5ymvOc6EynOtfJzna6853wjKc850nPetrznvjMpz73yc9++vOfAA2oQAdK0IIa9KAITahCF8rQhjr0oRCNqEQnStGKWvSiGM2oRjfK0Y569KMgDalIR0rSkpr0pChNqUpXytKWuvSlMI2pTGdK05ra9KY4zalOd8rTnvr0p0ANqlCHStSiGvWoSE2qUpfK1KY69alQjapUp0rVqlr1qlhBzapWt8rVrnr1q2ANq1jHStaymvWsaE2rWtfK1ra69a1wjatc50rXutr1rnjNq173yte++vWvgA2sYAdL2MKKLxAAIfkEBQQAAQAsAABqAZYAKgAAAv8EgobLbNdem9TBdKsOcna7heKoYCOXLeXpZSsLUi86w7Z81ZWus29/6s0eqZtRlUt+kLgIUfSDEJO0Vmu4PGqnpRW2yTRtoqhw9QuqAbUwr5TrBIvL44PiThWj9cU1O5i3xuOSp4FX5mZmFaZW9GeTSLfjSDY3CRcpucj32BnHaampmGn4Nkf6CRrjeZM55YQVlTV5+oQxKCvqx8rb6/sLHCw8TFxsfIycrLzM3Oz8DB0tPZ08iyy7S82aDfyBqt3teMRNIw5ki+QdaIctnhbpZnqb8moyy324WWfWVdhfC0Xev3m28kmKJ8qHvFWXKq2CtxAQqET5BnJZNw6OIjDvsR5iTBjC4sJDIkNt/OOwlMmD/gS6o0VnICJ2E825IwcwYM6YLVXtKslyZk1+N1/K+ZaO5RKNPNNlkynhX0V05ZQYVdivXi+c4Lqy4eo1LCBrYsuaPYs2rdq1bMf2gdQIx9Ut0shqigtXH0NeYIMJUaeXxNyTnvqGazhKa8gs9+wyWYqOaR3AkGORsXySnMGNm1U2tYSvJc1UrjqnXMmxDyHUn6CuFgwz3mlVoFVLTFjpqcvEtwPLvNWa3uu9nvHSLj5y+GKYMQY1NxrXz+/arJ/vFLrvus+euqxeETx6noXwyJ2qnquVKnDZSkIpKAAAIfkEBQkAAQAsAwCiAQIAAgAAAgKEUQAh+QQFBAAMACwAAG4BFwA2AAAHd4AKDIOEhYaHDA8KD4iNhgGKjI6OAZAIkpOHlYkImYibnJ6TkaKNpKWHp6gTGK2tmKOMDxCog4oRgxW1DBQPEowCsJ6yA4kHu7nJyGIGBQTIhGHQ0dPV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+yZAACI757yh++BACH5BAUEABkALAAAbgFIAB0AAAWrIJCNZGmeaKqurAkAQSvPNP0Gca3v9Y3zwCDKlxMagUTRcRnEOZ/QqHRKrVqv2Kx2y+16v+Cw9yEuly1ks7qLQaTX8Cvm4Y7bqZgA/X3vB/J6bio+TIWAgQ8rSoVLh4GKjEyOj5GVJZOIlpaYmZqMnJ2ejVATGKamopI4D2QPEKmReXQROBWwnwEUDxJkAnx+ahgXrQN6B8BxGA1OCrXIcA5PDAYFBLearE8hACH5BAUFABkALB4AWwGTAEkAAAX/YCaOZGmeaKqubOu+7gPPdG3feGvJee//wBoGwQsaj8ge5kFMOp/QFCbDLEav2OCU2sx6v7Yt1woum0/i8XnNzqTV7bj3DZfbn/T6fa9FVfmAP28TGIWFZIGJMFsPMg8QipE4U0wRIhWSmTRTFA8SMgKImqNoF44DVAekq1INIwqXrLIlDiQMBgUEs7snjby/wMHCw8TFxsfIycrLzIEBzZkBz9CK0tPUgNbX2HfP1tx709/gctMAANLkcQAi5+nqbOwZ5xkB8vBm8vTz6Phl+gDf+csCsB06gQOj3DuHzt22hE/EeXsIMcpEcRW9XJyYEcu3dAg7OhGIUSSUbdpMOn4JqbKly5cwY8qcSbOmzZs4c+rcybOnz59AgwodSrSo0aNIR+1LqsKhtqdQo0qdSrWq1atYs2q9GgIAIfkEBQUAGQAsJwAPAfwAlQAABf9gJo5kaZ5oqq5s675wLM90jT52ru987//AmAUXLBqPyKRyhUEQl9CodEolYR7OqnbL7cowGezTSy6bp+Bw9sxuu3tp9fhNr9tPcfl9z6fn9X2Bglx/gIOHiEmFhomNjjuLjI+TlC5/ExiZmXOVnZ4jaQ84DxCfpqdWahEiFaiun2AUDxI4ApyvuIcYF6MDYQe5wYkYDSMKrMLJgg4kDAYFBMrSh6LT1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AAMKHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFPKqlzJsqXLlzBjypxJs6bNmzinBchZJ8BOnm58/gR6RuhQomR2CkVa5udSpl2GPoWq5ehUqlOOZriKFYrWrT67SvkKlqzYIma5nkVbwqjatT+cKjULN8hcp3WX3J2bN8nSsGH7Hgm8VQRdwTusvkWM9jDjx5AjS55MubLly5gza97MubPnz6BDix5NurTp06hTq17NurXr17Bjy55Nu7bt27hz697Nu7fv38CDCx8eEACA2sbdKl/OvLnz59CjS59Ovbr169iza18eAgAh+QQFBQAZACwwAMwAcgHYAAAF/2AmjmRpnmiqrmzrvnAsz3Rt33ium8/u/8CgcEgsGo8xSw/JbDqf0Ki0iEEsp9isdsvt2jAPq3dMLpvPQ0wmfEW73/C4Wb0Wy+/4vD49Yu//gIGCKHQifoOIiYpohYZ2i5CRkk6Njm2TmJmaXyeHm5+goSeVfY+ip6iTlRMYra2XqbGyf3QPPQ8Qs7q7gGphESIVvMPEcGoUDxI9ArDFzs9TGBe3A2sH0NjZUBgNIwrB2uHiRA4kDAYFBOPr7EG27fDx8vP09fb3+Pn6+/z9/v8AAwocSLCgwYMIEypcyLChw4cQI0qcSLGixYsYM2rcyLGjx48gQ4ocSbKkyZMoU/+qXMmypcuXMGPKnEmzps2bOHPq3Mmzp8+fQIMKHUq0qNGjSJMqXcq0qdOnUKNKnUq1qtWrQANgnRhA61aIXb1+bRhW7FiFWsOeXehV7VqEYt2+LWhW7lyBZjPYvfsvr96ufAP6/Ts4ML7Cew0fLlE2seJ6bdMWfnxPclvK/ixLxsxPLWDAnPWB1iticuh4dR2fPmx6tevXsGPLnk27tu3buHPr3s27t+/fwIMLH068uPHjyJMrX868ufPn0KNLn069uvXr2LNr3869u/fv4MOLH0++vPnz6NOrX8++vfv38OPLn0+/vv37+PPr38+/v///AAYo4IAEFmjggQgmqOBqggw26OCDEEYo4YQUVmjhhRhmqOGGHHbo4YcghijiiCSWaOKJKKao4oostujiizDGKOOMNNZo44045qjjjjz26OOPQAYp5GkAAPBikY0lqeSSTDbp5JNQRinllFRWaeWVWGap5ZZcdullCAAh+QQFBQAZACw5AL0AiAHnAAAF/2AmjmRpnmiqrmzrvnAsz3Rt33iu79nD/8CgcEgsGo9InsWXbDqf0Kh0ShVhEMyqdsvter9AzAMLLpvP6DQU0yOr3/C4fF5it7P0vH7PR9rvfYGCg4Qvf4CFiYqLeoeIjJCRklyOj5OXmJlDlZaanp+ghihjeKGmp6aOExisrKWosLGRdg8+DxCyubqSbGMRIhW7wsNRAWEZFA8SPgKvxM/QPAHGShe2Az0H0dvcOdPUOhgNIwrA3efoMN/gOA4kDAYFBOn09SfG30K19vz81Pn9Agr0NgLgwIMIXbAzmLChw4IlGD6cOJCdCIkUM9azeHGaxo8bUWAESZKYxXUjS/+qlPUPH8eVMHW5/BezprCZLm3qjJXPo8edQEP9zEAzqFFNC1MeXSppKNOnUKNKnUq1qtWrWLNq3cq1q9evYMOKHUu2rNmzaNOqXcu2rdu3cOPKnUu3rt27ePPq3cu3r9+/gAMLHky4sOHDiBMrXsy4sePHkCNLnky5suXLmDNr3sy5s+fPoEOLHk26tOnTqFOrXs26tevXsGPLnk27tu3buHPr3s27t+/fwIMLH068uPHjyJMrX868ufPn0KNLn069uvXr2LNr3869u/fv4MOLH0++vPnz6NOrX8++vfv38OPLn0+/vv37+PPr38+/v///AAYo4IAEFmjggQgmqOCIggw26OCDEEYo4YQUVmjhhRhmqOGGHHbo4YcghijiiCSWaOKJKKao4oostujiizDGKOOMNNZo44045qjjjjz26OOPQAYp5JBEFmnkkUgmqeSSTDbp5JNQRinllFRWaeWVWGYpDAAA+MglSmCGKeaYZJZp5plopqnmmmy26eabcMYp55x01glnCAAh+QQFBgABACxCAKIBAgACAAACAoRRACH5BAUKAAEALEsAogECAAIAAAIChFEAIfkEBQkAAAAstAG9AA0AFAAAAg6Mj6nL7Q+jnLTai7NeBQAh+QQFBQAQACwJAAgAXwCcAQAH/4ABAQsQhRAPg4aKi4VHAUWKB4mMlJWVDxuLDw+SSJafAQ8vhkCITJ+Rj4pNRU6or5QwkxBEATysrrCLoQ+GHqYQNpuYhTuIorQBA8dJnUbKw0kQBsMMuoZNyIUbvZ3T1Yc2EE0BGYXEEAE2qgvqg0vK07ZJ6vJEjg9MSQ8kzuXj/OiZoKXtmoZeAE8kQyKQoAxixhA+yFHIFjEYnBIhaHIORYwAhhg6+nHug78gJT/6QnitiK1giTqp3CaqFwcQnIRMsuUgnyhJp0YMU0aCZSNVhzr4g5RUAK9j1wwRQ9fJ6dB8gyaKKsHypahBQGkEQHnoxMxpzZBiWprSaFRDOP8eIZXpNtwgFptSGHrJYNNCFPkgOG2AIF6OR46YrkWstkPDJR0IvD3n9yjDeJAld/BbBNGRvTyS9ViYoJoHdTmOxVhYkm3Sb9EmC65nGfYmaT0ChKAsu7fv38CDCx9OvLjx48iTK1/OvLnz59CjS59Ovbr169iza9/Ovbv37+DDix9Pvrz58+jTq1/Pvr379/Djy59Pv779+/jz69/Pv7///wAGKOCABBZo4IEIJqjgggw26OCDEEYo4YQUVmjhhRhmqOGGHHbo4YcghijiiCSWaOKJKKao4oostujiizDGKOOMNNZo44045qjjjjz26OOPQAYp5JBEFmnkkUgmqeShkkw26eSTUEYp5ZRUVmnllVhmqeWWXHbp5ZdghinmmGSWaeaZaKap5ppstunmm3DGKeecdNZp55145qnnnnz26eefgAYq6KCEFmrooYgmquiijDbq6KOQRirppJRWaumlmGaq6aacdurpp6CGKuqopJZq6qmopqrqqqy26uqrsMYq66y01mrrrbjmquuuvPYKIgAAUAKssMHONywjxy4CbCAAIfkEBQQAAQAsbwCiAQsAAgAAAgYEghlmmlYAIfkEBQoAAQAsgQCiAQIAAgAAAgKEUQAh+QQFCgABACyKAKIBCwACAAACBgSCGWaaVgAh+QQFBAABACycAKIBAgACAAACAoRRACH5BAUEAAEALKUAogECAAIAAAIChFEAIfkEBQQAAQAsrgCiAQIAAgAAAgKEUQAh+QQFBAABACy3AKIBAgACAAACAoRRACH5BAUEAAEALMAAogECAAIAAAIChFEAIfkEBQkAAQAsyQCiAQIAAgAAAgKEUQAh+QQFBQABACzSAKIBAgACAAACAoRRACH5BAUFAAEALNsAogECAAIAAAIChFEAIfkEBQUAAQAs5ACiAQIAAgAAAgKEUQAh+QQFBQABACztAKIBAgACAAACAoRRACH5BAUFAAEALPMAmgEOAAoAAAIZBIKGm9e81INBVgeNtszyiH3TRZFj42FNAQAh+QQFBQABACwIAaIBAgACAAACAoRRACH5BAUFAAEALBEBogECAAIAAAIChFEAIfkEBQUAAQAsGgGiAQIAAgAAAgKEUQAh+QQFBQABACwjAZ0BDQAHAAACEowfoIrH9tCaLYHaIryOW/0xBQAh+QQFBQABACw1AaIBAgACAAACAoRRACH5BAUFAAEALD4BogECAAIAAAIChFEAIfkEBQUAAQAsRwGiAQIAAgAAAgKEUQAh+QQFBQABACxPAZoBDAAKAAACE4SDqafNnR4MElYHZsyacmxcRgEAIfkEBQoAAQAsYgGiAQIAAgAAAgKEUQAh+QQFBQABACxrAaIBCwACAAACBgSCGWaaVgAh+QQFBQABACx8AZoBDAAKAAACE4SDqafNnR4MElYHZsyacmxcRgEAIfkEBQkAAQAsjwGiAQIAAgAAAgKEUQAh+QQFBAABACyYAZ0BDQAHAAACEowfoIrH9lCMDtSWLFxSZ/oxBQAh+QQFBAABACyqAaIBAgACAAACAoRRACH5BAUEAAEALLwBogECAAIAAAIChFEAIfkEBQQAAQAsxQGiAQIAAgAAAgKEUQAh+QQFBQABACzOAaIBAgACAAACAoRRACH5BAUKAAEALNcBogECAAIAAAIChFEAIfkEBQUAAQAs4AGiAQIAAgAAAgKEUQAh+QQFBQABACzpAZoBDgAKAAACGowPcJFrjZSDTy7KbLy65j8pDVYlphl6JNQUACH5BAUFAAEALPsBogECAAIAAAIChFEAIfkEBQoAAQAsBAKdARQABwAAAheMH6CK3Wyge+DIaWvUOHt3SVeyUCVVAAAh+QQFBQABACwfAqIBAgACAAACAoRRACH5BAUFAAEALCgCnQENAAcAAAISjA8Qqee8mosmzSovfpmizEgFACH5BAUFAAEALDoCogECAAIAAAIChFEAIfkEBQUAAQAsQwKiAQIAAgAAAgKEUQAh+QQFBQABACxMAqIBAgACAAACAoRRACH5BAUFAAEALFUCmgEMAAoAAAIUjG+gyLF9HnRgpmol1G3xS3UKUAAAIfkEBQUAAQAsZwKiAQIAAgAAAgKEUQAh+QQFBQABACxwAqIBAgACAAACAoRRACH5BAUFAAEALHkCogECAAIAAAIChFEAIfkEBQUAAQAsggKiAQIAAgAAAgKEUQAh+QQFBAABACyLAqIBAgACAAACAoRRACH5BAUEAAEALJQCogECAAIAAAIChFEAIfkEBQQAAQAsnQKiAQIAAgAAAgKEUQAh+QQFCQABACyjApoBDgAKAAACGIyBpqvJ795BQM4QmctrV+lZoVZR2NcABQAh+QQFBAABACy4AqIBAgACAAACAoRRACH5BAUEAAEALMECogECAAIAAAIChFEAIfkEBQUAAQAsygKiAQIAAgAAAgKEUQAh+QQFBQACACwAAFoBzAJKAAAC/wSChsts116b1MF0qw5ydruF4kiW5omm6sq27gvH8kzX9o3nsYKRfJRB/TjB0xBkOeqWzKbzCY1Kp9Sq9Rr6KSvbbWno9RV7yTH2jE6r1+y2+/3WXh7KbpBuRpLxC8WnX0QHFAZXaHiImKi4yAiDxyMHRAE2l0fWE4lxcMS5GWjZGCo6SlpqesqS+Xg3RgmY5UkkewnJilQHiqq7y9vr+/ukammnRyjrF0ub5zqrB/wMHS09TS28Qfx6ybXanDmZUUstPk5ebp5ord3s7K0R3l3pDg6Be25/j5+vv+LNVzY47488ZR8EefgjodO+hQwbOnwIMaLEiRQrWryIMaPGjf8cO3r8CDKkyJEkS5o8iTKlypUsW7p8CTNmSYHBAhqTiTOnzlE3bxSMtzOo0KHocn0xqslMT6JMm0Y0COhnNmQ2c1GdWoleVlZSaS5F9s2p2LEZ+2nNNuvdum17ziY1CFZZ1LVH1dElizdvPn92zbY14lYt2He1+KoFzPeu3sWMq7mdizbdUqx/MSUjrBSpGGeNO3t+djgy0LSPN5OWGxcz29V17X5+DduUYKB+T7uWZDtS6sCjw0yWezu28OFwEm6tSvv4iNmXYxWm9PP3tQ7ciFu/zks69u3ciWvvDj583sTiy5s/jz69+vXs27t/Dz++fBxQ+yA++E2zECw00c7//89dPYDhF1YN39ngRX0ALjicgCb8dqAIEdKQYH8MXtgZdBYe1MknN10VlRwKbtOVhgDNs9aIGK64mIMSJsNZXLBUts5XvckommgwBsdij2K5OF1fKCqG22ycDVSgiMwUaYuPTo73iWkuhraakf4FWeAtXDGJ25NeOgUkklOWJuZjS86YJWUE0vhlm2PVYwyVzPSkmjY4ZtkOjbUp5GafOo24YRI1InRnksoNshxUgMpoWGgT+glppJJOSmmlll6Kaaaabsppp55+Cmqooo5KKmx5ZvdoCoHuc+Y9q8aRaqmqjvZLrELod06rruKqhq2yPkirL74CS5Gu9gwbBbK//754ZbIqOsLrC8q+JduQt756KxHRtjAtE88ui+AjVZwKrbMGBtuIsczyqIJxNTFSKLg+oVsTeTtsyy2+WBJZ1DHRkpsvuxTqOwWV8obb7Ls6dIvmDAArMti/9AYsBcP0kXkwwgLnYHHCCxPMWsdNrCKxx6mAzA/KUBh8bpoJY9PlkXfBLDPNL7eCs8uu2bxzzmvWbC2fMd+cZp48z+zz0D3rjHTRwUKYNNBM8yk0O09HfaVvWC/9M9Fdc630oEJOnfTRZm/d9Ndph3022W6r3TbcaC9ZtddscxXm2iHK/fY/d7tsL9R9S921o1gHPrdNrBGu9KKD2824JikmznTGljpfjnnmmm/Oeeeefw566KKPTnrppp+Oeuqqr856666/Dnvsss9Oe+2234577rp3JPLuvpel8u/Cc1QAACH5BAUFAAEALAwAogECAAIAAAIChFEAIfkEBQoAAQAsFQCiAQIAAgAAAgKEUQAh+QQFBQABACwdAJoBFQAKAAACGwwQqct61+J6SEpqLcy38rZ9ohhOnmmcjpocBQAh+QQFCgABACw5AKIBAgACAAACAoRRACH5BAUFAAEALEIAogECAAIAAAIChFEAIfkEBQUAAQAsSwCiAQIAAgAAAgKEUQAh+QQFBQABACxUAKIBAgACAAACAoRRACH5BAUKAAEALF0AogELAAIAAAIGBIIZZppWACH5BAUFAAEALG8AogECAAIAAAIChFEAIfkEBQUAAQAseACiAQIAAgAAAgKEUQAh+QQFBQABACyBAKIBAgACAAACAoRRACH5BAUFAAEALIoAogECAAIAAAIChFEAIfkEBQUAAQAskwCiAQIAAgAAAgKEUQAh+QQFBAABACycAKIBAgACAAACAoRRACH5BAUEAAEALKUAogECAAIAAAIChFEAIfkEBQQAAQAsrgCiAQIAAgAAAgKEUQAh+QQFCQABACy3AKIBAgACAAACAoRRACH5BAUEAAEALMAAogECAAIAAAIChFEAIfkEBQQAAQAsyQCiAQIAAgAAAgKEUQAh+QQFBAABACzSAKIBAgACAAACAoRRACH5BAUFAAEALNsAogECAAIAAAIChFEAIfkEBQUAAQAs5ACiAQIAAgAAAgKEUQAh+QQFBQABACztAKIBAgACAAACAoRRACH5BAUKAAEALPYAogECAAIAAAIChFEAIfkEBQUAAQAs/wCiAQsAAgAAAgYEghlmmlYAIfkEBQoAAQAsEQGiAQIAAgAAAgKEUQAh+QQFBQABACwaAaIBAgACAAACAoRRACH5BAUFAAEALCMBogECAAIAAAIChFEAIfkEBQUAAQAsLAGiAQIAAgAAAgKEUQAh+QQFBQABACw1AaIBAgACAAACAoRRACH5BAUFAAEALD4BogECAAIAAAIChFEAIfkEBQUAAQAsRwGiAQIAAgAAAgKEUQAh+QQFBQABACxQAaIBAgACAAACAoRRACH5BAUFAAEALFkBogECAAIAAAIChFEAIfkEBQUAAQAsYgGiAQIAAgAAAgKEUQAh+QQFBAABACxrAaIBAgACAAACAoRRACH5BAUEAAEALHQBogECAAIAAAIChFEAIfkEBQkAAQAsfQGiAQIAAgAAAgKEUQAh+QQFBAABACyGAaIBAgACAAACAoRRACH5BAUEAAEALI8BogECAAIAAAIChFEAIfkEBQQAAQAsmAGiAQIAAgAAAgKEUQAh+QQFBQABACyhAaIBAgACAAACAoRRACH5BAUFAAEALKoBogECAAIAAAIChFEAIfkEBQUAAQAsswGiAQIAAgAAAgKEUQAh+QQFBQABACy8AaIBAgACAAACAoRRACH5BAUKAAEALMUBogECAAIAAAIChFEAIfkEBQUAAQAszgGiAQIAAgAAAgKEUQAh+QQFBQABACzXAaIBCwACAAACBgSCGWaaVgAh+QQFBQABACzpAaIBAgACAAACAoRRACH5BAUKAAEALPIBogECAAIAAAIChFEAIfkEBQUAAQAs+wGiAQIAAgAAAgKEUQAh+QQFBQABACwEAqIBAgACAAACAoRRACH5BAUFAAEALA0CogECAAIAAAIChFEAIfkEBQUAAQAsFgKiAQIAAgAAAgKEUQAh+QQFBQABACwfAqIBAgACAAACAoRRACH5BAUFAAEALCgCogECAAIAAAIChFEAIfkEBQUAAQAsMQKiAQIAAgAAAgKEUQAh+QQFCQABACw6AqIBCwACAAACBgSCGWaaVgAh+QQFBAABACxMAqIBAgACAAACAoRRADs=" alt="QEMU 显示 &quot;.....H...e...l...l..o..... ...W..o..r....l...d...!&quot;"></p> <p>查看电脑的 CPU 使用率可以发现 <code>QEMU</code> 进程现在会一直保持 CPU 繁忙。这因为 <code>SimpleExecutor</code> 在循环里面不断地轮询任务。所以即使我们没有按下键盘的任何按键，执行器也会不断地调用 <code>print_keypresses</code> 任务的 <code>poll</code>，尽管这是任务没有任何进度并每次都会返回 <code>Poll::Pending</code>。</p> <h3 id="支持-waker-的执行器"><a href="#支持-waker-的执行器" class="header-anchor">#</a> 支持 waker 的执行器</h3> <p>为了解决性能问题，我们需要创建一个能够正确利用 <code>Waker</code> 通知的执行器。这样，执行器在下一次键盘输入时就能被唤醒，不需要不断地轮询 <code>print_keypresses</code> 任务。</p> <h4 id="任务-id"><a href="#任务-id" class="header-anchor">#</a> 任务 ID</h4> <p>创建一个能够正确利用 <code>Waker</code> 通知的执行器的第一步是给每个任务分配一个唯一的 ID。这是因为我们需要一种注明哪个任务应该被唤醒的方式。先创建一个新的 <code>TaskId</code> 包装类型：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/mod.rs</span>

<span class="token attribute attr-name">#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">TaskId</span><span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>TaskId</code> 结构体是包装 <code>u64</code> 的一个简单类型。我们为其实现几个 trait 使其能够被打印、赋值、比较和排序。后者是重要的，这样 <code>TaskId</code> 才能用于作为马上用到的 <a href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html" target="_blank" rel="noopener noreferrer"><code>BTreeMap</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的键类型。</p> <p>为了创建一个唯一的 ID，我们创建一个 <code>TaskID::new</code> 函数：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>sync<span class="token punctuation">::</span>atomic<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">AtomicU64</span><span class="token punctuation">,</span> <span class="token class-name">Ordering</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">TaskId</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
        <span class="token keyword">static</span> <span class="token constant">NEXT_ID</span><span class="token punctuation">:</span> <span class="token class-name">AtomicU64</span> <span class="token operator">=</span> <span class="token class-name">AtomicU64</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TaskId</span><span class="token punctuation">(</span><span class="token constant">NEXT_ID</span><span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Relaxed</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这个函数使用 <a href="https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU64.html" target="_blank" rel="noopener noreferrer"><code>AtomicU64</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型的静态变量 <code>NEXT_ID</code> 来确保每个 ID 都只会被赋值一次。<a href="https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU64.html#method.fetch_add" target="_blank" rel="noopener noreferrer"><code>fetch_add</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法原子性地增加值并返回上一个值。这意味着即使 <code>TaskId::new</code> 被并发低调用，每个返回的 ID 都是唯一的。<a href="https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html" target="_blank" rel="noopener noreferrer"><code>Ordering</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 参数定义是否允许编译器重排序指令流中的 <code>fetch_add</code> 操作。由于我们只要求 ID 唯一，所以这种情况下使用要求最弱的 <code>Relaxed</code> 排序即可。</p> <p>现在可以用一个额外的 <code>id</code> 字段拓展我们的 <code>Task</code> 类型了：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/mod.rs</span>

<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Task</span> <span class="token punctuation">{</span>
    id<span class="token punctuation">:</span> <span class="token class-name">TaskId</span><span class="token punctuation">,</span> <span class="token comment">// new</span>
    future<span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>future<span class="token punctuation">:</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">+</span> <span class="token lifetime-annotation symbol">'static</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>
        <span class="token class-name">Task</span> <span class="token punctuation">{</span>
            id<span class="token punctuation">:</span> <span class="token class-name">TaskId</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// new</span>
            future<span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">pin</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>新的 <code>id</code> 字段让我们可以唯一命名一个任务，这对于唤醒特定任务必须的。</p> <h4 id="executor-类型"><a href="#executor-类型" class="header-anchor">#</a> <code>Executor</code> 类型</h4> <p>我们在 <code>task::executor</code> 模块创建新的 <code>Executor</code> 类型：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/mod.rs</span>

<span class="token keyword">pub</span> <span class="token keyword">mod</span> <span class="token module-declaration namespace">executor</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">::</span><span class="token punctuation">{</span><span class="token class-name">Task</span><span class="token punctuation">,</span> <span class="token class-name">TaskId</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">alloc<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token namespace">collections<span class="token punctuation">::</span></span><span class="token class-name">BTreeMap</span><span class="token punctuation">,</span> <span class="token namespace">sync<span class="token punctuation">::</span></span><span class="token class-name">Arc</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token class-name">Waker</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">crossbeam_queue<span class="token punctuation">::</span></span><span class="token class-name">ArrayQueue</span><span class="token punctuation">;</span>

<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Executor</span> <span class="token punctuation">{</span>
    tasks<span class="token punctuation">:</span> <span class="token class-name">BTreeMap</span><span class="token operator">&lt;</span><span class="token class-name">TaskId</span><span class="token punctuation">,</span> <span class="token class-name">Task</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    task_queue<span class="token punctuation">:</span> <span class="token class-name">Arc</span><span class="token operator">&lt;</span><span class="token class-name">ArrayQueue</span><span class="token operator">&lt;</span><span class="token class-name">TaskId</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>
    waker_cache<span class="token punctuation">:</span> <span class="token class-name">BTreeMap</span><span class="token operator">&lt;</span><span class="token class-name">TaskId</span><span class="token punctuation">,</span> <span class="token class-name">Waker</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
        <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
            tasks<span class="token punctuation">:</span> <span class="token class-name">BTreeMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            task_queue<span class="token punctuation">:</span> <span class="token class-name">Arc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">ArrayQueue</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            waker_cache<span class="token punctuation">:</span> <span class="token class-name">BTreeMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>没有像之前 <code>SimpleExecutor</code> 那样把任务保存在 <a href="https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html" target="_blank" rel="noopener noreferrer"><code>VecDeque</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，我们使用一个任务 ID 的 <code>task_queue</code> 和一个包含真实 <code>Task</code> 实例的、名为 <code>tasks</code> 的 <a href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html" target="_blank" rel="noopener noreferrer"><code>BTreeMap</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。<a href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html" target="_blank" rel="noopener noreferrer"><code>BTreeMap</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 用 <code>TaskId</code> 索引允许特定任务的高效继续执行。</p> <p><code>task_queue</code> 字段是任务 ID 的 <a href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html" target="_blank" rel="noopener noreferrer"><code>ArrayQueue</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，用实现 <em>引用计数</em> 的 <a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html" target="_blank" rel="noopener noreferrer"><code>Arc</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型包装。引用计数使得在多个拥有者之间共享值的所有权成为可能。具体工作方式是在堆上分配值，并记录这个值得活跃引用。当活跃引用数变 0 时，这个不再需要的值就可以被释放了。</p> <p>用 <code>Arc&lt;ArrayQueue&gt;</code> 作为 <code>task_queue</code> 的类型是因为它会在执行器和唤醒器之间共享。思路是唤醒器往队列添加被唤醒任务的 ID。执行器在队列的接收端，根据任务 ID 从 <code>tasks</code> 字典提取被唤醒的任务，然后执行它们。使用定长队列而不是诸如 <a href="https://docs.rs/crossbeam-queue/0.2.1/crossbeam_queue/struct.SegQueue.html" target="_blank" rel="noopener noreferrer"><code>SegQueue</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这样的不定长队列是因为中断处理函数在往队列添加值不应该触发内存分配。</p> <p>除了 <code>task_queue</code> 和 <code>tasks</code>，<code>Executor</code> 类型还有一个也是字段的 <code>waker_cache</code> 字段。这个字段缓存任务创建后的 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html" target="_blank" rel="noopener noreferrer"><code>Waker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。理由有二：其一，它通过为多次唤醒同一个任务复用同一个唤醒器而不是每次创建一个新的唤醒器，从而提高性能；其二，它保证引用计数的唤醒器不会再中断处理函数内被释放，因为这会触发死锁（后续有对此更加详细的描述。）。</p> <p>为了创建 <code>Executor</code>，我们提供一个简单的 <code>new</code> 函数。选定 <code>task_queue</code> 容量为 100，这对可见的未来应该绰绰有余了。如果系统某个时候需要用到超过 100 个并发任务，我们可以很容易增加这个值。</p> <h4 id="spawning-tasks"><a href="#spawning-tasks" class="header-anchor">#</a> Spawning Tasks</h4> <h4 id="新建任务"><a href="#新建任务" class="header-anchor">#</a> 新建任务</h4> <p>参照 <code>SimpleExecutor</code>，我们为 <code>Executor</code> 类型提供一个 <code>spawn</code> 方法，用于往 <code>tasks</code> 字典添加给定任务，并通过将其 ID 添加到 <code>task_queue</code> 来立即唤醒它：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">impl</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">spawn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> task<span class="token punctuation">:</span> <span class="token class-name">Task</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> task_id <span class="token operator">=</span> task<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>id<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is_some</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token macro property">panic!</span><span class="token punctuation">(</span><span class="token string">&quot;task with same ID already in tasks&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>task_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>task_id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">&quot;queue full&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果字段中已有一个同样 ID 的任务，[<code>BTreeMap::insert</code>] 方法会返回它。由于每个任务都有唯一的 ID，所以这应该永远都不会发生，一旦发生说明我们的代码有 bug，panic 即可。类似地，如果队列长度足够大的话，<code>task_queue</code> 容量应该永不会打满，所以这种情况下也直接触发 panic。</p> <h4 id="运行中的任务"><a href="#运行中的任务" class="header-anchor">#</a> 运行中的任务</h4> <p>为了执行 <code>task_queue</code> 中的所有任务，我们创建一个私有的 <code>run_ready_tasks</code> 方法：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Context</span><span class="token punctuation">,</span> <span class="token class-name">Poll</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">run_ready_tasks</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// destructure `self` to avoid borrow checker errors</span>
        <span class="token keyword">let</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
            tasks<span class="token punctuation">,</span>
            task_queue<span class="token punctuation">,</span>
            waker_cache<span class="token punctuation">,</span>
        <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>task_id<span class="token punctuation">)</span> <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> task <span class="token operator">=</span> <span class="token keyword">match</span> tasks<span class="token punctuation">.</span><span class="token function">get_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task_id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Some</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> task<span class="token punctuation">,</span>
                <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token keyword">continue</span><span class="token punctuation">,</span> <span class="token comment">// task no longer exists</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> waker <span class="token operator">=</span> waker_cache
                <span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>task_id<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">or_insert_with</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token class-name">TaskWaker</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>task_id<span class="token punctuation">,</span> task_queue<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> <span class="token keyword">mut</span> context <span class="token operator">=</span> <span class="token class-name">Context</span><span class="token punctuation">::</span><span class="token function">from_waker</span><span class="token punctuation">(</span>waker<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">match</span> task<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token comment">// task done -&gt; remove it and its cached waker</span>
                    tasks<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    waker_cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>这个函数的思路和 <code>SimpleExecutor</code> 类似：遍历 <code>task_queue</code> 的所有任务，为每个任务创建一个唤醒器，然后轮询它们。然而，我们让 <code>TaskWaker</code> 的实现负责把唤醒的任务放回队列，而不是把挂起的任务放回 <code>task_queue</code> 末尾。这个唤醒器类型我们马上就会看到。</p> <p>让我们看一下这个 <code>run_ready_tasks</code> 方法的一些实现细节：</p> <ul><li>我们使用 <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values" target="_blank" rel="noopener noreferrer"><em>析构</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来把 <code>self</code> 打散成三个字段，避免一些借用检查触发的错误。即，我们的实现需要在一个闭包里面访问 <code>self.task_queue</code>，这当前会完整地借用 <code>self</code>。这是在 <a href="https://github.com/rust-lang/rfcs/pull/2229" target="_blank" rel="noopener noreferrer">RFC 2229<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> [实现后]RFC 2229 impl] 才能解决的一个严重的借用检查器问题</li> <li>对于每个弹出的任务 ID，我们从 <code>tasks</code> 字段提取相应任务的可变引用。由于我们的 <code>ScancodeStream</code> 实现在检查任务需要休眠前注册唤醒器，这样可能会出现在一个任务不再存在后触发唤醒的现象。这种情况下，我们无脑地忽略唤醒并继续取队列的下一个 ID 即可</li> <li>为了避免每次轮询使创建唤醒器的性能损耗，我们使用 <code>waker_cache</code> 字典为每个创建后的任务保存唤醒器。为此，我们结合使用 <a href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html#method.entry" target="_blank" rel="noopener noreferrer"><code>BTreeMap::entry</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法和 <a href="https://doc.rust-lang.org/alloc/collections/btree_map/enum.Entry.html#method.or_insert_with" target="_blank" rel="noopener noreferrer"><code>Entry::or_insert_with</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为尚未存在唤醒器的情况创建一个唤醒器，并获得这个唤醒器的可变引用。为了创建一个唤醒器，我们克隆 <code>task_queue</code> 并把它和任务 ID 传给 <code>TaskWaker::new</code> 函数（实现往后看）。由于 <code>task_queue</code> 用 <code>Arc</code> 包装，<code>clone</code> 只会增加值得引用计数，但是仍然指向同一个堆上分配的队列。需要注意的是像这样复用唤醒器不是对所有唤醒器实现都行的，但是我们的 <code>TaskWaker</code> 类型是支持的。</li></ul> <p>任务返回 TODO 时就结束了。这种情况下，我们使用 TODO 方法从 TODO 字段移除它。如果存在的话，我们也把它从唤醒器缓存移除。</p> <h4 id="唤醒器设计"><a href="#唤醒器设计" class="header-anchor">#</a> 唤醒器设计</h4> <p>唤醒器的任务是把唤醒任务的 ID 添加到执行器的 <code>task_queue</code>。我们的实现为创建一个新的 <code>TaskWaker</code> 结构体，保存任务 ID 和 <code>task_queue</code> 的引用：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">TaskWaker</span> <span class="token punctuation">{</span>
    task_id<span class="token punctuation">:</span> <span class="token class-name">TaskId</span><span class="token punctuation">,</span>
    task_queue<span class="token punctuation">:</span> <span class="token class-name">Arc</span><span class="token operator">&lt;</span><span class="token class-name">ArrayQueue</span><span class="token operator">&lt;</span><span class="token class-name">TaskId</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>由于 <code>task_queue</code> 的所有权在执行器和唤醒器之间共享，我们使用 <a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html" target="_blank" rel="noopener noreferrer"><code>Arc</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包装器类型来实现共享引用计数的所有权。</p> <p>唤醒操作的实现非常简单：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">impl</span> <span class="token class-name">TaskWaker</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">wake_task</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>task_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>task_id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">&quot;task_queue full&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>我们把 <code>task_id</code> 添加到引用的 <code>task_queue</code>。由于 <a href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html" target="_blank" rel="noopener noreferrer"><code>ArrayQueue</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型的更改只要求一个共享引用，我们可以用 <code>&amp;self</code> 而不是 <code>&amp;mut self</code> 实现这个方法。</p> <h5 id="wake-trait"><a href="#wake-trait" class="header-anchor">#</a> <code>Wake</code> trait</h5> <p>为了使用 <code>TaskWaker</code> 类型轮询 future，我们需要首先把它转换成 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html" target="_blank" rel="noopener noreferrer"><code>Waker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 实例。这有必要是因为 <a href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html#tymethod.poll" target="_blank" rel="noopener noreferrer"><code>Future::poll</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法接收的 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Context.html" target="_blank" rel="noopener noreferrer"><code>Context</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 参数只能从 <code>Waker</code> 类型构造。我们提供一个 <a href="https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html" target="_blank" rel="noopener noreferrer"><code>RawWaker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型的实现即可，它也比实现基于 <code>Arc</code> 的 <a href="https://doc.rust-lang.org/nightly/alloc/task/trait.Wake.html" target="_blank" rel="noopener noreferrer"><code>Wake</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 更加简单和安全，然后使用标准库提供的 <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" target="_blank" rel="noopener noreferrer"><code>From</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 实现来构造 <code>Waker</code>。</p> <p>trait 的实现如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">use</span> <span class="token namespace">alloc<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token class-name">Wake</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">Wake</span> <span class="token keyword">for</span> <span class="token class-name">TaskWaker</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">wake</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Arc</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">wake_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">wake_by_ref</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Arc</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">wake_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>这个 trait 尚未稳定，所以我们必须在 <code>lib.rs</code> 头部添加 <strong><code>#![feature(wake_trait)]</code></strong> 来使用它。由于唤醒器常常在执行器和异步任务之间共享，trait 方法要求实现引用计数所有权的包裹在 <a href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html" target="_blank" rel="noopener noreferrer"><code>Arc</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型里面的 <code>Self</code> 实例。这意味着我们必须把 <code>TaskWaker</code> 移入 <code>Arc</code> 才能调用它们。</p> <p><code>wake</code> 和 <code>wake_by_ref</code> 方法的区别在于后者只要求 <code>Arc</code> 的引用，而前者则获得 <code>Arc</code> 所有权，因此通常会要求增加引用的计数值。不是所有类型都支持借助引用来唤醒，所以实现 <code>wake_by_ref</code> 方法是可选的，然而它能避免不必要的引用计数更新从而带来更好的性能。在我们的场景下，我们可以单纯把两个 trait 方法导给 <code>wake_task</code> 函数，这个函数只需要一个共享的引用。</p> <h5 id="创建唤醒器"><a href="#创建唤醒器" class="header-anchor">#</a> 创建唤醒器</h5> <p>由于 <code>Waker</code> 类型支持所有实现 <code>Wake</code> trait 的 <code>Arc</code> 包装值的 <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" target="_blank" rel="noopener noreferrer"><code>From</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 转换，我们可以现在实现 <code>Executor::run_ready_tasks</code> 方法要求的 <code>TaskWaker::new</code> 函数了：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">impl</span> <span class="token class-name">TaskWaker</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>task_id<span class="token punctuation">:</span> <span class="token class-name">TaskId</span><span class="token punctuation">,</span> task_queue<span class="token punctuation">:</span> <span class="token class-name">Arc</span><span class="token operator">&lt;</span><span class="token class-name">ArrayQueue</span><span class="token operator">&lt;</span><span class="token class-name">TaskId</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Waker</span> <span class="token punctuation">{</span>
        <span class="token class-name">Waker</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">Arc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">TaskWaker</span> <span class="token punctuation">{</span>
            task_id<span class="token punctuation">,</span>
            task_queue<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们基于传入的 <code>task_id</code> 和 <code>task_queue</code> 创建 <code>TaskWaker</code>。然后用 <code>Arc</code> 包装 <code>TaskWaker</code>，并使用 <code>Waker::from</code> 实现来把它转化成 <a href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html" target="_blank" rel="noopener noreferrer"><code>Waker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。这个 <code>from</code> 方法负责为 <code>TaskWaker</code> 类型构造 <a href="https://doc.rust-lang.org/stable/core/task/struct.RawWakerVTable.html" target="_blank" rel="noopener noreferrer"><code>RawWakerVTable</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html" target="_blank" rel="noopener noreferrer"><code>RawWaker</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 示例。如果对其原理感兴趣的话，参见 <a href="https://github.com/rust-lang/rust/blob/cdb50c6f2507319f29104a25765bfb79ad53395c/src/liballoc/task.rs#L58-L87" target="_blank" rel="noopener noreferrer"><code>alloc</code> 包的实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h4 id="run-方法"><a href="#run-方法" class="header-anchor">#</a> <code>run</code> 方法</h4> <p>唤醒器实现在手后，我们终于能够为执行器构造 <code>run</code> 方法了：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">impl</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
        <span class="token keyword">loop</span> <span class="token punctuation">{</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">run_ready_tasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这个方法只是在一个循环里面调用 <code>run_ready_tasks</code> 函数，虽然理论上 <code>tasks</code> 变空时我们可以从函数返回，但是由于我们的 <code>keyboard_task</code> 任务永不结束，这是不可能发生的，所以一个简单的 <code>loop</code> 应该够用了。由于函数不会返回，我们使用 TODO 返回类型向编译器声明函数是 <a href="https://doc.rust-lang.org/stable/rust-by-example/fn/diverging.html" target="_blank" rel="noopener noreferrer">发散的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>现在更新 <code>kernel_main</code> 使用 <code>Executor</code> 代替 <code>SimpleExecutor</code>：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">use</span> <span class="token namespace">blog_os<span class="token punctuation">::</span>task<span class="token punctuation">::</span>executor<span class="token punctuation">::</span></span><span class="token class-name">Executor</span><span class="token punctuation">;</span> <span class="token comment">// new</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token comment">// […] initialization routines, including init_heap, test_main</span>

    <span class="token keyword">let</span> <span class="token keyword">mut</span> executor <span class="token operator">=</span> <span class="token class-name">Executor</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new</span>
    executor<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token class-name">Task</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">example_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token class-name">Task</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token namespace">keyboard<span class="token punctuation">::</span></span><span class="token function">print_keypresses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>我们只需要更新导入路径和类型名称即可。由于我们的 <code>run</code> 函数标记为发散的，编译直到它永不返回，所以我们不在需要在 <code>kernel_main</code> 函数末尾调用 <code>hlt_loop</code> 了。</p> <p>现在借助 TODO 运行内核可以看到键盘输入依然是可用的：</p> <p><img src="data:image/gif;base64,R0lGODlh0AKoAfYBAP//VQAAAJCQkJKSkpOTk5SUlJWVlZaWlpiYmJmZmZqampycnJ2dnZ+fn6CgoKKioqOjo6SkpKenp6mpqaqqqqurq6ysrK2tra6urq+vr7GxsbOzs7S0tLW1tba2tre3t7m5ubq6uru7u7y8vL6+vsDAwMPDw8TExMbGxsjIyMnJycvLy8zMzM3Nzc/Pz9PT09XV1dbW1tfX19ra2t/f3+Dg4OLi4uPj4+Xl5ebm5ujo6Ovr6+zs7O3t7e/v7/Dw8PHx8fLy8vPz8/T09PX19ZeXl5ubm56enqGhoaWlpaampqioqLCwsLKysr29vb+/v8LCwsXFxdDQ0NHR0dLS0tTU1NjY2NnZ2dvb293d3d7e3uHh4efn5+7u7vb29lVVVQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hlPcHRpbWl6ZWQgdXNpbmcgZXpnaWYuY29tACH5BAQEAP8ALAAAAADQAqgBAAf/gF6Cg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6eriCQlDhBIC747yhDv1nRVOhUwf9z/rAgocSHBcOxiDcizA14ihqBhFhCQcsIUIj4IYM2rcuCyBiAuDSICohyXCggUnBNVQYgSJFUECpjw4APJfj5gWHlgA4sXGkgZIUkgyMiVkkp4kfwb1sgALTBGCPkDhSLWq1augEmAxsANmlnpFqCCtAQTBSy0DLgoA8a4BC5tr/wVBeJvAhddIJ5YMYiAFKcC6XkFMXflALg2siBMrXnxIq4eUMSj8K+RACkRDAnJEfQKXy+bLgkxskETRr1/QXkRHTp3CQQ8dCCwynk27dkGtaIlgoDJ5hQQlLC0XtofvcefPA06e3BlpwwgvGkgI+tciufKdBYJIBlGlBQfb4MOLZ1excux/Vw54Zio8Ic/iJI5DJyFjwaWvk0/b52fF3YsQTRQ13oAEFhiNVqmhpN871a3wg1mmwSefcYANQd8kOoE0HVgvRPUSCktkAJMCXRho4okoCoNgF6VNdsFJLKAQFg1JHHTXfBNK59MRC/gzCQsxTQTQjj3ydEOQTCmR4v+STDbp5JNQRinllFRWaeWVWGap5ZZcdunll2CGKeaYZJZp5ploqpLFmmy26eabcMYp55x01mnnnXjmqeeefPbp55+ABirooIQWauihiCaq6KKMNuqongFEKumklFZq6aWYZqrpppx26umnoIYq6qiklmrqqaimquqqrLbq6quwxirrrLTWauutuOaq66689urrr8AGK+ywxBZr7LHIJqvsssw26+yz0EYr7bTUVmvttdhmq+223Hbr7bfghivuuOSWa+656Kar7rrstuvuu/DGK++89NZr77345qvvvvz26++/AAcs8MAEF2zwwQgnrPDCDDfs8MMQRyzxxBRXbPH/xRhnrPHGHHfs8ccghyzyyCSXbPLJKKes8sost+zyyzDHLPPMNNds880456zzzjz37PPPQAct9NBEF2300UgnrfTSTDft9NNQRy311FRXbfXVWGet9dZcd+3112CHLfbYZJdt9tlop6322my37fbbcMct99x012333XjnrffefPft99+ABy744IQXbvjhiCeu+OKMN+7445BHLvnklFdu+eWYZ6755px37vnnoIcu+uikl2766ainrvrqrLfu+uuwxy777LTXbvvtuOeu++689+7778AHL/zwxBdv/PHIJ6/88sw37/zz0Ecv/fTUV2/99dhnr/323Hfv/ffghy/+//jkl2/++einr/767Lfv/vvwxy///PTXb//9+Oev//789+///wAMoAAHSMACGvCACEygAhfIwAY68IEQjKAEJ0jBClrwghjMoAY3yMEOevCDIAyhCEdIwhKa8IQoTKEKV8jCFrrwhTCMoQxnSMMa2vCGOMyhDnfIwx768IdADKIQh0jEIhrxiEhMohKXyMQmOvGJUIyiFKdIxSpa8YpYzKIWt8jFLnrxi2AMoxjHSMYymvGMaEyjGtfIxja68Y1wjKMc50jHOtrxjnjMox73yMc++vGPgAykIAdJyEIa8pCITKQiF8nIRjrykZCMpCQnSclKWvKSmMykJjfJyU568v+ToAylKEdJylKa8pSoTKUqV8nKVrrylbCMpSxnScta2vKWuMylLnfJy1768pfADKYwh0nMYhrzmMhMpjKXycxmOvOZ0IymNKdJzWpa85rYzKY2t8nNbnrzm+AMpzjHSc5ymvOc6EynOtfJzna6853wjKc850nPetrznvjMpz73yc9++vOfAA2oQAdK0IIa9KAITahCF8rQhjr0oRCNqEQnStGKWvSiGM2oRjfK0Y569KMgDalIR0rSkpr0pChNqUpXytKWuvSlMI2pTGdK05ra9KY4zalOd8rTnvr0p0ANqlCHStSiGvWoSE2qUpfK1KY69alQjapUp0rVqlr1qlj/zapWt8rVrnr1q2ANq1jHStaymvWsaFUeAAAgqbVyaq1spRRcS+XWtsZVVHOtVF4nVdd69rWvmgKsXel61wAIFlSHjZRg4VpYef61sZhKbGI9BdjJdmqyi93rPB9rV80qFrKGbSxjQSvXwtZ1tIP1bGj16lnG2nO0p71rZi1VWdmSdrCptW1nV8tX0bL1sJZ1J2dDi9re0ta0us2UW5f72+Tydra4Be5thZvc4EoWubiNbHNXO1zeHte43s0uPYdrXdDWVrzHha13u8ta8AbXr9V17me/m933Pjeu3bXsecM739c6t7id9W1tVUvfx+7VtawdMH/tm9YGO/jBEI6wFoQnTOEKW/jCGM6whjfM4Q57+MNlCwQAIfkEBQkAAgAsAAB6AZcAHQAAAv8EgobLbNdem9TBdKsOcna7heLIXcp4RhkJLinbeuuzwnaVvpuO3XHpc9V6Fl4wmDPRZBQdbahqPYWlGm9ZhB5tz1MyyqQSNS/FF3NwztJW7RZ27q6bmTOZDbR75+Kr+00S52ZUphRihqenVTgmBngkuDPE2EjXBTRm1Lj32BnDWUlYZ3gIAYqJGkbk54lEWqUWO/ohmYkFazmbutva6/sLHCw8TFxsfIycrLzM3Oz8DB0tPU1tTKtceF0trFn8YbfN/Qc3LqTZjZv1ykk7VVrVp2Qqv/bN1haIp/pu27867+jOP1uX8qyTxytfpYQq2uHzd0ohplOIJgKEZW9hPndVGsHE+kQqIoqLFBORvLgPECV+ohxFYijQYr+KMhl2Q0cn4I+S8Vye1Jmz5heaoBTFZGE0FE2M6kLSK1dSX8U9Du3hRNpBDrCr4bo+4uo1LJdbYr0WAAAh+QQFBAABACwDAKIBAgACAAACAoRRACH5BAUJAAEALAwAogELAAIAAAIGBIIZZppWACH5BAUEAAEALB4AogECAAIAAAIChFEAIfkEBQQAAQAsJwCiAQIAAgAAAgKEUQAh+QQFBAABACwwAKIBAgACAAACAoRRACH5BAUEAAEALDkAogECAAIAAAIChFEAIfkEBQQAAQAsQgCiAQIAAgAAAgKEUQAh+QQFCQABACxLAKIBAgACAAACAoRRACH5BAUEAAEALFQAogECAAIAAAIChFEAIfkEBQQAAQAsXQCiAQIAAgAAAgKEUQAh+QQFDQABACxmAKIBAgACAAACAoRRACH5BAUEAAEALG8AogECAAIAAAIChFEAIfkEBQQAAQAseACiAQIAAgAAAgKEUQAh+QQFCQABACyBAKIBCwACAAACBgSCGWaaVgAh+QQFBAABACyTAKIBAgACAAACAoRRACH5BAUEAAEALJwAogECAAIAAAIChFEAIfkEBQQAAQAspQCiAQIAAgAAAgKEUQAh+QQFBAABACyuAKIBAgACAAACAoRRACH5BAUEAAEALLcAogECAAIAAAIChFEAIfkEBQgAAQAswACiAQIAAgAAAgKEUQAh+QQFBAABACzJAKIBAgACAAACAoRRACH5BAUEAAEALNIAogECAAIAAAIChFEAIfkEBQQAAQAs2wCiAQIAAgAAAgKEUQAh+QQFBAABACzkAKIBAgACAAACAoRRACH5BAUJAAEALO0AogECAAIAAAIChFEAIfkEBQQAAQAs9gCiAQIAAgAAAgKEUQAh+QQFBAABACz/AKIBAgACAAACAoRRACH5BAUIAAEALAgBogECAAIAAAIChFEAIfkEBQkAAQAsEQGiAQsAAgAAAgYEghlmmlYAIfkEBQoAAQAsIwGiAQIAAgAAAgKEUQAh+QQFBAABACwsAaIBAgACAAACAoRRACH5BAUFAEUALAkACAAuAZwBAAf/gAEBQUWFRV+DhoqLhTkBN4o0iYyUlZVfBItfX5I6lp+goaKjpKWmp6ipqquWAV8chjGIQqOOkIZDN0SslB2TRTYBLLm7vMbHyMnKy8yLrl+GB7NFJZuYhSuIr8ABFdo8nTjd1jxFLdYKpkPbhQTQnebohyVFQwEChdfN+/z9/v9FApR4VE/gICDdzAnjIVChDUdfhPD48iDcvXoUGUoAxo7UAGgYJ3DToZHjh2vZQH5JAbCly5cwW7G41oFToh1D8lHwEMAQSUcw8iGwKEMoz2ggSd0QRi1Rp6PtXkErkIDTjF8xs2rdmkwYioivJNFyYK3bg6SNCB4yYPEWJgjP/7SduqavE9yyEQetfBUBLde/gAOHYvpqkNgRAYoemgDVHDi1mNoa9XvqxCO1TykXHpJhkwXBoEOLZqpg00gKEYvAbbAjYYpHtoRKXlsSiAEQqKzFgp3QNm4Dpm8gyiG6uHGtTIGO7IHugMAU2jyMlM3brYF45FA9aJjW07nsLgIsyEf5uPnz6NOrX8++vfv38OPLn0+/vv37+PPr38+/v///AAYo4IAEFmjggQgmqOCCDDbo4IMQRijhhBRWaOGFGGao4YYcdujhhyCGKOKIJJZo4okopqjiiiy26OKLMMYo44w01mjjjTjmqOOOPPbo449ABinkkEQWaeSRSCap5P+STDbp5JNQRinllFRWaeWVWGap5ZZcdunll2CGKeaYZJZp5plopqnmmmy26eabcMYp55x01mnnnXjmqeeefPbp55+ABirooIQWauihiCaq6KKMNuroo5BGKumklFZq6aWYZqrpppx26umnoIYq6qiklmrqqaimquqqrLbq6quwxirrrLTWauutuOaq66689urrr8AGK+ywxBZr7LHIJqvsssw26+yz0EYr7bTUVmvttdhmq+223Hbr7bfghivuuOSWa+656Kar7rrstuvuu/DGK++89NZr77345qvvvvz26++/AAcs8MAEF2zwwQgnrPDCDDfs8MMQRyzxxBRXbPGuxRhnrPHGHHfs8ccghyzyyCSXbPLJKKes8sost+zyyzDHLPPMNNds880456zzzjz37PPPQAct9NBEF2300UgnrfTSTDft9NNQRy311FRXbfXVWGet9dZcd+3112CHLfbYZJdt9tlop6322my37fbbcMct99x012333XjnrffefPft99+ABy744IQXbvjhiCeu+OKMN+7445BHLvnklFdu+eWYZ6755mcDAAC2ngcCACH5BAUJAAEALD4BogECAAIAAAIChFEAIfkEBQQAAQAsRwGiAQsAAgAAAgYEghlmmlYAIfkEBQQAAQAsWQGiAQIAAgAAAgKEUQAh+QQFBAABACxiAaIBAgACAAACAoRRACH5BAUJAAEALGsBogECAAIAAAIChFEAIfkEBQQAAQAsdAGiAQIAAgAAAgKEUQAh+QQFCQABACx9AaIBCwACAAACBgSCGWaaVgAh+QQFBAABACyPAaIBAgACAAACAoRRACH5BAUEAAEALJgBogECAAIAAAIChFEAIfkEBQgAAQAsngGaAQ4ACgAAAhkEgoab17zUg0FWB422zPKIfdNFkWPjYU0BACH5BAUEAAEALLMBogECAAIAAAIChFEAIfkEBQQAAQAsvAGiAQIAAgAAAgKEUQAh+QQFBAABACzFAaIBAgACAAACAoRRACH5BAUEAAEALMsBnQEOAAcAAAITDH6hq9nAFprx1equhJalyXlAAQAh+QQFCAABACzgAaIBAgACAAACAoRRACH5BAUEAAEALOkBogECAAIAAAIChFEAIfkEBQkAAQAs8gGaAQwACgAAAhSMb6DIsX0edGCmaiXUbfFLdQpQAAAh+QQFBAABACwEAqIBCwACAAACBgSCGWaaVgAh+QQFCAABACwVApoBDAAKAAACE4SDqafNnR4MElYHZsyacmxcRgEAIfkEBQQAAQAsKAKiAQIAAgAAAgKEUQAh+QQFBAABACwxAqIBAgACAAACAoRRACH5BAUEAAEALDoCnQENAAcAAAISjB+gisf2UIwO1JYsXFJn+jEFACH5BAUJAAEALEwCogECAAIAAAIChFEAIfkEBQQAAQAsVQKiAQIAAgAAAgKEUQAh+QQFBAABACxnAqIBAgACAAACAoRRACH5BAUEAAEALHACogECAAIAAAIChFEAIfkEBQkAAQAseQKiAQIAAgAAAgKEUQAh+QQFCAABACyCAqIBCwACAAACBgSCGWaaVgAh+QQFBAABACyUAqIBAgACAAACAoRRACH5BAUJAAEALJ0CogECAAIAAAIChFEAIfkEBQQAAQAspgKdAQ0ABwAAAhKMH6CAferMgo7SZtlNjHu0cAUAIfkEBQQAAQAsuAKiAQIAAgAAAgKEUQAh+QQFBAABACzBAqIBAgACAAACAoRRACH5BAUEAAEALMoCogECAAIAAAIChFEAIfkEBQQAAgAsAABqAcwCOgAAAv8EgobLbNdem9TBdKsOcna7heJIluaJpurKtu4Lx/JM1/aN57GCkXyUQf04wdMQZDnqlsym8wmNSqfUqvUa+ikr221p6PUVe8kx9oxOq9fstvv91l4eym6QbkaS8QvFp19EBxQGV2h4iJiouMgIg8cjB0QBNpdH1hOJcXDEuRlo2RgqOkpaanrKkvl4N0YJmOVJJHsJyYpUB4qqu8vb6/v7pGppp0co6xdLm+c6qwf8DB0tPU0tvEH8esm12pw5mVFLLT5OXm6eaK3d7OytEd5d6Q4OgXtuf4+fr7/izVc2OO+PPGUfBHn4I6HTvoUMGzp8CDGixIkUK1q8iDGjxo3/HDt6/AgypMiRJEuaPIkypcqVLFu6fAkzpkuBwQIak4kzp85RN28UjLczqNCh6HJ9MarJTE+iTJtGNAjoZzZkNnNRnVqJXlZWUmkuRfbNqdixGftpzTbr3bpte84mNQhWWdS1R9XRJYs3bz5/ds22NeJWLdh3tfiqBcz3rt7FjKu5nYs23VKsfzElI6wUqRhnjTt7fnY4MtC0jzeTlhsXM9vVde1+fg27ETO/8CjXhlU5UurAo8NMlus6tvDhajolI4LQ8OPEA+FdjlWY0s/f1zpwI449Oy/q2rt7J879u/jxeZmTP48+vfr17Nu7fw8/vvz59Ovbn9KuF00h4e/7/yefn36aVfdfgfUFuN2AzRnI4HsI2mCeDv1J4kSE50DVYIY1XCfhaExMyFkOD9oDooYmhhUcDRx+qCBrS4xIjoUnzggYWiK2KEOJKW7oIYml0QhkjTvmiOMORVLIoo0+DskfikiGeBc2TyrpmpRQWklllK1s6eSVXB7UZZZYVvnllGSGeSaYapqpJZptisbmmOvkJ2edZXrppp3F2LLmCHr2KeadNob2JpJ/xilomojmmWiheAKq6KOLQupooIxeSumhkm5qaaZ30tkoluZpSiWGkSblKaZR1UPpgpyeCutaCfE5aZC23oprrrruymuvvv4KbLDCDktsscYei2yyyicuy2yzzj4LbbTSTktttdZei2222m7LbbfefnuFjuCOe5645J6bXQEAIfkEBQQAAQAsDACiAQIAAgAAAgKEUQAh+QQFBAABACwSAJ0BBwAKAAACDgxuB5Hd+FZkUEE2nWUFACH5BAUEAAEALB4AogECAAIAAAIChFEAIfkEBQgAAQAsJwCiAQIAAgAAAgKEUQAh+QQFBAABACwwAJ0BFAAHAAACF4wfoIDtqJ5cUbZa7cHs5dR9BnVFolIAACH5BAUIAAEALEsAogECAAIAAAIChFEAIfkEBQQAAQAsUwCaAQwACgAAAhQMEKl76/8OgqlRM6nVGW4mfRVQAAAh+QQFCQABACxmAKIBAgACAAACAoRRACH5BAUEAAEALG8AogECAAIAAAIChFEAIfkEBQgAAQAseACdARQABwAAAhmMDxCp529SbBDKRau7V+/WfQ+XYSE2jUABACH5BAUEAAEALJMAogECAAIAAAIChFEAIfkEBQQAAQAsnACiAQIAAgAAAgKEUQAh+QQFCQABACylAKIBAgACAAACAoRRACH5BAUEAAEALK4AogECAAIAAAIChFEAIfkEBQQAAQAstwCiAQIAAgAAAgKEUQAh+QQFBAABACzAAKIBAgACAAACAoRRACH5BAUEAAEALMgAmgEMAAoAAAIUDBCperfb0EtxMmkNti57uF0aBxQAIfkEBQkAAQAs2wCiAQIAAgAAAgKEUQAh+QQFBAABACzkAKIBAgACAAACAoRRACH5BAUEAAEALO0AogECAAIAAAIChFEAIfkEBQQAAQAs9gCiAQIAAgAAAgKEUQAh+QQFCQABACz/AKIBAgACAAACAoRRACH5BAUEAAEALAgBogECAAIAAAIChFEAIfkEBQQAAQAsEQGiAQIAAgAAAgKEUQAh+QQFBAABACwaAaIBAgACAAACAoRRACH5BAUIAAEALCMBogECAAIAAAIChFEAIfkEBQQAAQAsLAGiAQIAAgAAAgKEUQAh+QQFBAABACw1AaIBAgACAAACAoRRACH5BAUEAAEALD4BogECAAIAAAIChFEAIfkEBQkAAQAsRwGiAQIAAgAAAgKEUQAh+QQFBAABACxQAaIBAgACAAACAoRRACH5BAUEAAEALFkBogECAAIAAAIChFEAIfkEBQQAAQAsYgGiAQIAAgAAAgKEUQAh+QQFBAABACxrAaIBAgACAAACAoRRACH5BAUIAAEALHQBogECAAIAAAIChFEAIfkEBQQAAQAsfQGiAQIAAgAAAgKEUQAh+QQFBAABACyGAaIBAgACAAACAoRRACH5BAUJAAEALI8BogECAAIAAAIChFEAIfkEBQkAAQAsmAGiAQsAAgAAAgYEghlmmlYAIfkEBQQAAQAsqgGiAQIAAgAAAgKEUQAh+QQFBAABACyzAaIBAgACAAACAoRRACH5BAUJAAEALLwBogECAAIAAAIChFEAIfkEBQQAAQAsxQGiAQIAAgAAAgKEUQAh+QQFCQABACzOAaIBCwACAAACBgSCGWaaVgAh+QQFBAABACzgAaIBAgACAAACAoRRACH5BAUJAAEALOkBogECAAIAAAIChFEAIfkEBQQAAQAs8gGiAQIAAgAAAgKEUQAh+QQFCQABACz7AaIBCwACAAACBgSCGWaaVgAh+QQFBAABACwNAqIBAgACAAACAoRRACH5BAUEAAEALBYCogECAAIAAAIChFEAIfkEBQgAAQAsHwKiAQIAAgAAAgKEUQAh+QQFBAABACwoAqIBAgACAAACAoRRACH5BAUEAAEALDECogECAAIAAAIChFEAIfkEBQQAAQAsOgKiAQIAAgAAAgKEUQAh+QQFCQABACxDAqIBAgACAAACAoRRACH5BAUEAAEALEwCogECAAIAAAIChFEAIfkEBQQAAQAsVQKiAQIAAgAAAgKEUQAh+QQFBAABACxeAqIBAgACAAACAoRRACH5BAUEAAEALGcCogECAAIAAAIChFEAIfkEBQkAAQAscAKiAQIAAgAAAgKEUQAh+QQFBAABACx5AqIBAgACAAACAoRRACH5BAUEAAEALIICogECAAIAAAIChFEAIfkEBQQAAQAsiwKiAQIAAgAAAgKEUQAh+QQFCQABACyUAqIBAgACAAACAoRRACH5BAUEAAEALJ0CogECAAIAAAIChFEAIfkEBQQAAQAspgKiAQIAAgAAAgKEUQAh+QQFBAABACyvAqIBAgACAAACAoRRACH5BAUJAAEALLgCogECAAIAAAIChFEAOw==" alt="QEMU 显示 &quot;.....H...e...l...l..o..... ...a..g..a....i...n...!&quot;"></p> <p>然而，QEMU 的 CPU 利用率依然没有得到改善。原因是我们依然全时段保持 CPU 繁忙。我们在任务被再次唤醒前轮不再询任务，但是我们依然在紧凑的循环里面检查 <code>task_queue</code>。为了解决这个问题，没有活需要弄的时候我们需要把 CPU 置为睡眠状态。</p> <h4 id="空闲时睡眠"><a href="#空闲时睡眠" class="header-anchor">#</a> 空闲时睡眠</h4> <p>基本思路是 <code>task_queue</code> 为空时执行 <a href="https://en.wikipedia.org/wiki/HLT_(x86_instruction)" target="_blank" rel="noopener noreferrer"><code>hlt</code> 指令<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。这个指令把 CPU 置为睡眠状态直至下一此中断到来。中断时 CPU 再次变得活跃确保我们依然能够在中断处理函数往 <code>task_queue</code> 添加东西时作出响应。</p> <p>为了实现这一点，我们为执行器添加一个新的 <code>sleep_if_idle</code> 方法，并在 <code>run</code> 方法中调用它：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">impl</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
        <span class="token keyword">loop</span> <span class="token punctuation">{</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">run_ready_tasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">sleep_if_idle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// new</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">sleep_if_idle</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>task_queue<span class="token punctuation">.</span><span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token namespace">x86_64<span class="token punctuation">::</span>instructions<span class="token punctuation">::</span></span><span class="token function">hlt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>由于我们在 <code>run_ready_tasks</code> 后面直接调用 <code>sleep_if_idle</code>，<code>run_ready_tasks</code> 会一直循环直至 <code>task_queue</code> 变空，再次检查队列是否为空可能看起来没有必要。然而，硬件中断可以在 <code>run_ready_tasks</code> 返回后刚好出现，所以 <code>sleep_if_idle</code> 函数调用时队列里面可能有新人物。只有这时队列依然为空时，我们借助 <a href="https://docs.rs/x86_64/0.12.1/x86_64/index.html" target="_blank" rel="noopener noreferrer"><code>x86_64</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包提供的 <a href="https://docs.rs/x86_64/0.12.1/x86_64/instructions/fn.hlt.html" target="_blank" rel="noopener noreferrer"><code>instructions::hlt</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包装函数执行 <code>hlt</code> 指令把 CPU 置为睡眠状态。</p> <p>不幸的是，这份实现还有一个隐秘的竞争状态。由于中断值异步的，可能在任何时候触发，所以在 <code>is_empty</code> 检查和 <code>hlt</code> 调用之间触发中断也是可能得：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>task_queue<span class="token punctuation">.</span><span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/// &lt;--- interrupt can happen here</span>
    <span class="token namespace">x86_64<span class="token punctuation">::</span>instructions<span class="token punctuation">::</span></span><span class="token function">hlt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这种情况下，中断会往 <code>task_queue</code> 添加值，即使有了就绪的任务我们依然把 CPU 置为了睡眠状态。最坏情况下，这会延迟键盘中断的处理直至下一次按键或者时钟中断。所以我们要如何避免这种情况呢？</p> <p>答案是在检查之前禁用 CPU 中断，并原子性地再次将其和 <code>hlt</code> 指令一起启用。这样，所有在中间发生的中断都会延迟到 <code>hlt</code> 指令之后，所以不会漏过任何唤醒。为了实现这种方法，我们可以使用 <a href="https://docs.rs/x86_64/0.12.1/x86_64/index.html" target="_blank" rel="noopener noreferrer"><code>x86_64</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包提供的 <a href="https://docs.rs/x86_64/0.12.1/x86_64/instructions/interrupts/fn.enable_interrupts_and_hlt.html" target="_blank" rel="noopener noreferrer"><code>enable_interrupts_and_hlt</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>  函数。这个函数从 0.9.6 版本才开始有，所以我们可能需要更新 <code>x86_64</code> 依赖的版本才能用上。</p> <p>更新的 <code>sleep_if_idle</code> 函数实现如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/task/executor.rs</span>

<span class="token keyword">impl</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">sleep_if_idle</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span>instructions<span class="token punctuation">::</span>interrupts<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token keyword">self</span><span class="token punctuation">,</span> enable_interrupts_and_hlt<span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token namespace">interrupts<span class="token punctuation">::</span></span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span>task_queue<span class="token punctuation">.</span><span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">enable_interrupts_and_hlt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token namespace">interrupts<span class="token punctuation">::</span></span><span class="token function">enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>为了避免竞争状态，我们检查 <code>task_queue</code> 是否为空之前禁用中断。如果已空，则调用 <a href="https://docs.rs/x86_64/0.12.1/x86_64/instructions/interrupts/fn.enable_interrupts_and_hlt.html" target="_blank" rel="noopener noreferrer"><code>enable_interrupts_and_hlt</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数在一个原子操作内启用中断并把 CPU 置为睡眠状态。如果队列非空了，这意味着 <code>run_ready_tasks</code> 返回后中断唤醒了一个任务。这种情况下，我们再次启用中断，并直接继续执行而不执行 <code>hlt</code>。</p> <p>现在没活干时，执行器正确地把 CPU 置为睡眠状态。再次执行 <code>cargo run</code> 启动内核可以看到 QEMU 进程的 CPU 占用率也低很多了。</p> <h4 id="可能的拓展"><a href="#可能的拓展" class="header-anchor">#</a> 可能的拓展</h4> <p>我们的执行器现在能够高效地运行任务。它利用唤醒器的通知功能避免轮询等待任务，并在当前没活干时把 CPU 置为睡眠状态。然而，这个执行器还非常基础，还有很多可能得方法能拓展它的功能：</p> <ul><li><strong>调度</strong>：现在的 <code>task_queue</code> 基于 <a href="https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html" target="_blank" rel="noopener noreferrer"><code>VecDeque</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型实现 <em>先进先出</em>（FIFO）策略，这通常称为 <em>轮询式</em> 调度。这种策略可不是对所有工作类型都是最优的。例如，优先处理时延要求高的任务或者 I/O 操作多的任务可能是比较合理的。更多详情参见 <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener noreferrer"><em>Operating Systems: Three Easy Pieces</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一书的 <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf" target="_blank" rel="noopener noreferrer">调度章节<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或 <a href="https://en.wikipedia.org/wiki/Scheduling_(computing)" target="_blank" rel="noopener noreferrer">维基百科关于调度的文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><strong>任务创建</strong>：<code>Executor::spawn</code> 方法现在要求一个 <code>&amp;mut self</code> 引用，因此执行 <code>run</code> 方法后就不再可用。为了解决这个问题，我们可以另外创建一个 <code>Spawner</code> 类型，和执行器共享某种队列，运行在任务内部创建新任务。这个队列可以直接是 <code>task_queue</code> 或者执行器会在循环内部检查的一个独立队列</li> <li><strong>利用线程</strong>：我们还没有支持线程，但是下一篇文章会添加。这会使得在不同线程启动多个执行器实例成为可能。这种方法的优势是因为其他任务可以并发地执行，所以长期任务带来的延时可以被降低。这种方法也允许使用多个 CPU 内核</li> <li><strong>负载均衡</strong>：添加线程支持后，如何在执行器之间分发任务使得所有 CPU 内核得到应用就变得重要了。一个常见的技巧是 <a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="noopener noreferrer"><em>工作量窃取</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>我们开篇从 <strong>多任务</strong> 讲起，区分定期强制中断任务的 <em>抢占式</em> 多任务和允许任意一直运行直到它们自愿放弃 CPU 控制权的 <em>合作式</em> 多任务。</p> <p>然后研究 Rust 支持的 <strong>async/await</strong> 是如何提供语言级别的合作式多任务的实现的。Rust 的实现基于轮询式的 <code>Future</code> trait，抽象了异步任务。async/await 使得我们可以想常规同步代码那样使用 future。不同点在于异步函数会再次返回一个 <code>Future</code>，为了执行它需要将其添加到一个执行器。</p> <p>内地里，编译器把 async/await 代码转换为 <em>状态机</em>，其中每个 <code>.await</code> 操作对应一个暂停点。基于对程序的认识，编译器能够只保存每个暂停点最少的状态，使得每个任务消耗非常小的内存。一个难点是生成的状态机可能会包含 <em>自引用</em> 结构体，例如异步函数的局部变量互相引用。为了防止指针无效化，Rust 使用 <code>Pin</code> 类型来确保 future 第一次轮询之后就不能再在内存里移动。</p> <p>对于 <strong>实现</strong>，我们首先创建一个非常基础的执行器，在一个紧凑的循环里面轮询所有创建的任务，且没有使用任何 TODO 类型。然后借助实现一份异步键盘任务展示唤醒器通知的优势。任务基于 <code>crossbeam</code> 包提供的无锁类型 <code>ArrayQueue</code> 定义一个静态变量 <code>SCANCODE_QUEUE</code>。与其直接处理按键，键盘中断处理函数现在吧所有接收到的扫描码放到队列，然后唤醒注册的 <code>Waker</code> 来提示新输入到来了。在接收端，我们创建一个 <code>ScancodeStream</code> 类型来提供会产出队列下一个扫描码的 <code>Future</code>。这使得创建异步的 <code>print_keypresses</code> 任务成为可能--利用 async/await 翻译并打印队列中的扫描码。</p> <p>为了利用键盘任务的唤醒器通知功能，我们创建一个新的 <code>Executor</code> 类型，使用 <code>Arc</code> 包装的 <code>task_queue</code> 存储就绪的任务。我们实现了一个 <code>TaskWaker</code> 类型，把唤醒的任务直接添加到 <code>task_queue</code>，然后任务会被执行器再次轮询。为了在没有运行任务时节省电量，我们使用 <code>hlt</code> 指令将 CPU 置为睡眠状态。最后，我们还讨论了执行器的可能拓展，例如提供多核支持。</p> <h2 id="下篇预告"><a href="#下篇预告" class="header-anchor">#</a> 下篇预告</h2> <p>借助 async/await，我们的内核基本支持了合作式多任务。虽然合作式多任务非常高效，但是单个任务一直运行很长时间会阻止其他任务执行，从而导致延时问题。因此，为我们的内核添加抢占式多任务支持也是合理的。</p> <p>下篇文章，我们将会介绍 <em>线程</em> 作为抢占式多任务最常见的形式。另外处理长期任务带来的问题，线程还让我们准备好将来利用多个 CPU 内核和运行不可行的用户程序。</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">4/18/2021, 1:52:33 AM</span></div></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#多任务" class="sidebar-link reco-side-多任务" data-v-70334359>多任务</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#抢占式多任务" class="sidebar-link reco-side-抢占式多任务" data-v-70334359>抢占式多任务</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#合作式多任务" class="sidebar-link reco-side-合作式多任务" data-v-70334359>合作式多任务</a></li><li class="level-2" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#rust-的-async-await" class="sidebar-link reco-side-rust-的-async-await" data-v-70334359>Rust 的 Async/Await</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#特性" class="sidebar-link reco-side-特性" data-v-70334359>特性</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#使用-futures" class="sidebar-link reco-side-使用-futures" data-v-70334359>使用 Futures</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#async-await-模式" class="sidebar-link reco-side-async-await-模式" data-v-70334359>Async/Await 模式</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#pinning" class="sidebar-link reco-side-pinning" data-v-70334359>Pinning</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#执行器和唤醒器" class="sidebar-link reco-side-执行器和唤醒器" data-v-70334359>执行器和唤醒器</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#合作式多任务-2" class="sidebar-link reco-side-合作式多任务-2" data-v-70334359>合作式多任务？</a></li><li class="level-2" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#实现" class="sidebar-link reco-side-实现" data-v-70334359>实现</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#任务" class="sidebar-link reco-side-任务" data-v-70334359>任务</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#简易执行器" class="sidebar-link reco-side-简易执行器" data-v-70334359>简易执行器</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#异步键盘输入" class="sidebar-link reco-side-异步键盘输入" data-v-70334359>异步键盘输入</a></li><li class="level-3" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#支持-waker-的执行器" class="sidebar-link reco-side-支持-waker-的执行器" data-v-70334359>支持 waker 的执行器</a></li><li class="level-2" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#总结" class="sidebar-link reco-side-总结" data-v-70334359>总结</a></li><li class="level-2" data-v-70334359><a href="/_post/blog-os/blog-os-12-async-await/#下篇预告" class="sidebar-link reco-side-下篇预告" data-v-70334359>下篇预告</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.460084d6.js" defer></script><script src="/assets/js/3.df7e20a8.js" defer></script><script src="/assets/js/1.7ac9a612.js" defer></script><script src="/assets/js/18.1dfec45f.js" defer></script>
  </body>
</html>
