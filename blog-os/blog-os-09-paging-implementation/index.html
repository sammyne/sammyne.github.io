<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>[blog os] 09. 分页实现 | sammyne</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="Just playing around :)">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.00c90c45.css" as="style"><link rel="preload" href="/assets/js/app.2124bf24.js" as="script"><link rel="preload" href="/assets/js/3.944fac0d.js" as="script"><link rel="preload" href="/assets/js/1.c30a1333.js" as="script"><link rel="preload" href="/assets/js/4.908240c5.js" as="script"><link rel="prefetch" href="/assets/js/10.6feb556b.js"><link rel="prefetch" href="/assets/js/11.d238b802.js"><link rel="prefetch" href="/assets/js/12.92a89c73.js"><link rel="prefetch" href="/assets/js/13.05851956.js"><link rel="prefetch" href="/assets/js/14.34744b6c.js"><link rel="prefetch" href="/assets/js/15.fd1f282f.js"><link rel="prefetch" href="/assets/js/16.338c7efe.js"><link rel="prefetch" href="/assets/js/17.dd7e0805.js"><link rel="prefetch" href="/assets/js/18.7e4af78d.js"><link rel="prefetch" href="/assets/js/19.96894619.js"><link rel="prefetch" href="/assets/js/20.3d3adc8f.js"><link rel="prefetch" href="/assets/js/21.669510d2.js"><link rel="prefetch" href="/assets/js/22.4997fa99.js"><link rel="prefetch" href="/assets/js/23.88d0f3d2.js"><link rel="prefetch" href="/assets/js/24.688b92a8.js"><link rel="prefetch" href="/assets/js/25.42a3079a.js"><link rel="prefetch" href="/assets/js/26.6b1973cc.js"><link rel="prefetch" href="/assets/js/27.e2133f18.js"><link rel="prefetch" href="/assets/js/28.4850156d.js"><link rel="prefetch" href="/assets/js/29.f6cf5316.js"><link rel="prefetch" href="/assets/js/30.824ebab1.js"><link rel="prefetch" href="/assets/js/31.d5cda852.js"><link rel="prefetch" href="/assets/js/32.5d223b08.js"><link rel="prefetch" href="/assets/js/33.9c398239.js"><link rel="prefetch" href="/assets/js/34.1cfaa2c4.js"><link rel="prefetch" href="/assets/js/35.69f5a7fc.js"><link rel="prefetch" href="/assets/js/36.a3ad36a5.js"><link rel="prefetch" href="/assets/js/37.71d0640c.js"><link rel="prefetch" href="/assets/js/38.8e4b00cc.js"><link rel="prefetch" href="/assets/js/39.ff2dfcd8.js"><link rel="prefetch" href="/assets/js/40.3262bce0.js"><link rel="prefetch" href="/assets/js/41.5eb1f517.js"><link rel="prefetch" href="/assets/js/42.efbc331e.js"><link rel="prefetch" href="/assets/js/43.d10817f1.js"><link rel="prefetch" href="/assets/js/44.5f29d6a5.js"><link rel="prefetch" href="/assets/js/45.19bf538d.js"><link rel="prefetch" href="/assets/js/46.caa3e673.js"><link rel="prefetch" href="/assets/js/47.02d2bfdd.js"><link rel="prefetch" href="/assets/js/48.8f6cdcc5.js"><link rel="prefetch" href="/assets/js/49.8874e137.js"><link rel="prefetch" href="/assets/js/5.6b0f5eca.js"><link rel="prefetch" href="/assets/js/50.c2d9cf07.js"><link rel="prefetch" href="/assets/js/51.83db0769.js"><link rel="prefetch" href="/assets/js/52.f81f5392.js"><link rel="prefetch" href="/assets/js/53.b04b70d0.js"><link rel="prefetch" href="/assets/js/54.07971080.js"><link rel="prefetch" href="/assets/js/55.674ca41a.js"><link rel="prefetch" href="/assets/js/56.862cae6b.js"><link rel="prefetch" href="/assets/js/57.3d3d7cc9.js"><link rel="prefetch" href="/assets/js/58.98ebbb9c.js"><link rel="prefetch" href="/assets/js/59.4081edac.js"><link rel="prefetch" href="/assets/js/6.81d9e9a0.js"><link rel="prefetch" href="/assets/js/60.42a820f4.js"><link rel="prefetch" href="/assets/js/61.a52bc06d.js"><link rel="prefetch" href="/assets/js/62.18da62d1.js"><link rel="prefetch" href="/assets/js/63.52f6533c.js"><link rel="prefetch" href="/assets/js/64.03c12890.js"><link rel="prefetch" href="/assets/js/65.ccfd6c32.js"><link rel="prefetch" href="/assets/js/66.a0c38aa4.js"><link rel="prefetch" href="/assets/js/67.a30f375b.js"><link rel="prefetch" href="/assets/js/68.8248dd23.js"><link rel="prefetch" href="/assets/js/69.123686ed.js"><link rel="prefetch" href="/assets/js/7.18067abc.js"><link rel="prefetch" href="/assets/js/70.a647f8ad.js"><link rel="prefetch" href="/assets/js/71.02a394bf.js"><link rel="prefetch" href="/assets/js/72.2b1e35e2.js"><link rel="prefetch" href="/assets/js/73.afa2fc7a.js"><link rel="prefetch" href="/assets/js/74.7a30b68a.js"><link rel="prefetch" href="/assets/js/75.cddbdc6c.js"><link rel="prefetch" href="/assets/js/76.7b929319.js"><link rel="prefetch" href="/assets/js/77.87e8820d.js"><link rel="prefetch" href="/assets/js/78.c68f804b.js"><link rel="prefetch" href="/assets/js/79.8b9d1881.js"><link rel="prefetch" href="/assets/js/8.8be62fa8.js"><link rel="prefetch" href="/assets/js/80.e0641939.js"><link rel="prefetch" href="/assets/js/81.2bf032f3.js"><link rel="prefetch" href="/assets/js/82.fc2e2dc0.js"><link rel="prefetch" href="/assets/js/83.eab5c475.js"><link rel="prefetch" href="/assets/js/84.48d98958.js"><link rel="prefetch" href="/assets/js/85.17986848.js"><link rel="prefetch" href="/assets/js/86.32c9a409.js"><link rel="prefetch" href="/assets/js/87.28193f1a.js"><link rel="prefetch" href="/assets/js/88.7ef5e0f3.js"><link rel="prefetch" href="/assets/js/89.e3126a19.js"><link rel="prefetch" href="/assets/js/9.49555849.js"><link rel="prefetch" href="/assets/js/90.569bbf88.js">
    <link rel="stylesheet" href="/assets/css/0.styles.00c90c45.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>sammyne</h3> <p class="description" data-v-59e6cb88>Just playing around :)</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>sammyne</span>
          
        <span data-v-59e6cb88>2020 - </span>
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.svg" alt="sammyne" class="logo"> <span class="site-name">sammyne</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/os/" class="nav-link"><i class="undefined"></i>
  os
</a></li><li class="dropdown-item"><!----> <a href="/categories/dev/" class="nav-link"><i class="undefined"></i>
  dev
</a></li><li class="dropdown-item"><!----> <a href="/categories/crypto/" class="nav-link"><i class="undefined"></i>
  crypto
</a></li><li class="dropdown-item"><!----> <a href="/categories/programming/" class="nav-link"><i class="undefined"></i>
  programming
</a></li><li class="dropdown-item"><!----> <a href="/categories/tee/" class="nav-link"><i class="undefined"></i>
  tee
</a></li><li class="dropdown-item"><!----> <a href="/categories/engineering/" class="nav-link"><i class="undefined"></i>
  engineering
</a></li><li class="dropdown-item"><!----> <a href="/categories/language/" class="nav-link"><i class="undefined"></i>
  language
</a></li><li class="dropdown-item"><!----> <a href="/categories/tool/" class="nav-link"><i class="undefined"></i>
  tool
</a></li><li class="dropdown-item"><!----> <a href="/categories/architecture/" class="nav-link"><i class="undefined"></i>
  architecture
</a></li><li class="dropdown-item"><!----> <a href="/categories/decentralization/" class="nav-link"><i class="undefined"></i>
  decentralization
</a></li><li class="dropdown-item"><!----> <a href="/categories/network/" class="nav-link"><i class="undefined"></i>
  network
</a></li><li class="dropdown-item"><!----> <a href="/categories/software engineering/" class="nav-link"><i class="undefined"></i>
  software engineering
</a></li><li class="dropdown-item"><!----> <a href="/categories/notes/" class="nav-link"><i class="undefined"></i>
  notes
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://github.com/sammyne" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    sammyne
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>80</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>43</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/os/" class="nav-link"><i class="undefined"></i>
  os
</a></li><li class="dropdown-item"><!----> <a href="/categories/dev/" class="nav-link"><i class="undefined"></i>
  dev
</a></li><li class="dropdown-item"><!----> <a href="/categories/crypto/" class="nav-link"><i class="undefined"></i>
  crypto
</a></li><li class="dropdown-item"><!----> <a href="/categories/programming/" class="nav-link"><i class="undefined"></i>
  programming
</a></li><li class="dropdown-item"><!----> <a href="/categories/tee/" class="nav-link"><i class="undefined"></i>
  tee
</a></li><li class="dropdown-item"><!----> <a href="/categories/engineering/" class="nav-link"><i class="undefined"></i>
  engineering
</a></li><li class="dropdown-item"><!----> <a href="/categories/language/" class="nav-link"><i class="undefined"></i>
  language
</a></li><li class="dropdown-item"><!----> <a href="/categories/tool/" class="nav-link"><i class="undefined"></i>
  tool
</a></li><li class="dropdown-item"><!----> <a href="/categories/architecture/" class="nav-link"><i class="undefined"></i>
  architecture
</a></li><li class="dropdown-item"><!----> <a href="/categories/decentralization/" class="nav-link"><i class="undefined"></i>
  decentralization
</a></li><li class="dropdown-item"><!----> <a href="/categories/network/" class="nav-link"><i class="undefined"></i>
  network
</a></li><li class="dropdown-item"><!----> <a href="/categories/software engineering/" class="nav-link"><i class="undefined"></i>
  software engineering
</a></li><li class="dropdown-item"><!----> <a href="/categories/notes/" class="nav-link"><i class="undefined"></i>
  notes
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://github.com/sammyne" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>[blog os] 09. 分页实现</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>sammyne</span>
          
        <span data-v-59e6cb88>2020 - </span>
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">[blog os] 09. 分页实现</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>sammyne</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>7/18/2020</span></i> <i class="iconfont reco-eye" data-v-8a445198><span id="/blog-os/blog-os-09-paging-implementation/" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-8a445198><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>blog_os</span><span class="tag-item" data-v-8a445198>rust</span></i></div></div> <div class="theme-reco-content content__default"><blockquote><p>原文：<a href="https://os.phil-opp.com/paging-implementation/" target="_blank" rel="noopener noreferrer">Paging Implementation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>本文讲解如何为我们的内核实现分页。文章会先探究使得物理页表能够被内核访问的不同方法，讨论它们各自的优劣，然后实现一个地址转换函数和一个创建新映射的函数。</p> <p>此博客在 <a href="https://github.com/phil-opp/blog_os" target="_blank" rel="noopener noreferrer">GitHub<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 上公开开发。如果您有任何问题或疑问，请在那边打开一个 issue。 您也可以在 <a href="#valine">底部</a> 发表评论。这篇文章的完整源代码可以在 <a href="https://github.com/sammyne/blog-os-cn/tree/master/09-paging-implementation" target="_blank" rel="noopener noreferrer">blog-os-cn/09-paging-implementation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 找到。</p> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <p><a href="/2020/07/19/blog-os-08-intro-to-paging/">上一篇文章</a> 介绍了分页的概念。它通过对比分段引出分页的思想，解释分页和页表是如何工作的，还介绍了 <code>x86_64</code> 结构的 4 级页表结构。我们发现引导器已经为我们的内核设置好了页表层级，这也就意味着内核已经在虚拟地址上运行。因为非法内存访问会触发缺页异常而不是随意更改物理内存，所以这样做能够提高安全性。</p> <p>因为页表已经存储在物理内存外加我们的内核运行在虚拟地址上，上篇文章结尾抛出了我们 <a href="/2020/07/19/blog-os-08-intro-to-paging/#访问页表">无法在自己的内核访问页表</a> 的问题。本文延续这个话题，探寻使得页帧能够被内核访问的不同方式。我们将会讨论每种方法的优劣，然后为我们的内核选定一种方法。</p> <p>为了实现这些方法，我们需要引导器的支持，所以得首先配置好它。之后，我们将会实现一个遍历页表层级来将虚拟地址翻译为物理地址的函数。最后，我们学习如何在页表中创建新的映射和如何找到空闲的内存帧来创建页表。</p> <h2 id="访问页表"><a href="#访问页表" class="header-anchor">#</a> 访问页表</h2> <p>在内核中访问页表没有看起来那么容易。为了解释这个问题，让我们首先回看一下上一篇文章展示的 4 级页表层级示例：</p> <p><img src="/assets/img/x86_64-page-table-translation.9c85e8a1.svg" alt="4 级页表层级结构，其中每级页表均位于物理内存"></p> <p>重要的是：每个页表项存储这下一个表的 <em>物理</em> 地址。这样做消除转换这些地址的需要，否则这些转换将会损害性能和容易会导致无尽的转换循环。</p> <p>现有问题是内核运行在虚拟地址之上，我们无法在内核中直接访问物理地址。举个例子说，想要访问地址 <code>4 KiB</code> 时，我们访问到的是<em>虚拟</em>地址 <code>4 KiB</code>，而不是存储第 4 级页表的 <em>物理</em> 地址 <code>4 KiB</code>。当我们想要访问物理地址 <code>4 KiB</code> 时，只能借助映射到这个地址的某个虚拟地址。</p> <p>因此，为了访问页表帧，我们需要将一些虚拟页映射到它们。有不同方式可以创建这些映射，这些方式都允许我们访问任意页表帧。</p> <h3 id="一一映射"><a href="#一一映射" class="header-anchor">#</a> 一一映射</h3> <p>一个简单的方式 <strong>一一映射所有页表</strong>。</p> <p><img src="/assets/img/identity-mapped-page-tables.8f381391.svg" alt="一个虚拟和物理地址空间，空间中多个虚拟页面映射到同样地址的物理帧"></p> <p>这个示例中，我们看到多个一一映射的页表帧。这种方式下，每个页表的物理地址也是合法的虚拟地址，使得我们能够轻易访问从 CR3 寄存器开始的所有层级的页表。</p> <p>然而，这种方法在虚拟空间中堆放页表，让搜索更大的连续内存区域变得更加困难了。例如，假如我们想要在上图所示内存布局中为 <a href="https://en.wikipedia.org/wiki/Memory-mapped_file" target="_blank" rel="noopener noreferrer">内存映射文件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 创建一个大小为 1000 KiB 的虚拟内存区域。如果从 <code>28 KiB</code> 的区域开始分配，我们将会冲掉位于 <code>1004 KiB</code> 的已经映射的页面。所以，我们需要一直搜索直至找到一个足够大的尚未映射的区域，例如从 <code>1008 KiB</code> 开始的区域。这是一个类似 <a href="/2020/07/19/blog-os-08-intro-to-paging/#碎片化">分段</a> 带来碎片化的问题。</p> <p>换句话说，这种方法很大程度上加大创建新页表的困难程度，因为我们需要找到尚未被征用的物理页帧对应的页面。例如，假如我们为内存映射文件从 <code>1008 KiB</code> 开始预留 1000 KiB <em>虚拟</em> 内存区域。这样一来，由于无法对其应用一一映射规则，我们就无法使用地址在 <code>1000 KiB</code> 到 <code>2008 KiB</code> 之间的所有 <em>物理</em> 地址。</p> <h3 id="从固定偏移量开始映射"><a href="#从固定偏移量开始映射" class="header-anchor">#</a> 从固定偏移量开始映射</h3> <p>为了规避扰乱虚拟地址空间的问题，我们可以 <strong>使用独立的内存区域实现页表映射</strong>。所以我们将从虚拟地址空间的固定偏移开始映射页面，而不是一一映射到页表帧。例如，这个偏移量可以是 10 TiB：</p> <p><img src="/assets/img/page-tables-mapped-at-offset.f4ac8a5e.svg" alt="和一一映射相同的图，但是每个被映射的虚拟页面都偏移了 10 TiB"></p> <p>这个范围在 <code>10TiB..(10TiB + 物理内存大小)</code> 虚拟内存专用于页表映射，解决了一一映射方法的冲突问题。预留如此大的虚拟内存空间只有在虚拟地址空间远大于物理内存大小时才有可能。由于 48-bit 的地址空间大小为 256 TiB，因此对 x86_64 结构来说不是问题。</p> <p>这种方式仍然具有一个缺点--创建新页表时需要创建新的映射。同时，它还不允许访问其他地址空间的页表（跨地址空间访问页表对于创建新进程很有用）。（@TODO：为什么不允许访问其他地址空间的页表）</p> <h3 id="映射完整的物理内存"><a href="#映射完整的物理内存" class="header-anchor">#</a> 映射完整的物理内存</h3> <p>我们可以通过 <strong>映射完整的物理内存</strong> 而不仅是页表帧来解决这个问题：</p> <p><img src="/assets/img/map-complete-physical-memory.c393cf7d.svg" alt="和偏移映射相同的图，但是除了页表帧以外，每个物理页帧都在 10TiB+X 有映射"></p> <p>这种方式允许我们的内核访问任意物理内存，包括其他地址空间的页表帧。预留的虚拟内存范围大小和之前一样，只是不再包含没有映射的页面了。</p> <p>这种方式的缺点是需要额外的页表来存储到物理内存的映射。这些页表需要保存在某个地方，因此需要占用部分物理内存，对于小内存的设备来说问题挺大。</p> <p>在 x86_64 架构上，我们可以使用 2MiB 的 <a href="https://en.wikipedia.org/wiki/Page_%28computer_memory%29#Multiple_page_sizes" target="_blank" rel="noopener noreferrer">巨大页<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 进行映射，而不是默认的 4KiB 的页面。这种方法下，由于只需要 1 个三级页表和 32 个二级页表，映射 32GiB 的物理内存只需消耗 132KiB 用于存储页表。因为 TLB（translation lookaside buffer）需要更少项，所以巨大页下的缓存使用效率也变高了。</p> <blockquote><p><strong>关于 132KiB 的计算</strong><br>
32GiB / 2MiB = 2^14 =&gt; 需要 2^14 个页表项<br>
x86_64 结构 64 位模式下，各级页表索引各占 9 比特，一级索引直接映射到页帧<br>
因此，采用一、二和三级页表即可，四级页表不用<br>
三级页表个数：1 = ceil(2^14/2^(9+9))<br>
二级页表个数：32 = ceil(2^14/2^9)<br>
页表索引总数为 33，每个页表项大小为 4KiB，总计需要内存 33*4KiB=132KiB</p></blockquote> <h3 id="临时映射"><a href="#临时映射" class="header-anchor">#</a> 临时映射</h3> <p>对于物理内存非常小的设备，我们可以在访问页表帧时 <strong>只临时映射页表帧</strong>。为了创建临时映射，我们只需要单个一一映射的一级表即可：</p> <p><img src="/assets/img/temporarily-mapped-page-tables.00a3ab5c.svg" alt="一个一一映射一级表关联虚拟和物理地址空间，其第 0 个表项映射到二级表帧，从而把那一帧映射到地址为 0 的页面"></p> <p>因为从 CR3 寄存器开始，沿着四级、三级和二级页表的第 0 项可以达到这个一级页表，所以图中的一级表控制这虚拟地址空间头部的 2 MiB（@TODO：如何计算）。下标为 <code>8</code> 的表项将地址为 <code>32 KiB</code> 的虚拟页面映射为地址为 <code>32 KiB</code> 的物理页帧，从而在一级表上实现一一映射。图中的 <code>32 KiB</code> 的水平箭头表示了这个一一映射。</p> <p>通过写入一一映射的一级表，我们的内核可以创建一个大小为 511 的临时映射（512减去用于一一映射的表项）。上述例子中，内核创建了两个临时映射：</p> <ul><li>将一级表的第 0 项映射到地址 <code>24 KiB</code>，它创建了地址为 <code>0 KiB</code> 的虚拟页面到二级页表的物理帧的临时映射，由图中虚箭头标识</li> <li>将一级表的第 9 项映射到地址为 <code>4 KiB</code> 的页帧，它创建了地址为 <code>36 KiB</code> 的虚拟页面到四级表的物理帧的临时映射，图中虚箭头标识</li></ul> <p>至此，内核就可以通过写入 <code>0 KiB</code> 所在页访问到二级表，写入 <code>36 KiB</code> 所在页访问到四级表。</p> <p>借助临时映射访问任意页表帧的流程为：</p> <ul><li>找到一个一一映射一级表的空闲项</li> <li>将表项映射为我们想要访问的页表物理帧中的表项</li> <li>通过映射到目标页帧的虚拟页面访问页表项</li> <li>将表项重新标识为空闲从而移除临时映射</li></ul> <p>这种方法复用同样的 512 个虚拟页面用于创建映射，因此只需 4KiB 物理内存（因为只需要一个页表项，每个页表项大小为 4KiB）。缺点是操作起来有点繁琐，尤其是当新的映射要求改变多级页表时，那时需要我们重复上述步骤多次。</p> <h3 id="递归式页表"><a href="#递归式页表" class="header-anchor">#</a> 递归式页表</h3> <p>还有一种有趣的方式，这种方式根本不需要额外的页表，具体姿势是 <strong>递归地映射页表</strong>。这种方式背后的思想是将四级页表的某些项映射到四级页表自身。借助这种方式，我们能够有效地预留虚拟地址空间一部分，将当前和将来的页表帧映射到这个空间。</p> <p>让我们看些例子来理解它是如何操作的：</p> <p><img src="/assets/img/recursive-page-table.779ee6d9.png" alt="一个四级页表结构示例，其中每个页表都显示在物理内存。第四级页表的第 511 项映射到位于 4KiB 的页帧，即第四级页表自身所在页帧"></p> <p>这个 <a href="#%E8%AE%BF%E9%97%AE%E9%A1%B5%E8%A1%A8">本文开头的示例</a> 仅有的不同是第四级页表索引为 <code>511</code> 的新加项映射到了位于 <code>4 KiB</code> 的物理帧，第四级页表所在物理帧。</p> <p>让 CPU 沿着这个表项继续执行转换，流程不会进入第三级页表，而是再次回到同级的四级页表。这和调用自身的递归函数类似，因此这个表被称为<em>递归页表</em>。重要的是 CPU 认为第四级页表的每个表项都是指向第三级页表的，所以现在 CPU 会把第四级页表看做第三级页表。因为 x86_64 架构下所有层级的页表结构都是一样的，所以这种操作是可行的。</p> <p>在开始真正的转换之前，沿着递归的表项执行一次或多次，我们可以有效地减少 CPU 遍历的层级数。例如，如果我们沿着递归表项走一次，然后前进到第三级页表，CPU 此时会把第三级页表看做第二级页表。继续往下，CPU 把第二级页表看做第一级页表，CPU 此时会把第一级页表看做被映射的页帧。这时，CPU 会把第一级页表看做映射到的页帧，也就意味着我们可以读写第一级页表了。</p> <p><img src="/assets/img/recursive-page-table-access-level-1.bdaac719.png" alt="上述例子用 5 个箭头演示四级页表层级：第 0 步从 CR4 到第四级页表，第 1 步从第四季页表到第四级页表，第 2 步从第四级页表到第三级页表，第 3 步从第三级页表到第二级页表，第 4 步从第二级页表到第一级页表"></p> <p>同理，我们可以开始转换前沿着递归的表项走两次，从而将遍历的层数减到 2：</p> <p><img src="/assets/img/recursive-page-table-access-level-2.7f4b9ac4.png" alt="上述例子用 4 个箭头演示四级页表层级：第 0 步从 CR4 到第四级页表，第 1 和 2 步从第四季页表到第四级页表，第 3 步从第四级页表到第三级页表，第 3 步从第三级页表到第二级页表"></p> <p>让我一步步分解：首先，CPU 沿着递归的第四级表项走一次，觉得自己已经到了第三级页表。然后，它沿着递归表项再走一次，自以为到了第二级页表。但事实上，它仍然在第四级页表。CPU 再沿着不同的表项往下时，它来到第三级页表，但自以为到了第一级页表。所以，虽然下一个表项落在第二级页表，但是 CPU 觉得这项已经指向了映射的页帧，从而允许我们读写第二级页表。</p> <p>访问页表的第三级和第四级的方式是一样的。为了到第三级页表，我们沿着递归表项走 3 次，骗 CPU 让它觉得已经到了第一级页表。然后，沿着另一个表项走到第三级页表，这个页表让 CPU 觉得已经到了被映射的页帧。为了访问第四级页表本身，我们只需要沿着递归的表项走四次，直到 CPU 把第四级页表看做被映射的页帧（下图中蓝色部分）。</p> <p><img src="/assets/img/recursive-page-table-access-level-3.487a8292.png" alt="上述例子用 3 个箭头演示四级页表层级：第 0 步从 CR4 到第四级页表，第 1 到 3 步从第四季页表到第四级页表，第 4 步从第四级页表到第三级页表"></p> <p>我们脑子理解这些概念可能有点绕，需要花点时间，但是这项操作在实践中是非常稳的。</p> <p>往后部分我们讲解如何基于递归表项一次或多次来构建虚拟地址。我们的实现不会采用递归式分页，所以我们跳过以下关于递归式分页的相关知识。如果感兴趣的话，点击<em>地址计算</em>即可展开。</p> <details class="custom-block details"><summary>地址计算</summary> <p>可以看到，我们可以在开始真正的转换前，一次或多次递归地访问页表所有层级的表项。由于四个层级的页表索引都是直接从虚拟地址推算的，我们需要为这种方法构造特殊的虚拟地址。如果没有忘记的话，页表索引应该是以下面这种方式推算的：</p> <p><img src="/assets/img/x86_64-table-indices-from-address.c4433c8f.svg" alt="0-12 位是页内偏移，12-21 是第一级索引，21-30 是二级索引，30-39 是三级索引，39-48 是四级索引"></p> <p>假设我们想要访问映射到特定页的第一级页表。由上可知，这意味着我们必须首先沿着递归表项走一次，然后再继续从第四级、第三级和第二级索引往下。为了这样做，我们将地址的每块右移一个块，将原先的第四级索引设置为递归项的索引：</p> <p><img src="/assets/img/table-indices-from-address-recursive-level-1.62ad82b5.svg" alt="0-12 位是第一级页表帧的页内偏移，12-21 是第二级索引，21-30 是三级索引，30-39 是四级索引，39-48 是递归表项的索引"></p> <p>为了访问那一页对应的第二级页表，我们将每个索引块右移两个块，将原先的第四级索引和原先的第三级索引设置为递归项的索引：</p> <p><img src="/assets/img/table-indices-from-address-recursive-level-2.1d9ae57c.svg" alt="0-12 位是第二级页表帧的页内偏移，12-21 位是第三级索引，21-30 位是四级索引，30-39 和 39-48 位是递归表项的索引"></p> <p>为了访问第三级页表，我们将每个索引块右移三个块，将原先的第四、三和二级索引都设置为递归项的索引：</p> <p><img src="/assets/img/table-indices-from-address-recursive-level-3.4b86eec9.svg" alt="0-12 位是第三级页表帧的页内偏移，12-21 位是第四级索引，21-30、30-39 和 39-48 位是递归表项的索引"></p> <p>最后访问第四级页表，我们将每个索引块右移四个块，将除页内偏移块以外的所有索引块都设置为递归项的索引：</p> <p><img src="/assets/img/table-indices-from-address-recursive-level-4.36b6b029.svg" alt="0-12 位是第四级页表帧的页内偏移，12-21、21-30、30-39 和 39-48 位是递归表项的索引"></p> <p>我们现在能够计算所有四个层级页表的虚拟地址。甚至还可以通过将索引值乘于 8（页表项的大小）计算指向特定页表项的地址（@TODO：更加详细的解释）。</p> <p>下表总结了访问不同类型页帧的地址结构：</p> <table><thead><tr><th>虚拟地址</th> <th>地址结构（<a href="https://en.wikipedia.org/wiki/Octal" target="_blank" rel="noopener noreferrer">八进制形式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</th></tr></thead> <tbody><tr><td>页帧</td> <td><code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code></td></tr> <tr><td>一级页表项</td> <td><code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code></td></tr> <tr><td>二级页表项</td> <td><code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code></td></tr> <tr><td>三级页表项</td> <td><code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code></td></tr> <tr><td>四级页表项</td> <td><code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code></td></tr></tbody></table> <p>对于映射到的页帧来说，<code>AAA</code> 是第四级索引，<code>BBB</code> 是第三级索引，<code>CCC</code> 是第二级索引，<code>DDD</code> 是第二级索引，<code>EEEE</code> 是页内偏移。<code>RRR</code> 是递归表项的索引。一个 3 位数的索引转化为 4 位数的偏移量是通过乘于 8（页表项的大小）来实现的。有了这个偏移量，所得地址直接指向各自的页表项。</p> <p><code>SSSSSS</code> 是符号延展位，即它们都是第 47 比特的副本。这时 x86_64 架构对合法地址的特殊要求。我们在 <a href="/2020/07/19/blog-os-08-intro-to-paging/#x86-64-架构的分页">之前的文章</a> 已经介绍过。</p> <p>因为每个八进制字符代表 3 个比特，使得我们可以清楚地隔离不同页表层级的 9 比特索引，所以我们用 <a href="https://en.wikipedia.org/wiki/Octal" target="_blank" rel="noopener noreferrer">八进制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 标识地址。十六进制下每个字符表示 4 比特，就不能实现清楚隔离了。</p> <h5 id="用-rust-代码实现"><a href="#用-rust-代码实现" class="header-anchor">#</a> 用 Rust 代码实现</h5> <p>为了用 Rust 代码构造这些地址，我们可以使用位运算：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// the virtual address whose corresponding page tables you want to access</span>
<span class="token keyword">let</span> addr<span class="token punctuation">:</span> <span class="token keyword">usize</span> <span class="token operator">=</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token number">0o777</span><span class="token punctuation">;</span> <span class="token comment">// recursive index</span>
<span class="token keyword">let</span> sign <span class="token operator">=</span> <span class="token number">0o177777</span> <span class="token operator">&lt;&lt;</span> <span class="token number">48</span><span class="token punctuation">;</span> <span class="token comment">// sign extension</span>

<span class="token comment">// retrieve the page table indices of the address that we want to translate</span>
<span class="token keyword">let</span> l4_idx <span class="token operator">=</span> <span class="token punctuation">(</span>addr <span class="token operator">&gt;&gt;</span> <span class="token number">39</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0o777</span><span class="token punctuation">;</span> <span class="token comment">// level 4 index</span>
<span class="token keyword">let</span> l3_idx <span class="token operator">=</span> <span class="token punctuation">(</span>addr <span class="token operator">&gt;&gt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0o777</span><span class="token punctuation">;</span> <span class="token comment">// level 3 index</span>
<span class="token keyword">let</span> l2_idx <span class="token operator">=</span> <span class="token punctuation">(</span>addr <span class="token operator">&gt;&gt;</span> <span class="token number">21</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0o777</span><span class="token punctuation">;</span> <span class="token comment">// level 2 index</span>
<span class="token keyword">let</span> l1_idx <span class="token operator">=</span> <span class="token punctuation">(</span>addr <span class="token operator">&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0o777</span><span class="token punctuation">;</span> <span class="token comment">// level 1 index</span>
<span class="token keyword">let</span> page_offset <span class="token operator">=</span> addr <span class="token operator">&amp;</span> <span class="token number">0o7777</span><span class="token punctuation">;</span>

<span class="token comment">// calculate the table addresses</span>
<span class="token keyword">let</span> level_4_table_addr <span class="token operator">=</span>
    sign <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">39</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">21</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> level_3_table_addr <span class="token operator">=</span>
    sign <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">39</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">21</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>l4_idx <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> level_2_table_addr <span class="token operator">=</span>
    sign <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">39</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>l4_idx <span class="token operator">&lt;&lt;</span> <span class="token number">21</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>l3_idx <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> level_1_table_addr <span class="token operator">=</span>
    sign <span class="token operator">|</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;&lt;</span> <span class="token number">39</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>l4_idx <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>l3_idx <span class="token operator">&lt;&lt;</span> <span class="token number">21</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>l2_idx <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>上述代码假设第四级页表的索引为 <code>0o777</code> 的最后一项被递归映射。我们当前情形不是这样的，所以代码还无法运行。如何指示引导器正确配置好递归映射请继续往下看。</p> <p>除了手动地执行位运算外，我们可以使用 <code>x86_64</code> 包的 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/struct.RecursivePageTable.html" target="_blank" rel="noopener noreferrer"><code>RecursivePageTable</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型，这个类型提供了多种页表运算的安全抽象。例如，以下代码演示了如何将虚拟地址转换为所映射的物理地址：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/memory.rs</span>

<span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span>structures<span class="token punctuation">::</span>paging<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Mapper</span><span class="token punctuation">,</span> <span class="token class-name">Page</span><span class="token punctuation">,</span> <span class="token class-name">PageTable</span><span class="token punctuation">,</span> <span class="token class-name">RecursivePageTable</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">VirtAddr</span><span class="token punctuation">,</span> <span class="token class-name">PhysAddr</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/// Creates a RecursivePageTable instance from the level 4 address.</span>
<span class="token keyword">let</span> level_4_table_addr <span class="token operator">=</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> level_4_table_ptr <span class="token operator">=</span> level_4_table_addr <span class="token keyword">as</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token class-name">PageTable</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> recursive_page_table <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> level_4_table <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token operator">*</span>level_4_table_ptr<span class="token punctuation">;</span>
    <span class="token class-name">RecursivePageTable</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>level_4_table<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/// Retrieve the physical address for the given virtual address</span>
<span class="token keyword">let</span> addr<span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token operator">=</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
<span class="token keyword">let</span> addr <span class="token operator">=</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> page<span class="token punctuation">:</span> <span class="token class-name">Page</span> <span class="token operator">=</span> <span class="token class-name">Page</span><span class="token punctuation">::</span><span class="token function">containing_address</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// perform the translation</span>
<span class="token keyword">let</span> frame <span class="token operator">=</span> recursive_page_table<span class="token punctuation">.</span><span class="token function">translate_page</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
frame<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>frame<span class="token closure-punctuation punctuation">|</span></span> frame<span class="token punctuation">.</span><span class="token function">start_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">u64</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>addr<span class="token punctuation">.</span><span class="token function">page_offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>再次声明，这份代码需要一个合法的递归映射，缺失的 <code>level_4_table_addr</code> 可以仿照第一份代码计算。</p></details> <p>递归分页是一个有趣的技巧，这种方法展示了页表的单个映射可以有多强大。它很容易实现，且仅需要很小配置即可（只是一个递归表项），所以是第一个分页实验很好的选择。</p> <p>然而， 它还有一些缺点</p> <ul><li>它占用这很大虚拟内存（512 GiB）。对 48 位的地址空间来说，这不是什么大问题，但是可能会触发次优的缓存行为</li> <li>它只允许方便地访问当前活跃的地址空间。虽然通过改变页表项也可以访问其他地址空间，但是需要借助一个临时映射来回切换。我们在一篇过时的文章 <a href="https://os.phil-opp.com/remap-the-kernel/#overview" target="_blank" rel="noopener noreferrer"><em>重新映射内核</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 有所描述。</li> <li>它严重依赖于 x86 架构的页表格式，可能在其他架构下无法工作</li></ul> <h2 id="引导器支持"><a href="#引导器支持" class="header-anchor">#</a> 引导器支持</h2> <p>以上所有方法都要求修改页表才能配置起来。例如，需要创建到物理内存的映射或第四级页表的某个页表项需要递归地映射。问题在于，不存在现有方式访问页表的情况下，我们无法创建这些要求的映射。</p> <p>这意味着，我们需要借助引导器的帮助，它创建我们内核运行所需的页表。引导器能够访问页表，所以它能够创建我们需要的任何映射。当前实现版本中，<code>bootloader</code> 包以上两种方式，通过 <a href="https://doc.rust-lang.org/cargo/reference/features.html#the-features-section" target="_blank" rel="noopener noreferrer">cargo 特性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 控制：</p> <ul><li><code>map_physical_memory</code> 特性将完整的物理内存映射到虚拟地址空间的某个位置。因此，内核可以访问所有物理内存，采用 <a href="#%E6%98%A0%E5%B0%84%E5%AE%8C%E6%95%B4%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><em>映射完整物理内存</em></a> 的方式。</li> <li>开启 <code>recursive_page_table</code> 特性，引导器将递归地映射第四级页表的某一项。这样允许内核按照 <a href="#%E9%80%92%E5%BD%92%E5%BC%8F%E9%A1%B5%E8%A1%A8"><em>递归式页表</em></a> 描述的方式访问页表</li></ul> <p>由于第一种方式简单、平台独立且更加强大（它允许访问非页表的页帧），我们的内核选择这种方式。为了启用需要的加载器支持，我们给 <code>bootloader</code> 依赖添加 <code>map_physical_memory</code> 特性：</p> <div class="language-toml line-numbers-mode"><pre class="language-toml"><code><span class="token punctuation">[</span><span class="token table class-name">dependencies</span><span class="token punctuation">]</span>
<span class="token key property">bootloader</span> <span class="token punctuation">=</span> <span class="token punctuation">{</span> <span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">&quot;0.9.3&quot;</span><span class="token punctuation">,</span> <span class="token key property">features</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">&quot;map_physical_memory&quot;</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>启用这个特性后，加载器将完整的物理内存映射到某个空闲的虚拟地址范围。为了向我们的内核传递这份虚拟地址范围，加载器会传入 <em>启动信息</em> 的结构。</p> <h3 id="启动信息"><a href="#启动信息" class="header-anchor">#</a> 启动信息</h3> <p><code>bootloader</code> 包定义了 <a href="https://docs.rs/bootloader/0.9.3/bootloader/bootinfo/struct.BootInfo.html" target="_blank" rel="noopener noreferrer"><code>BootInfo</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 结构，这个结构体包含传给内核的所有信息。这个结构体还处于早期开发阶段，所以预期后续升级到 <a href="https://doc.rust-lang.org/stable/cargo/reference/specifying-dependencies.html#caret-requirements" target="_blank" rel="noopener noreferrer">语义版本不兼容<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的 <code>bootloader</code> 版本时会有破坏性变化。启用 <code>map_physical_memory</code> 特性后，这个结构体目前有 <code>memory_map</code> 和 <code>physical_memory_offset</code> 两个字段可用：</p> <ul><li><code>memory_map</code> 包含可用物理内存的概览信息。它告诉我们的内核系统可用的物理内存有多少，哪个内存区域是预留给 VGA 硬件等设备的。内存映射表可以从 BIOS 或 UEFI 固件中查询，但是查询只允许发生在启动的很早阶段。因此，引导器必须为内核提供这项信息，否则内核后续没有办法拿到它。我们在文章后续部分会用到这个内存映射表。</li> <li><code>physical_memory_offset</code> 是物理内存在虚拟内存起始地址。物理地址加上这个偏移量得到相应的虚拟地址。这样就允许我们在内核中访问任意的物理内存了。</li></ul> <p>引导器以 <code>_start</code> 函数的 <code>&amp;'static BootInfo</code> 参数向我们的内核传入 <code>BootInfo</code> 结构。我们的函数还没有声明这个参数，所以得加一下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">use</span> <span class="token namespace">bootloader<span class="token punctuation">::</span></span><span class="token class-name">BootInfo</span><span class="token punctuation">;</span>

<span class="token attribute attr-name">#[no_mangle]</span>
<span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">fn</span> <span class="token function-definition function">_start</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span> <span class="token comment">// new argument</span>
    <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>因为 x86_64 架构的调用风格会传入某个 CPU 寄存器的值作为参数，所以之前忽略这个参数没有什么问题（@TODO：不懂）。因此，没有声明时，这个参数会被忽略掉。然而，如果不小心用错参数类型就会报错，因为编译器不知道我们入口函数正确的类型签名。</p> <h3 id="entry-point-宏"><a href="#entry-point-宏" class="header-anchor">#</a> <code>entry_point</code> 宏</h3> <p><code>_start</code> 函数由外在的引导器调用，引导器不会对其函数签名进行检查。这也就意味着我们可以让函数接收任意类型而不触发任何编译错误，但是一旦运行起来就会失败或者触发未定义行为。</p> <p>为了确保入口函数的签名总是符合加载器的期望，<code>bootloader</code> 包提供 <a href="https://docs.rs/bootloader/0.6.4/bootloader/macro.entry_point.html" target="_blank" rel="noopener noreferrer"><code>entry_point</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 宏，这个宏提供一个自动检查定义为入口函数的 Rust 函数是否符合要求的功能。让我们利用这个宏改写一些入口函数：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">use</span> <span class="token namespace">bootloader<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">BootInfo</span><span class="token punctuation">,</span> entry_point<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property">entry_point!</span><span class="token punctuation">(</span>kernel_main<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>由于这个宏为我们定义了真正的底层 <code>_start</code> 函数，现在就不用为入口函数附上 <code>extern &quot;C&quot;</code> 或 <code>no_mangle</code> 等修饰符了。<code>kernel_main</code> 函数现在完全是一个正常的 Rust 函数，我们可以随意为其命名。重要的是，类型检查被加了进来使得采用错误的函数签名（例如添加参数或者改变参数类型）会触发编译错误。</p> <p>对 <code>lib.rs</code> 进行同样的改造：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/lib.rs</span>

<span class="token attribute attr-name">#[cfg(test)]</span>
<span class="token keyword">use</span> <span class="token namespace">bootloader<span class="token punctuation">::</span></span><span class="token punctuation">{</span>entry_point<span class="token punctuation">,</span> <span class="token class-name">BootInfo</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token attribute attr-name">#[cfg(test)]</span>
<span class="token macro property">entry_point!</span><span class="token punctuation">(</span>test_kernel_main<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/// Entry point for `cargo test`</span>
<span class="token attribute attr-name">#[cfg(test)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">test_kernel_main</span><span class="token punctuation">(</span>_boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token comment">// like before</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">test_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">hlt_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>由于入口点只有在测试模式下使用，我们为所有新添项添加了 <code>#[cfg(test)]</code> 属性。我们将测试入口程序取不同的名字为 <code>test_kernel_main</code>，以避免和 <code>main.rs</code> 的 <code>kernel_main</code> 混淆。<code>BootInfo</code> 暂时还用不上，所以我们在参数名字前添加 <code>_</code> 以屏蔽掉变量未被使用的警告。</p> <h2 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h2> <p>物理内存访问权到手，我们终于可以开始实现自己的页表代码了。首先，我们将会瞅一下内核当前所在的活跃页表。然后创建一个转换函数，计算给定虚拟地址映射到的物理地址。最后，我们尝试修改现有页表来创建一个新的映射。</p> <p>开始之前，我们创建一个 <code>memory</code> 模块用于存放相关代码：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/lib.rs</span>

<span class="token keyword">pub</span> <span class="token keyword">mod</span> <span class="token module-declaration namespace">memory</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>再为模块创建对应的 <code>src/memory.rs</code> 空文件。</p> <h3 id="访问页表-2"><a href="#访问页表-2" class="header-anchor">#</a> 访问页表</h3> <p><a href="/2020/07/19/blog-os-08-intro-to-paging/#访问页表">上一篇文章的末尾</a>，我们试图访问内核所在的页表，但是由于无法访问 <code>CR3</code> 寄存器指向的物理页帧而失败了。现在我们可以继续往下，创建一个 <code>active_level_4_table</code> 函数返回活跃的第四级页表：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/memory.rs</span>

<span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span></span><span class="token punctuation">{</span>
    <span class="token namespace">structures<span class="token punctuation">::</span>paging<span class="token punctuation">::</span></span><span class="token class-name">PageTable</span><span class="token punctuation">,</span>
    <span class="token class-name">VirtAddr</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/// Returns a mutable reference to the active level 4 table.</span>
<span class="token comment">///</span>
<span class="token comment">/// This function is unsafe because the caller must guarantee that the</span>
<span class="token comment">/// complete physical memory is mapped to virtual memory at the passed</span>
<span class="token comment">/// `physical_memory_offset`. Also, this function must be only called once</span>
<span class="token comment">/// to avoid aliasing `&amp;mut` references (which is undefined behavior).</span>
<span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function-definition function">active_level_4_table</span><span class="token punctuation">(</span>physical_memory_offset<span class="token punctuation">:</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">)</span>
    <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token keyword">mut</span> <span class="token class-name">PageTable</span>
<span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span>registers<span class="token punctuation">::</span>control<span class="token punctuation">::</span></span><span class="token class-name">Cr3</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> <span class="token punctuation">(</span>level_4_table_frame<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Cr3</span><span class="token punctuation">::</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> phys <span class="token operator">=</span> level_4_table_frame<span class="token punctuation">.</span><span class="token function">start_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> virt <span class="token operator">=</span> physical_memory_offset <span class="token operator">+</span> phys<span class="token punctuation">.</span><span class="token function">as_u64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> page_table_ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token class-name">PageTable</span> <span class="token operator">=</span> virt<span class="token punctuation">.</span><span class="token function">as_mut_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token operator">*</span>page_table_ptr <span class="token comment">// unsafe</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>首先，我们从 <code>CR3</code> 寄存器读取了活跃的第四级页表的物理帧。然后，获取它的物理起始地址，转换为 <code>u64</code>，然后加上 <code>physical_memory_offset</code> 得到映射到页表帧的虚拟地址。最后，我们借助 <code>as_mut_ptr</code> 方法将虚拟地址转换为 <code>*mut PageTable</code> 裸指针，并不安全地基于其创建一个 <code>&amp;mut PageTable</code> 引用。之所以创建 <code>&amp;mut</code> 引用而不是 <code>&amp;</code> 引用是因为我们将会在后续部分改变页表结构。</p> <p>由于 Rust 将整个 <code>unsafe fn</code> 看做一个大的 <code>unsafe</code> 块，所以我们不需要使用一个 unsafe 块包围这些语句。因为我们可能会无意地在之前代码块里面加入危险操作，所以这样做也会使得我们的代码更加不安全。有一个 <a href="https://github.com/rust-lang/rfcs/pull/2585" target="_blank" rel="noopener noreferrer">RFC#2585<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 想要改变这种行为。</p> <p>至此，我们就可以使用这个函数来打印第四级页表的表项了：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token namespace">blog_os<span class="token punctuation">::</span>memory<span class="token punctuation">::</span></span>active_level_4_table<span class="token punctuation">;</span>
    <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span></span><span class="token class-name">VirtAddr</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World{}&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token namespace">blog_os<span class="token punctuation">::</span></span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> phys_mem_offset <span class="token operator">=</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">.</span>physical_memory_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> l4_table <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token function">active_level_4_table</span><span class="token punctuation">(</span>phys_mem_offset<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> entry<span class="token punctuation">)</span> <span class="token keyword">in</span> l4_table<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token operator">!</span>entry<span class="token punctuation">.</span><span class="token function">is_unused</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;L4 Entry {}: {:?}&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// as before</span>
    <span class="token attribute attr-name">#[cfg(test)]</span>
    <span class="token function">test_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;It did not crash!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token namespace">blog_os<span class="token punctuation">::</span></span><span class="token function">hlt_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>我们首先将 <code>BootInfo</code> 结构的 <code>physical_memory_offset</code> 转化为 <a href="https://docs.rs/x86_64/0.12.1/x86_64/addr/struct.VirtAddr.html" target="_blank" rel="noopener noreferrer"><code>VirtAddr</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，然后传给 <code>active_level_4_table</code> 函数。再调用 <code>iter</code> 函数遍历页表项，外加 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate" target="_blank" rel="noopener noreferrer"><code>enumerate</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 组合器来添加额外的元素下标。由于全屏放不下 512 个表项，我们只打印了非空的表项。</p> <p>运行它我们可以看到以下输出：</p> <p><img src="/assets/img/qemu-print-level-4-table.a33def50.png" alt="QEMU 打印第四级非空的页表项"></p> <p>可以看到有很多非空的页表项，分别映射到不同的第三级页表。之所以出现那么多区域，是因为内核代码、内核栈、物理内存映射和启动信息都使用了独立的内存区域。</p> <p>为了进一步遍历页表，瞅瞅第三级页表，我们可以将第四级页表项映射到的页帧再次转化为虚拟地址：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in the `for` loop in src/main.rs</span>

<span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span>structures<span class="token punctuation">::</span>paging<span class="token punctuation">::</span></span><span class="token class-name">PageTable</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token operator">!</span>entry<span class="token punctuation">.</span><span class="token function">is_unused</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;L4 Entry {}: {:?}&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// get the physical address from the entry and convert it</span>
    <span class="token keyword">let</span> phys <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> virt <span class="token operator">=</span> phys<span class="token punctuation">.</span><span class="token function">as_u64</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> boot_info<span class="token punctuation">.</span>physical_memory_offset<span class="token punctuation">;</span>
    <span class="token keyword">let</span> ptr <span class="token operator">=</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>virt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_mut_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> l3_table<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">PageTable</span> <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token operator">&amp;</span><span class="token operator">*</span>ptr <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// print non-empty entries of the level 3 table</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> entry<span class="token punctuation">)</span> <span class="token keyword">in</span> l3_table<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token operator">!</span>entry<span class="token punctuation">.</span><span class="token function">is_unused</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;  L3 Entry {}: {:?}&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>为了查看第二级和第一级页表，我们对第三级和第二级页表项重复同样的操作即可。可以想象得到，代码会变得变多很多，所以我们没有再次展示完整的代码。</p> <p>手动地遍历页表挺好玩，它会帮助我们理解 CPU 是如何执行地址转换的。然而，大多数时候，我们只关心指定虚拟地址映射到的物理地址，所以我们为其创建一个函数吧。</p> <h3 id="转换地址"><a href="#转换地址" class="header-anchor">#</a> 转换地址</h3> <p>为了实现地址从虚拟到物理的转换，我们必须遍历四级页表直至走到映射的物理页帧。让我们为这个转换创建一个函数：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/memory.rs</span>

<span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span></span><span class="token class-name">PhysAddr</span><span class="token punctuation">;</span>

<span class="token comment">/// Translates the given virtual address to the mapped physical address, or</span>
<span class="token comment">/// `None` if the address is not mapped.</span>
<span class="token comment">///</span>
<span class="token comment">/// This function is unsafe because the caller must guarantee that the</span>
<span class="token comment">/// complete physical memory is mapped to virtual memory at the passed</span>
<span class="token comment">/// `physical_memory_offset`.</span>
<span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function-definition function">translate_addr</span><span class="token punctuation">(</span>addr<span class="token punctuation">:</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">,</span> physical_memory_offset<span class="token punctuation">:</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">)</span>
    <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">PhysAddr</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token function">translate_addr_inner</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> physical_memory_offset<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>为了限制 <code>unsafe</code> 的作用域，我们将函数导向一个安全的 <code>translate_addr_inner</code>。正如我们之前所说的，Rust 把整个 <code>unsafe fn</code> 的函数体看做一个很大的 unsafe 块。通过调用一个私有的安全函数，我们显式地标识出每个 <code>unsafe</code> 的操作。</p> <p>私有的内层函数包含真正的实现：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/memory.rs</span>

<span class="token comment">/// Private function that is called by `translate_addr`.</span>
<span class="token comment">///</span>
<span class="token comment">/// This function is safe to limit the scope of `unsafe` because Rust treats</span>
<span class="token comment">/// the whole body of unsafe functions as an unsafe block. This function must</span>
<span class="token comment">/// only be reachable through `unsafe fn` from outside of this module.</span>
<span class="token keyword">fn</span> <span class="token function-definition function">translate_addr_inner</span><span class="token punctuation">(</span>addr<span class="token punctuation">:</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">,</span> physical_memory_offset<span class="token punctuation">:</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">)</span>
    <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">PhysAddr</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span>structures<span class="token punctuation">::</span>paging<span class="token punctuation">::</span>page_table<span class="token punctuation">::</span></span><span class="token class-name">FrameError</span><span class="token punctuation">;</span>
    <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span>registers<span class="token punctuation">::</span>control<span class="token punctuation">::</span></span><span class="token class-name">Cr3</span><span class="token punctuation">;</span>

    <span class="token comment">// read the active level 4 frame from the CR3 register</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span>level_4_table_frame<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Cr3</span><span class="token punctuation">::</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> table_indexes <span class="token operator">=</span> <span class="token punctuation">[</span>
        addr<span class="token punctuation">.</span><span class="token function">p4_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">.</span><span class="token function">p3_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">.</span><span class="token function">p2_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">.</span><span class="token function">p1_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> frame <span class="token operator">=</span> level_4_table_frame<span class="token punctuation">;</span>

    <span class="token comment">// traverse the multi-level page table</span>
    <span class="token keyword">for</span> <span class="token operator">&amp;</span>index <span class="token keyword">in</span> <span class="token operator">&amp;</span>table_indexes <span class="token punctuation">{</span>
        <span class="token comment">// convert the frame into a page table reference</span>
        <span class="token keyword">let</span> virt <span class="token operator">=</span> physical_memory_offset <span class="token operator">+</span> frame<span class="token punctuation">.</span><span class="token function">start_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_u64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> table_ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token class-name">PageTable</span> <span class="token operator">=</span> virt<span class="token punctuation">.</span><span class="token function">as_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> table <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span><span class="token operator">&amp;</span><span class="token operator">*</span>table_ptr<span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// read the page table entry and update `frame`</span>
        <span class="token keyword">let</span> entry <span class="token operator">=</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        frame <span class="token operator">=</span> <span class="token keyword">match</span> entry<span class="token punctuation">.</span><span class="token function">frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Ok</span><span class="token punctuation">(</span>frame<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> frame<span class="token punctuation">,</span>
            <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token class-name">FrameError</span><span class="token punctuation">::</span><span class="token class-name">FrameNotPresent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">None</span><span class="token punctuation">,</span>
            <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token class-name">FrameError</span><span class="token punctuation">::</span><span class="token class-name">HugeFrame</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">panic!</span><span class="token punctuation">(</span><span class="token string">&quot;huge pages not supported&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// calculate the physical address by adding the page offset</span>
    <span class="token class-name">Some</span><span class="token punctuation">(</span>frame<span class="token punctuation">.</span><span class="token function">start_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">u64</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>addr<span class="token punctuation">.</span><span class="token function">page_offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>与其重用我们的 <code>active_level_4_table</code> 函数，我们再次从 <code>CR3</code> 寄存器读出第四级页帧。我们这样做是为了简化原型实现。别介意，我们后续会创建一个更优雅的实现。</p> <p><code>VirtAddr</code> 结构体已经提供计算四级页表每一个索引的方法。我们用一个小数组保存这些索引，使得我们可以借助 <code>for</code> 循环遍历这些页表。循环之外，我们保存上一次访问的 <code>frame</code> 用于后续计算物理地址。<code>frame</code> 指向遍历过程中的页表帧，也指向上一轮迭代指向的页帧，即最后指向第一级页表项映射的页帧。</p> <p>循环内部，我们再次使用 <code>physical_memory_offset</code> 将页帧转换为页表引用。然后读取当前页表项，调用 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/page_table/struct.PageTableEntry.html#method.frame" target="_blank" rel="noopener noreferrer"><code>PageTableEntry::frame</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数提取映射到的页帧。如果表项没有映射到页帧则返回 <code>None</code>。如果表项映射到 2MiB 或 1GiB 的页面，我们暂且直接 panic。</p> <p>让我们借助一些地址来测测我们的转换函数：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token comment">// new imports</span>
    <span class="token keyword">use</span> <span class="token namespace">blog_os<span class="token punctuation">::</span>memory<span class="token punctuation">::</span></span>translate_addr<span class="token punctuation">;</span>
    <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span></span><span class="token class-name">VirtAddr</span><span class="token punctuation">;</span>

    <span class="token punctuation">[</span>…<span class="token punctuation">]</span> <span class="token comment">// hello world and blog_os::init</span>

    <span class="token keyword">let</span> phys_mem_offset <span class="token operator">=</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">.</span>physical_memory_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> addresses <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token comment">// the identity-mapped vga buffer page</span>
        <span class="token number">0xb8000</span><span class="token punctuation">,</span>
        <span class="token comment">// some code page</span>
        <span class="token number">0x201008</span><span class="token punctuation">,</span>
        <span class="token comment">// some stack page</span>
        <span class="token number">0x0100_0020_1a10</span><span class="token punctuation">,</span>
        <span class="token comment">// virtual address mapped to physical address 0</span>
        boot_info<span class="token punctuation">.</span>physical_memory_offset<span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token operator">&amp;</span>address <span class="token keyword">in</span> <span class="token operator">&amp;</span>addresses <span class="token punctuation">{</span>
        <span class="token keyword">let</span> virt <span class="token operator">=</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> phys <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token function">translate_addr</span><span class="token punctuation">(</span>virt<span class="token punctuation">,</span> phys_mem_offset<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?} -&gt; {:?}&quot;</span><span class="token punctuation">,</span> virt<span class="token punctuation">,</span> phys<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">[</span>…<span class="token punctuation">]</span> <span class="token comment">// test_main(), &quot;it did not crash&quot; printing, and hlt_loop()</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>我们运行后可看到以下输出：</p> <p><img src="/assets/img/qemu-translate-addr.959508b3.png" alt="0xb8000 -&gt; 0xb8000, 0x201008 -&gt; 0x401008, 0x10000201a10 -&gt; 0x279a10, &quot;panicked at 'huge pages not supported'"></p> <p>正如预期的那样，一一对应的地址 <code>0xb8000</code> 转换得到相同的物理地址。代码页和栈页则转换到某个随意的物理地址，依赖于引导器加载我们内核时创建的初始映射。最后的 12 比特总是不随转换变化，因为这些比特是 <a href="/2020/07/19/blog-os-08-intro-to-paging/#x86-64-架构的分页"><em>页内偏移</em></a>，而不是转换的一部分。</p> <p>由于每个物理地址加上 <code>physical_memory_offset</code> 后即可访问到，转换 <code>physical_memory_offset</code> 地址本身应该得到物理地址 <code>0</code>。然而，因为映射使用当前不支持的巨大页提高效率，所以转换失败了。</p> <h3 id="使用-offsetpagetable"><a href="#使用-offsetpagetable" class="header-anchor">#</a> 使用 <code>OffsetPageTable</code></h3> <p>OS 内核中，虚拟地址到物理地址的转换是很常见的，<code>x86_64</code> 架构为此提供了相应的抽象。除 <code>translate_addr</code> 之外，具体实现已经支持的巨大页和其他页表操作函数，所以我们后续部分直接使用这个包而不是在自己的实现中添加巨大页支持。</p> <p>抽象的基础是两个 traits，定义了多种页表映射函数：</p> <ul><li><a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/trait.Mapper.html" target="_blank" rel="noopener noreferrer"><code>Mapper</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 对于页面大小支持泛型，并提供操作页面的函数。例如 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/trait.Mapper.html#tymethod.translate_page" target="_blank" rel="noopener noreferrer"><code>translate_page</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 将给定页面转换为同样大小的页帧，<a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/trait.Mapper.html#tymethod.map_to" target="_blank" rel="noopener noreferrer"><code>map_to</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 在页表中创建映射</li> <li><a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/trait.MapperAllSizes.html" target="_blank" rel="noopener noreferrer"><code>MapperAllSizes</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 要求实现者提供所有页面大小的 <code>Mapper</code>。另外，它提供了处理多种页面大小的函数，例如 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/trait.MapperAllSizes.html#method.translate_addr" target="_blank" rel="noopener noreferrer"><code>translate_addr</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或者通用的 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/trait.MapperAllSizes.html#tymethod.translate" target="_blank" rel="noopener noreferrer"><code>translate</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>这些 traits 只是定义了接口，不提供任何实现。<code>x86_64</code> 包目前提供了三种不同的实现类型，分别有不同的要求。<a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/struct.OffsetPageTable.html" target="_blank" rel="noopener noreferrer"><code>OffsetPageTable</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型假设完整的物理内存映射到某个偏移量的虚拟内存空间。<a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/struct.MappedPageTable.html" target="_blank" rel="noopener noreferrer"><code>MappedPageTable</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 要更加灵活一点：它只要求每个页表帧都映射到可计算的虚拟地址空间。最后，<a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/struct.RecursivePageTable.html" target="_blank" rel="noopener noreferrer"><code>RecursivePageTable</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型可用于以 <a href="#%E9%80%92%E5%BD%92%E5%BC%8F%E9%A1%B5%E8%A1%A8">递归式页表</a> 的方式访问页表帧。</p> <p>对于当前场景，引导器将完整的物理内存映射到偏移量为 <code>physical_memory_offset</code> 的虚拟地址，所以我们可以使用 <code>OffsetPageTable</code> 类型。我们在 <code>memory</code> 模块创建一个 <code>init</code> 函数用来初始化它：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span>structures<span class="token punctuation">::</span>paging<span class="token punctuation">::</span></span><span class="token class-name">OffsetPageTable</span><span class="token punctuation">;</span>

<span class="token comment">/// Initialize a new OffsetPageTable.</span>
<span class="token comment">///</span>
<span class="token comment">/// This function is unsafe because the caller must guarantee that the</span>
<span class="token comment">/// complete physical memory is mapped to virtual memory at the passed</span>
<span class="token comment">/// `physical_memory_offset`. Also, this function must be only called once</span>
<span class="token comment">/// to avoid aliasing `&amp;mut` references (which is undefined behavior).</span>
<span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function-definition function">init</span><span class="token punctuation">(</span>physical_memory_offset<span class="token punctuation">:</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">OffsetPageTable</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'static</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> level_4_table <span class="token operator">=</span> <span class="token function">active_level_4_table</span><span class="token punctuation">(</span>physical_memory_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">OffsetPageTable</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>level_4_table<span class="token punctuation">,</span> physical_memory_offset<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// make private</span>
<span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function-definition function">active_level_4_table</span><span class="token punctuation">(</span>physical_memory_offset<span class="token punctuation">:</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">)</span>
    <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token keyword">mut</span> <span class="token class-name">PageTable</span>
<span class="token punctuation">{</span>…<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>这个函数接收一个 <code>physical_memory_offset</code> 作为入参，并返回生命期为 <code>'static</code> 的 <code>OffsetPageTable</code> 实例。这意味着，这个实例在我们内核的整个运行时范围内有效。函数体内，我们首先调用 <code>active_level_4_table</code> 函数获取第四级页表的可修改引用。然后以这个引用调用 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/struct.OffsetPageTable.html#method.new" target="_blank" rel="noopener noreferrer"><code>OffsetPageTable::new</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数。外加第二个参数，<code>new</code> 函数还需要物理内存起始的虚拟地址，记录在 <code>physical_memory_offset</code> 变量中。</p> <p>从现在开始，<code>active_level_4_table</code> 只应被 <code>init</code> 函数调用，否则容易产生同名可变引用导致未定义行为。因此，我们把函数私有化，移除 <code>pub</code> 标识符。</p> <p>我们现在可以用 <code>MapperAllSizes::translate_addr</code> 方法替换掉 <code>memory::translate_addr</code> 函数，改动 <code>kernel_main</code> 函数的几行即可：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token comment">// new: different imports</span>
    <span class="token keyword">use</span> <span class="token namespace">blog_os<span class="token punctuation">::</span></span>memory<span class="token punctuation">;</span>
    <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token namespace">structures<span class="token punctuation">::</span>paging<span class="token punctuation">::</span></span><span class="token class-name">MapperAllSizes</span><span class="token punctuation">,</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token punctuation">[</span>…<span class="token punctuation">]</span> <span class="token comment">// hello world and blog_os::init</span>

    <span class="token keyword">let</span> phys_mem_offset <span class="token operator">=</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">.</span>physical_memory_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// new: initialize a mapper</span>
    <span class="token keyword">let</span> mapper <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token namespace">memory<span class="token punctuation">::</span></span><span class="token function">init</span><span class="token punctuation">(</span>phys_mem_offset<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> addresses <span class="token operator">=</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// same as before</span>

    <span class="token keyword">for</span> <span class="token operator">&amp;</span>address <span class="token keyword">in</span> <span class="token operator">&amp;</span>addresses <span class="token punctuation">{</span>
        <span class="token keyword">let</span> virt <span class="token operator">=</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// new: use the `mapper.translate_addr` method</span>
        <span class="token keyword">let</span> phys <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">translate_addr</span><span class="token punctuation">(</span>virt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?} -&gt; {:?}&quot;</span><span class="token punctuation">,</span> virt<span class="token punctuation">,</span> phys<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">[</span>…<span class="token punctuation">]</span> <span class="token comment">// test_main(), &quot;it did not crash&quot; printing, and hlt_loop()</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>为了使用提供的 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/trait.MapperAllSizes.html#method.translate_addr" target="_blank" rel="noopener noreferrer"><code>translate_addr</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法，我们需要导入 <code>MapperAllSizes</code> trait。</p> <p>再次运行，我们可以看到和之前一样的转换结果，不同的是巨大页转换现在也成功了：</p> <p><img src="/assets/img/qemu-mapper-translate-addr.f1197bc5.png" alt="0xb8000 -&gt; 0xb8000, 0x201008 -&gt; 0x401008, 0x10000201a10 -&gt; 0x279a10, 0x18000000000 -&gt; 0x0"></p> <p>正如预期那样，<code>0xb8000</code>、代码地址和栈地址的转换都和我们自己的转换函数所得一样。另外， 我们现在可以看到虚拟地址 <code>physical_memory_offset</code> 映射到了物理地址 <code>0x0</code>。</p> <p>借助 <code>MappedPageTable</code>类型的转换函数，我们不用再自己实现巨大页支持。我们还可以调用其他诸如 <code>map_to</code> 的页面操作函数，后续部分会用到这个函数。</p> <p>至此，<code>memory::translate_addr</code> 和 <code>memory::translate_addr_inner</code> 函数就没用了，删除即可。</p> <h3 id="创建新的映射"><a href="#创建新的映射" class="header-anchor">#</a> 创建新的映射</h3> <p>到目前为止，我们都只是查看页表，没有做任何更改。让我们动手实操，为之前没有映射的页面创建一个映射。</p> <p>我们将会使用 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/trait.Mapper.html" target="_blank" rel="noopener noreferrer"><code>Mapper</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 的 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/trait.Mapper.html#tymethod.map_to" target="_blank" rel="noopener noreferrer"><code>map_to</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数，所以先瞅瞅这个函数。文档说他需要四个参数：想要映射的页面，页面映射到的页帧，页表项的一系列标识符和一个 <code>frame_allocator</code>。因为映射给定页面可能要求创建额外的页表，额外的页表需要使用后备的页帧，所以页帧分配器是需要的。</p> <h4 id="create-example-mapping-函数"><a href="#create-example-mapping-函数" class="header-anchor">#</a> <code>create_example_mapping</code> 函数</h4> <p>我们实现的第一步是创建一个 <code>create_example_mapping</code> 函数，用于映射给定的虚拟地址到 VGA 文本缓冲区所在物理页帧地址 <code>0xb8000</code>。选取这个页帧是因为它允许我们很容易地测试一个映射是否被正确地创建了出来：我们只是需要写入新映射的页面，然后查看写操作的结构是否出现在屏幕上。</p> <p><code>create_example_mapping</code> 函数如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/memory.rs</span>

<span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span></span><span class="token punctuation">{</span>
    <span class="token class-name">PhysAddr</span><span class="token punctuation">,</span>
    <span class="token namespace">structures<span class="token punctuation">::</span>paging<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Page</span><span class="token punctuation">,</span> <span class="token class-name">PhysFrame</span><span class="token punctuation">,</span> <span class="token class-name">Mapper</span><span class="token punctuation">,</span> <span class="token class-name">Size4KiB</span><span class="token punctuation">,</span> <span class="token class-name">FrameAllocator</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/// Creates an example mapping for the given page to frame `0xb8000`.</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">create_example_mapping</span><span class="token punctuation">(</span>
    page<span class="token punctuation">:</span> <span class="token class-name">Page</span><span class="token punctuation">,</span>
    mapper<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">OffsetPageTable</span><span class="token punctuation">,</span>
    frame_allocator<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">impl</span> <span class="token class-name">FrameAllocator</span><span class="token operator">&lt;</span><span class="token class-name">Size4KiB</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span>structures<span class="token punctuation">::</span>paging<span class="token punctuation">::</span></span><span class="token class-name">PageTableFlags</span> <span class="token keyword">as</span> <span class="token class-name">Flags</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> frame <span class="token operator">=</span> <span class="token class-name">PhysFrame</span><span class="token punctuation">::</span><span class="token function">containing_address</span><span class="token punctuation">(</span><span class="token class-name">PhysAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">0xb8000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> flags <span class="token operator">=</span> <span class="token class-name">Flags</span><span class="token punctuation">::</span><span class="token constant">PRESENT</span> <span class="token operator">|</span> <span class="token class-name">Flags</span><span class="token punctuation">::</span><span class="token constant">WRITABLE</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> map_to_result <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token comment">// FIXME: this is not safe, we do it only for testing</span>
        mapper<span class="token punctuation">.</span><span class="token function">map_to</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> frame<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> frame_allocator<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    map_to_result<span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">&quot;map_to failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>除了要求被映射的 <code>page</code> 外，函数还期望一个 <code>OffsetPageTable</code> 实例的可变引用和 <code>frame_allocator</code>。<code>frame_allocator</code> 参数使用 <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters" target="_blank" rel="noopener noreferrer"><code>impl Trait</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 语法来实现对所有满足 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/trait.FrameAllocator.html" target="_blank" rel="noopener noreferrer"><code>FrameAllocator</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 类型的泛型。这个 trait 对 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/page/trait.PageSize.html" target="_blank" rel="noopener noreferrer"><code>PageSize</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait 实现泛型，从而支持标准的 4KiB 页面和巨大的 2MiB/1GiB 页。我们只想要创建 4KiB 的映射，所以我们设置泛型参数为 <code>Size4KiB</code>。</p> <p><a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/trait.Mapper.html#tymethod.map_to" target="_blank" rel="noopener noreferrer"><code>map_to</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法是不安全的，因为调用者必须确保页帧是尚未被征用。理由是映射同一个页帧两次会导致未定义行为，例如两个不同的可变引用指向同一个物理内存位置。在我们当前场景下，我们复用已被映射的 VGA 文本缓冲区的页帧，所以违背了要求的条件。但是，<code>create_example_mapping</code> 只用作临时测试，过了这篇文章就会被删除，所以问题不大。为了警示我们危险性，我们添加了一个 <code>FIXME</code> 注释。</p> <p>除了 <code>page</code> 和 <code>unused_frame</code> 之外，<code>map_to</code> 方法还要一些映射用的标识符和一个 <code>frame_allocator</code> 的引用（紧接着会解释原因）。对于标识符，我们设置所有合法表项都要求的 <code>PRESENT</code> 标识和让被映射的页面可写的 <code>WRITABLE</code> 标识符。查看上一篇文章的 <a href="/2020/07/19/blog-os-08-intro-to-paging/#页表格式">页表格式</a> 小节可以找到所有可用的标识符。</p> <p><a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/trait.Mapper.html#tymethod.map_to" target="_blank" rel="noopener noreferrer"><code>map_to</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数可能会失败，所以它返回一个 <a href="https://doc.rust-lang.org/core/result/enum.Result.html" target="_blank" rel="noopener noreferrer"><code>Result</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。由于这只是示例代码，对健壮性没有要求，所以我们仅使用 <a href="https://doc.rust-lang.org/core/result/enum.Result.html#method.expect" target="_blank" rel="noopener noreferrer"><code>expect</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来触发错误时直接 panic。一旦成功，这个函数返回一个 <a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/paging/mapper/struct.MapperFlush.html" target="_blank" rel="noopener noreferrer"><code>MapperFlush</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型，这个类型提供便利的 <code>flush</code> 方法将 TLB（translation lookaside buffer）中新映射的页面刷入。和 <code>Result</code>，这个类型使用 <a href="https://doc.rust-lang.org/std/result/#results-must-be-used" target="_blank" rel="noopener noreferrer"><code>#[must_use]</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 属性来触发忘记使用时触发警告。</p> <h4 id="仿造-frameallocator"><a href="#仿造-frameallocator" class="header-anchor">#</a> 仿造 <code>FrameAllocator</code></h4> <p>为了调用 <code>create_example_mapping</code>，我们首先需要创建一个实现 <code>FrameAllocator</code> trait 的类型。如前面所述，这个 trait 负责在 <code>map_to</code> 需要新页表时分配页面。</p> <p>从简单情况开始，假设我们现在不需要创建新的页表。这种情况下，页帧分配器总是返回 <code>None</code>。我们创建一个 <code>EmptyFrameAllocator</code> 来测试我们的映射函数：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/memory.rs</span>

<span class="token comment">/// A FrameAllocator that always returns `None`.</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">EmptyFrameAllocator</span><span class="token punctuation">;</span>

<span class="token keyword">unsafe</span> <span class="token keyword">impl</span> <span class="token class-name">FrameAllocator</span><span class="token operator">&lt;</span><span class="token class-name">Size4KiB</span><span class="token operator">&gt;</span> <span class="token keyword">for</span> <span class="token class-name">EmptyFrameAllocator</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">allocate_frame</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">PhysFrame</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">None</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>实现 <code>FrameAllocator</code> 是不安全的，因为实现者必须保证分配器只会返回空闲的页帧。否则可能会触发未定义行为，例如两个虚拟页面映射到同一个物理页帧的情况。我们的 <code>EmptyFrameAllocator</code> 只会返回 <code>None</code>，所以在这个场景下是没有问题的。</p> <h4 id="选择一个虚拟页"><a href="#选择一个虚拟页" class="header-anchor">#</a> 选择一个虚拟页</h4> <p>现在这个简单的页帧分配器可以传给我们的 <code>create_example_mapping</code>。然而，这个分配器总是返回 <code>None</code>，所以只有当创建映射不需要额外的页表帧时才是可行的。为了弄明白什么时候需要和不需要额外的页表帧，我们看个例子：</p> <p><img src="/assets/img/required-page-frames-example.f3dcc8f9.svg" alt="一个虚拟和物理地址空间，空间下有一个映射的页面和四个不同层级的页表"></p> <p>上图在左边显示虚拟地址空间，右边显示物理地址空间，页表在中间。如虚线所示，页表存在物理内存页帧中。虚拟地址空间包含一个地址为 <code>0x803fe00000</code>、蓝色的映射页。为了将这个页面映射到页帧，CPU 遍历四级页表直至找到地址为 36 KiB 的页帧。</p> <p>另外，VGA 文本缓冲区的物理页帧在图中被标成红色。我们的目标是在 <code>create_example_mapping</code> 函数中将之前尚未映射的虚拟页面映射到这个页帧。由于我们的 <code>EmptyFrameAllocator</code> 总是返回 <code>None</code>，我们想要创建的映射不能向分配器申请额外的页帧。这就取决于我们选取用来做映射的虚拟页面了。</p> <p>图中展示了虚拟地址空间的两个候选页面，都标成了黄色。一页位于地址 <code>0x803fdfd000</code>，在之前和蓝色的映射页隔三页。虽然第四级和第三级页表索引和蓝色页相同，但是第二级和第一级索引不同（具体算法参见 <a href="/2020/07/19/blog-os-08-intro-to-paging/#x86-64-架构的分页">上一篇文章</a>）。不同的第二级页表索引意味着这个页面需要采用不同的第一级页表。由于这个第一级页表尚未存在，我们如果选择这页作示例映射的话就需要把页表创建出来，这样就会需要分配空闲的物理帧。而位于 <code>0x803fe02000</code> 的第二个候选页则不会有这个问题，因为它和蓝色也使用相同的第一级页表。因此，所有需要的页表都已经存在了。</p> <p>总而言之，创建新映射的难点依赖我们需要映射的虚拟页面。最简单的情况下，第一级页表已经存在，我们只需要写入一个页表项即可。最艰难的情况下，页面所在内存区域对应的第三级页表尚未存在，这时我们就需要首先创建新的第三级、第二级和第一级页表。</p> <p>为了以 <code>EmptyFrameAllocator</code> 调用 <code>create_example_mapping</code> 函数，我们需要选择所有页表都已经存在的页面。为了找到这样一个页面，我们可以利用这样的一个事实：引导器会将自己加载到虚拟地址空间的首个兆字节的虚拟空间。这也就意味着这个区域所有页面的第一级页表都是已存在。因此，我们可以选择这个内存区域空闲的页面用作示例映射，例如地址为 <code>0</code> 的页面。正常情况下，这个页面应该会保持空闲以确保解析空指针会触发缺页异常，所以我们可以知道引导器闲置这个页面。</p> <h4 id="创建映射"><a href="#创建映射" class="header-anchor">#</a> 创建映射</h4> <p>现在所有调用 <code>create_example_mapping</code> 函数所需的参数准备就绪，让我们修改 <code>kernel_main</code> 函数将虚拟地址 <code>0</code> 的页面映射出来。由于我们要把页面映射到 VGA 文本缓冲区，我们应该能够通过它往屏幕写入东西。具体实现如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token namespace">blog_os<span class="token punctuation">::</span></span>memory<span class="token punctuation">;</span>
    <span class="token keyword">use</span> <span class="token namespace">x86_64<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token namespace">structures<span class="token punctuation">::</span>paging<span class="token punctuation">::</span></span><span class="token class-name">Page</span><span class="token punctuation">,</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// new import</span>

    <span class="token punctuation">[</span>…<span class="token punctuation">]</span> <span class="token comment">// hello world and blog_os::init</span>

    <span class="token keyword">let</span> phys_mem_offset <span class="token operator">=</span> <span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">.</span>physical_memory_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> mapper <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> <span class="token namespace">memory<span class="token punctuation">::</span></span><span class="token function">init</span><span class="token punctuation">(</span>phys_mem_offset<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> frame_allocator <span class="token operator">=</span> <span class="token namespace">memory<span class="token punctuation">::</span></span><span class="token class-name">EmptyFrameAllocator</span><span class="token punctuation">;</span>

    <span class="token comment">// map an unused page</span>
    <span class="token keyword">let</span> page <span class="token operator">=</span> <span class="token class-name">Page</span><span class="token punctuation">::</span><span class="token function">containing_address</span><span class="token punctuation">(</span><span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token namespace">memory<span class="token punctuation">::</span></span><span class="token function">create_example_mapping</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> mapper<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> frame_allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// write the string `New!` to the screen through the new mapping</span>
    <span class="token keyword">let</span> page_ptr<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span> <span class="token keyword">u64</span> <span class="token operator">=</span> page<span class="token punctuation">.</span><span class="token function">start_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_mut_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> page_ptr<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write_volatile</span><span class="token punctuation">(</span>0x_f021_f077_f065_f04e<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token punctuation">[</span>…<span class="token punctuation">]</span> <span class="token comment">// test_main(), &quot;it did not crash&quot; printing, and hlt_loop()</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>我们首先以 调用 <code>mapper</code> 和 <code>frame_allocator</code>  实例的可变引用调用 <code>create_example_mapping</code> 函数，创建出地址为 <code>0</code> 的页面映射。这个映射将页面映射到 VGA 文本缓冲区页帧，所以我们可以在屏幕看到这个缓冲区写入的任何东西。</p> <p>然后将页面转换为一个裸指针，并往偏移量 <code>400</code> 的地址写入值。我们没有往页面开始的地方写入是因为 VGA 缓冲区的顶行会被下一个 <code>println</code> 直接刷出屏幕。写入的值为 <code>0x_f021_f077_f065_f04e</code>，表示白底的字符串 <em>&quot;New!&quot;</em>。如 <a href="/2020/07/23/blog-os-03-vga-text-mode/#易失操作">VGA 文本模式</a> 文章所描述的那样，对 VGA 缓冲区的写入应该是不稳定的，所以我们使用了 <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.write_volatile" target="_blank" rel="noopener noreferrer"><code>write_volatile</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法。</p> <p>在 QEMU 中运行，我们可以看到以下输出：</p> <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAtIAAAGtCAYAAAA79pMjAAAABHNCSVQICAgIfAhkiAAAABh0RVh0U29mdHdhcmUAbWF0ZS1zY3JlZW5zaG90yJbwSgAAH15JREFUeJzt3WmQZedh1+H/OXfrZWY0I8mWPHIcxVKII2+yHVu2LCI5QZYQNqEIKZO9KPAHwhIgpCigAgQoqBRVgZCiEpa4IPtKnAVHMnHkNYmTeMGr7ESOHVnbaPalu+92Dh9ud09PT89M9zvaRvM8Vdca3XvOe869PaP6zev3nlNlC7e98ZZ2q+cBAOBy9MEPfbja/NwZT6wF9P4XXLvplbNd4OWkOv8WF9z/jI3O3npn+5/9wrb2P88Y1YU22Pb+ZRtv7/yri9x/4w5n7rHz/Tf/645HOGOMorM598ex/bGqnb73s954yTs/Y6wL/NG68Cjn+XO17bM4/39KLrz/eXfZ5k+o8A9xde6XtjXWxe2/xdlc5M8zSdKu/0/O/NVOx9j4yx2Octb+53hxG2NceOvzbNHu9Mzbs/61fCZp9ZO7yKmo0/uXDbTpt8OOx9p6/+2Pt/PTP8fv3YK3327x89zZ/pufuKjfTZueLPydfc7ddvAnbZs/z/L9N2+2xQ7bGGPrTbb9H4ZtvM3zb3Gh/R955LEkZwb1+i9ue+Mt7b59ey90CgAAcNk6cuToekxXySyi9+694pk9KwAAuAQcPXosH/zQh6v6mT4RAAC4FFW3vfGW9oor9jzT5wEAwCWsbdtUVZWmadK0TZppmzbN6tLkNkmVqlr7vk+Vtt36ez9rz7dtuz7u6Y3PP85kMt3WudZ1lTp16k6Vuq5T1zufWz527Hi66ycIAAAF2rZN27aZNk2a6TTj8STNdLoa1W3qajVYO530ep2kqmfri9usR/HaOFWqpG3Ttk3G4+k2xpltX1VV6q2advW8Js00TXM6+Os66daddLqd1N1OOnVnx0HdvbiPDQCAy9l6RE+ajMejDEejXH/99bnuuv256qqrs2/f3hw5cjSHDh3Mww8/ki9+8YsZ9Pvp9rqzGeWszSzPppbbts1kMslwOMr+/ftz4403ZO++fdm9a1dOnjyZo0eP5cEHH8yXv/zls8bJphCeTqcZjUb5Kzfuz+uuuzLX792da3bN5/GTy/ni0RP5g4cP551//Ej6g37Sm+2zk5iubnvjLe3u3bsu6gOcTqdZWRlmaWk5VVVlfn4ug8Eg3W7nosY9Q9tktLySpeEk42mTVHW6vV7mF+Yy1137m0yTpaPHc3J89u5Vbz5X7R2kTtIOT+Xg8XGq/kKuvKKfMz+uNivHj+f4MJnbsyd7BlWSaU4ePpGlppc9Vy1mrtq8bZ3Ffbuz6K8lAMBlZD2ip9MMR+P0er3ccfvtufLKvZlOm0ynTZpmkrruptOp0+nUOXz4aN77vvdlPB6n3+utzkjPlm20bZvxeJxOp84b33hbrrnm+Wmarcc5ePBQPvCBD2a0YZymOT0jPZ1M8vy5Tn7o61+a/bsGaZtp0jRpmyZVXSd1naru5JGTw/yT9386j69M1sN8O06cODkL6V27Fos/wJWVYQ4dPpK2bdPtdJJqFtadupN9+/ZmMOgXj72uGefE0mK+9s1vyVv//Mvz1dfuTr1yJH/22Y/k3e98Vz70eHLFfLJ8fC5v+uf/Lt/9NWd/AJNP/1S+54d+LxlMsvTSt+cnvvfrMv7oT+Qf/chHU+1Zi+k2K8ervOJ7/k3+wS29fPCHvzc//rl+OitX56/8+x/IX33+x/If3/5f88nFhQyqNsPjw7zy7/1ovvfVT+R//8C/zDsPL4ppAOCyMlldytHr9vLmN9+ZTrfKeDROmzbthrCt6ipVqvT6vUwnbe67792ZTMfpdnup62o1oiepqypvfvOd6Q966+OkPb0UeeM4k3GTe++9L007TbfbWz/WdDLJdYNOfuSOmzLfjtOMVs55/nV/LstVL3/ndz6Vxydt+r1+6vrCF/k/efLUxS3tWFlZyYEDB7Nr12Lm5+fT68+ieTgcZjgc5omDh3L1VVdmbm5QfpB2mpPLz8td3/+P8x03LWZy7Mt54BN/msnur8hLXntXvudVN+cl//mH8hMPTLKe7M3hfOYDn8jDG2amp48+lvTrtE2bK67cm05VZXDzW/KWr/rD/NJjya5e0k6GGb3orfmW1+5KVU2zd99i2mZUfu4AAM9hbdumnbYZj0a5/etvS9tOsrw0WZ+pXntUVbX+mEzG6fX6ufXW1+U973lvuvVsrXPTNBkNh3nTN9yRuk6Wl5YvMM4kvV4vt932+vVx6rpeXRoyzr94w1eme+pwhsPl87+JU8fTm1vIv3rVdXn7h76QTqeTut5eIhd/2XA8HufYsROziJ6by7d927fmNa98RZLkY//vE/npn/3ZtE2bo0eP5aqrrixe5jFZGubat/zNfOtNizn2sZ/Jv/7R+/PItE41TXa/8tvyA//wjnzD29+Wj3/fO/LRdn620/SRvO9nfjrvH3bSWfsLRaeXxblOpktV9l55Req2TVNfk2/8y6/Lb/7IRzLtdjNeGuR133RHrqvbtG2dvfv2JNMDZ93ppm3b2d+yNp9s2170Ha0AAC4V02mb8XSc667bn7m5uSwtLWdtiUbTNKsBPLuqRrX6RcGqqjIeTzI/v5D91+3PE48fSL/Tz3Q8zbXXXptdi4ur4yT33/++TCaTLY99553fmPF4vD7OgQMHMugMMplMcs+1i3l+u5Tx0aNJkgNLoxxcHuemq06vwvj8kaXs6nWyf9cg0+UTuXbX3vzFF+zK/z04mq2y2IbVkN75B7eyMkrTtpmbm893f9d35qaXfHVOnTqZJHn5S7823/kd35H/9VM/ndF4nOXllZQtH5lkpfnq3PmmF6YzeiC//I735on+rlzRSZI2w0/+Yn7yg6/KP7vj1bnz9b+YP/ydjfs2GQ+nmU1K15nbM5e0SdMke67YnWr6YN7/ewu57da78ubrPpxfe6LJ9Nq78tZXzeXh3/1wVm55fa7esztpHj/rrNrVW8ieHdgXf2tYAIBLxdqXDF+w/wVZXl7OdDpdfb5Zn0Vec3o2ebagtmma7N//gjz6yKPptbMlIvv3X5uVldk4a7veeec3nDXO/fe/P+PxePUyeU1eeN3+PPrIo6kGVSbTaW5/3nwmp46nmcxK8PGVaX74Iw/l+25+QW66ciGfP7qc//CxR/J3X/2iXDs322Zy6njueN58fuvx5fS32XOr89Y7r79pM02/102v183Nr3hpjh87nroz+2CGKyt51ctflp/r9tLv9TKdToqOkek0zb6vzPVXVGm+9Jl86lg3g92nx+kPJvncpx7M6I5X5/oXvzDV78zugZ7ey/K3/9s78rfXNmwO5V3/5p/mZx8epNvOZc+eXqr2RD7xzg9mz9d9V/7CPS/Pb/74Z/OSu+/I9aNP5cfe+dm84XWvz1desTvdttl05m22zuic4zkAgOemqkraZppdi4sZjYZJzl7psLYk4/Tz01RVlel0ksWFhdmX/zIbZ3FxMaPR6IwxlpeXzxhnzawvZ9/NW1gdp06dZtrkK+aqNKeW0jZNkuRlz9+b73/r7fkPv/HefPP1e/OrXzyW773nz+fl1fE0J44kSZpmmhcuzqeZNtlu0xUv7ejUdeqNF8PeeMBq7fBtut3Opg9vB9o2GQwyl6RdPpWl1ec2/J0k45NLGSWzLzWuvdAcyifu/2geWlve3J7KAyc66VZNmuzJ7sUq7fBUTh74/fzm7/7l/PPb7szt79mTm99wRQ5+4L783mPzecUkqRZ3ZbFNTmxcb96unUO7xWdsaQcAcPlokzRtm1RZX4JRVVV+93c/fM59br31lvXZ6sFcJ81q2zWroTwej9fHSc7s1I2/ns1az/59MFgdp5pdf3qhHa+HfZI0R5/I1+we56+97uX5nx/8eL7j1lfkpc3hTI4fPn1iVZW5Zrw+m74dxUs7er1eptNpJpNpPvHpz+ZrbnxxhsPh6puZy8c/+amMJ9PUdSfdbrcwMKu0J0/kRJtUe/ZmT9ocnv2skiRt02awd08GaXPi5FLatRemj+ZDv/Dzed/K2hrpKr1BP716muXMZ3GhSru0lFOZ5MF735cv3f5N+eZ/cF12db+Yn7vv85lUfy5Ly0m1uJjFqs3xdpLxpE0yl4X52fKQtk6adj4L81WScUbjrH6jtOR9AgBceqrVuwwuL62kbWfLOqqqzh13fP36uug1a+ull5eX07SzWejlpZXZNqvbrqwMU1WzuxeuXTlj80z0mqZpVi9312Y4HM6WjdR1qqrOieVhBtMmbdusb//Anz2S//3AsXzbG16Rd/7RZ3L911yRr73i9NXlqrrOyeWVVFW97Z5bvYRyu+PHwsJ8er1uOp0q/+Md78jHP/HpLCwsZmFhMR//5Gfyv37yJ9Pp1On3u5mfHxQdI3WdzvEv5PMHmtT7X5nXvqDJynjt9WlWhgt5zWtvTC/D/MnnHjpd2Kd/YquPJuPhKJO2TZv5LM5XaUejjKo63cfen3d9cpjde3dl+ePvyf0HOum04wxHbaqFxSy0barqUB56eJi2++Lc+vqrMz65nJMnlzO55pbcemMn7dLD+dLBpFMXvEcPDw8PDw8Pj0v4Udd1jhw5mum0yWQyyXQ6ydLSUpaXl7O8vJyVlZX1Xy8tncp0Osl0Msl02uTo0WOpO53MwrnOsWPH18eZ3e5745cWT3+JMWkzmUxXj9fk2LHjq7f6rtLpdPLHJ1bSpkkzHaeZjvP5o8v54c8ezd/7xtfmrdf28v13vyH/6YGj+cyRpfVt2rbJgyeH6XQ723zvF7G0Y35+Pnv37stjjz2afq+XX/zlX8pv/J//k7TJ0vJS+v1+mqbNNddcm+FwJcePH9/xMZIq/e5Dec+9n8vdf+Ml+abv+et56D/9Uv7gwCip9+Qlb/lb+c7XLKR94v7c97HldLJ61Y7O/tz+7d+ZGzfemKU5kN//1d/OpzOX+bkkR0cZt0lncCp/8Gu/npcNX5g//a2PZmVQpxqNMhwl1e75zFdJpz/O//ut38mXvu4v5WXf9S/yH1//uXzp1GK+8qYbcs1glAd//d35RNPNfCztAAAuH1WVdLvdHDz4RBYX5zOdTlNVTeq6SadTr3/B8PSNW5rVmeQm3W43Bw4cSK/TTZ36rHFm15ZOfv/3/3DLY08m4zRNuz5Ot9tL1dbp9/r5wKETeenzknZ1ucnC/EL+/l94Sb52dCDjJw7lht1784/ven0GB/407WRpNmCnn/sPTtLv7TpjJvt8ipd2HDt2PPPzk7ziFTdneXk5k+kk/d5senw0HqVTd9Lr9fLlLz+UU6dOFQdm1evl2Ht/Ij/24u/L37n9G/N9P3xbThw+nsnCvuxb6KQ9/rn8/I/+Sj6X/ukJ6frK3HT7Hblp40CTP87Dv3lfPtWby3y3SjseZdRWqepu6ofekx//L206/X4GnTbDdjSbke7PZb5u01aDdB/69fzbf3c83/otd+Q1N7wsX9eZ5Pjjn81vv/ud+bn7H81gvnT5CgDApalp2vR6/Rw+fCRXXX11Bv1emqZJVVfpTDurIZ3VRQJtps00bTObxT585GiOHjmShYVdSZV0u2eOM5m2ufnmV6bTqVeXeczuftg0s1nppeXl1FWVU0tLOXTwUOYXFpIqGcwN8t6jS7lnzzgvrOo0k1H2z0+TpUfW10RPjx7MDdNp0m/SLE1S9/r5yMk27zvZyd59g6wsX+Da06uq2954S9vv9y685TksLCzkmmuuzQ033pirr35e6qrO448/lgcf/JMcOHAgS0unisc+rc1oOdn3sq/PnbfdnNe++iW5dnA4H/v1X80v3fvh/Omwl4XebLvhqZWsTLcao87crkEG1TRLJ0YZd3rZvdjN1ndTXxunk4Xd/fRWC72dTrIynGQ8Xb0mYl2n1+9lrl+ftaoEAOByUNedTCfTTJsmN9xw/foM9Mabp5xxU5W6TjNt8+CDf5JOt5t+b5C6nt3eezyaXV75xS/+qlR1Zlf02DBOktWlHrM7HKat8oUvfCFJlX6/l/5gdhPA4cowe1aO5gevOZU97Xj9Mnhbnn+3l+NVL//ksd0ZL+5J0mYy3vra1RuNRuNZSPd65SH9dGomkwyHVW749h/MD95zZQ780W/ll9/9sTzw0MEsTZpssQ4dAICnSJskbZtur5fRaJTpZHYt6IWFhXNeR3ppaSmPPvpYOp06g7m5M75I2DRtRsNhptMm+/dfm/n5+dUxNv7f/tXq5fOm+fKXH07TNJmbG6Sq6/T7p788uLS0lN7Kqbx9z/G8ZjBMmtWrfKzeIaaqqqTu5CPDQf778T0Zz+1Kv9/LyvK5bye+0Xg8TudFL3rhv6rrredln22quk63lxz81Cfz6OL1edXrb83tb3pT7n75KB989wM51TUzDADwdGrbNs10mkG/n1TJkcNHMhyOkqpN3anTZnaN5qWlpRw6dDiHDh1KvzdIfzBYj+iqml07uaqq1S8ftjl8+MjsknpVUtd1miZp2iYrw5UcPXI0jz32eDrdTgb9fqrVlu10u5ktAanS6/Uzqbt5/4lOHhomg6rNYtVmUCcnmjqfGffzCycW8yvLV6S/a0/6/X6Wlle2vea5aZrZjHTp7bufOW3Gw0lG9RX5ihe/KNc0D+eTf3Y83Y6MBgB4uq3NPHd73VTpZDwZZzqezNZEry7z6NSddHrd9Lu91cvUzfbdfIm82T+Ttp1mNJ5kMp6sLudoUlV16rpOt9tJr99LXdVnxHivPzjr3JqmzXC4ktFomOlkNlZd17NlJf1BBoO5TMajjIbDtNnelwyTZDKZzkK6s837iT/7tGmmbZqqSrcW0QAAz5Q2p69E3Ol0Z7PL6312OnbXri99rutDrz0/u0Z0kk13mZ7dImQ26zy7ssfpcdbWSF/wXJsmTdtkMp5mOBqu3wFxJ6bTafnl754tqrpKJ5f2ewAAeC5Yq7HJeb7c91RaWlp6Wo/Xnf1DhAIAwE4UX0caAAAuZ5f80g4AAHgmdPfs3pt33XvfM30eAABwybjn7rvOcWM/AADgvIQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMAQAEhDQAABYQ0AAAUENIAAFBASAMA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" alt="QEMU 打印 &quot;It did not crash!&quot;，还有屏幕中央显示四个完整的白底格子"></p> <p>屏幕上的 <em>&quot;New!&quot;</em> 是往页面 <code>0</code> 写入的结果，这意味着我们成功地在页面中创建了映射。</p> <p>创建这个映射只有在地址为 <code>0</code> 的页面已经存在相应的第一级页表的情况下可行。当我们试图映射一个第一级页表不存在的页面时，由于请求 <code>EmptyFrameAllocator</code> 创建新页表用于创建新页帧而不得导致 <code>map_to</code> 函数执行失败。通过尝试映射地址为 <code>0xdeadbeaf000</code> 而不是 <code>0</code> 的页面可以复现这个失败现象。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
    <span class="token keyword">let</span> page <span class="token operator">=</span> <span class="token class-name">Page</span><span class="token punctuation">::</span><span class="token function">containing_address</span><span class="token punctuation">(</span><span class="token class-name">VirtAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">0xdeadbeaf000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>运行会触发以下错误信息的 panic：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>panicked at <span class="token string">'map_to failed: FrameAllocationFailed'</span>, /…/result.rs:999:5
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>为了映射一个还没有第一级页表的页面，我们需要创建一个合适的 <code>FrameAllocator</code>。但是我们如何知道空闲的页帧和可用的物理内存呢？</p> <h3 id="分配页帧"><a href="#分配页帧" class="header-anchor">#</a> 分配页帧</h3> <p>为了创建新页表，我们需要创建合适的页帧分配器。这时可以利用引导器一开始传入的 <code>BootInfo</code> 结构体中的 <code>memory_map</code>：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/memory.rs</span>

<span class="token keyword">use</span> <span class="token namespace">bootloader<span class="token punctuation">::</span>bootinfo<span class="token punctuation">::</span></span><span class="token class-name">MemoryMap</span><span class="token punctuation">;</span>

<span class="token comment">/// A FrameAllocator that returns usable frames from the bootloader's memory map.</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">BootInfoFrameAllocator</span> <span class="token punctuation">{</span>
    memory_map<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">MemoryMap</span><span class="token punctuation">,</span>
    next<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">BootInfoFrameAllocator</span> <span class="token punctuation">{</span>
    <span class="token comment">/// Create a FrameAllocator from the passed memory map.</span>
    <span class="token comment">///</span>
    <span class="token comment">/// This function is unsafe because the caller must guarantee that the passed</span>
    <span class="token comment">/// memory map is valid. The main requirement is that all frames that are marked</span>
    <span class="token comment">/// as `USABLE` in it are really unused.</span>
    <span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function-definition function">init</span><span class="token punctuation">(</span>memory_map<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">MemoryMap</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
        <span class="token class-name">BootInfoFrameAllocator</span> <span class="token punctuation">{</span>
            memory_map<span class="token punctuation">,</span>
            next<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>上面的结构体有两个字段：一个对引导器传入的内存映射表的 <code>'static</code> 引用，和用于记录分配器应该返回的下一个页帧的索引 <code>next</code>。</p> <p>如前面 <a href="#%E5%90%AF%E5%8A%A8%E4%BF%A1%E6%81%AF"><em>启动信息</em></a> 解释那样，BIOS/UEFI 提供内存映射表。这个映射表只能在启动流程非常早期的时候查询，所以引导器已经为我们调用了相应的函数。内存映射表由一系列 <a href="https://docs.rs/bootloader/0.6.4/bootloader/bootinfo/struct.MemoryRegion.html" target="_blank" rel="noopener noreferrer"><code>MemoryRegion</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 结构体组成，这些结构体包含每个内存区域的起始地址、长度和类型（例如，空闲、保留等）。</p> <p><code>init</code> 函数用给定的内存映射表初始化 <code>BootInfoFrameAllocator</code>。<code>next</code> 字段初始化为 <code>0</code>，并在每次页帧分配后自增以防止返回同一个页帧两次。由于我们不知道内存映射表的可用页帧是否已经在别处使用，<code>init</code> 函数必须是 <code>unsafe</code> 的，从而要求调用者提供额外保障。</p> <h4 id="usable-frames-方法"><a href="#usable-frames-方法" class="header-anchor">#</a> <code>usable_frames</code> 方法</h4> <p>在实现 <code>FrameAllocator</code> trait 之前，我们需要添加一个辅助方法用于将内存映射表转换为一个可用页帧的迭代器：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/memory.rs</span>

<span class="token keyword">use</span> <span class="token namespace">bootloader<span class="token punctuation">::</span>bootinfo<span class="token punctuation">::</span></span><span class="token class-name">MemoryRegionType</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">BootInfoFrameAllocator</span> <span class="token punctuation">{</span>
    <span class="token comment">/// Returns an iterator over the usable frames specified in the memory map.</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">usable_frames</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">impl</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span><span class="token class-name">Item</span> <span class="token operator">=</span> <span class="token class-name">PhysFrame</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// get usable regions from memory map</span>
        <span class="token keyword">let</span> regions <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>memory_map<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> usable_regions <span class="token operator">=</span> regions
            <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>r<span class="token closure-punctuation punctuation">|</span></span> r<span class="token punctuation">.</span>region_type <span class="token operator">==</span> <span class="token class-name">MemoryRegionType</span><span class="token punctuation">::</span><span class="token class-name">Usable</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// map each region to its address range</span>
        <span class="token keyword">let</span> addr_ranges <span class="token operator">=</span> usable_regions
            <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>r<span class="token closure-punctuation punctuation">|</span></span> r<span class="token punctuation">.</span>range<span class="token punctuation">.</span><span class="token function">start_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">..</span>r<span class="token punctuation">.</span>range<span class="token punctuation">.</span><span class="token function">end_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// transform to an iterator of frame start addresses</span>
        <span class="token keyword">let</span> frame_addresses <span class="token operator">=</span> addr_ranges<span class="token punctuation">.</span><span class="token function">flat_map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>r<span class="token closure-punctuation punctuation">|</span></span> r<span class="token punctuation">.</span><span class="token function">step_by</span><span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// create `PhysFrame` types from the start addresses</span>
        frame_addresses<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>addr<span class="token closure-punctuation punctuation">|</span></span> <span class="token class-name">PhysFrame</span><span class="token punctuation">::</span><span class="token function">containing_address</span><span class="token punctuation">(</span><span class="token class-name">PhysAddr</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>这个函数使用迭代器的组合方法将初始的 <code>MemoryMap</code> 变换为可用物理页帧的迭代器：</p> <ul><li>首先调用 <code>iter</code> 方法将内存映射表转换成 <a href="https://docs.rs/bootloader/0.6.4/bootloader/bootinfo/struct.MemoryRegion.html" target="_blank" rel="noopener noreferrer"><code>MemoryRegion</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的迭代器</li> <li>然后使用 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.filter" target="_blank" rel="noopener noreferrer"><code>filter</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法筛掉预留或不可用的区域。引导器会把自己创建的所有映射更新到内存映射表中，所以我们内核（代码、数据或栈）使用的或者用于存储启动信息的页帧都已经标识为 <code>InUse</code> 或者类似的标识符。因此，我们可以确定 <code>Unsable</code> 页帧尚未在其他地方被征用</li> <li>接下来，使用 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.map" target="_blank" rel="noopener noreferrer"><code>map</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法和 Rust 的 <a href="https://doc.rust-lang.org/core/ops/struct.Range.html" target="_blank" rel="noopener noreferrer">range 语法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 将内存区域的迭代器转化为地址范围的迭代器</li> <li>下一步是最为复杂的一步：借助 <code>into_iter</code> 方法将每个范围转化为一个迭代器，然后借用 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.step_by" target="_blank" rel="noopener noreferrer"><code>step_by</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 实现每隔 4096 选一个地址。由于 4096 字节（= 4 KiB）是页面大小，我们得到每个页帧的起始地址。引导器对齐了所有可用的内存区域，所以我们不需要任何对齐操作或归约的代码。借用 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.flat_map" target="_blank" rel="noopener noreferrer"><code>flat_map</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 而不是 <code>map</code>，我们得到一个 <code>Iterator&lt;Item = u64&gt;</code> 而不是 <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code></li> <li>最后，将起始地址转化为 <code>PhysFrame</code> 类型，创建出一个 <code>Iterator&lt;Item = PhysFrame&gt;</code></li></ul> <p>函数的返回类型使用 <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits" target="_blank" rel="noopener noreferrer"><code>impl Trait</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 特性。这样的话，我们可以注明返回的类型实现了 item 类型为 <code>PhysFrame</code> 的 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html" target="_blank" rel="noopener noreferrer"><code>Iterator</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> trait，而不用明确返回的具体类型。由于具体的返回值依赖不可命名的闭包类型，我们 <em>无法</em> 为其命名，所以这个特性是很重要的。</p> <h4 id="实现-frameallocator-trait"><a href="#实现-frameallocator-trait" class="header-anchor">#</a> 实现 <code>FrameAllocator</code> trait</h4> <p>现在我们可以实现 <code>FrameAllocator</code> trait 了：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/memory.rs</span>

<span class="token keyword">unsafe</span> <span class="token keyword">impl</span> <span class="token class-name">FrameAllocator</span><span class="token operator">&lt;</span><span class="token class-name">Size4KiB</span><span class="token operator">&gt;</span> <span class="token keyword">for</span> <span class="token class-name">BootInfoFrameAllocator</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">allocate_frame</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">PhysFrame</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> frame <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">usable_frames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nth</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>next <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        frame
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>我们首先调用 <code>usable_frames</code> 方法得到内存映射表中可用的页帧迭代器。然后以 <code>self.next</code> 为索引（从而跳过第 <code>(self.next - 1)</code> 帧）调用 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.nth" target="_blank" rel="noopener noreferrer"><code>Iterator::nth</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数。返回页帧前，自增 <code>self.next</code> 使得下次调用返回后续的页帧。</p> <p>由于每次分配时都需要重建 <code>usable_frame</code> 迭代器，这个实现方式离最优解还差不少。要是能够直接在结构体字段里面直接存储这个迭代器会更好。这样一来我们就不需要 <code>nth</code>方法，只需在每次分配时调用 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next" target="_blank" rel="noopener noreferrer"><code>next</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。问题在于当前还不支持这在结构体字段里面存储一个 <code>impl Trait</code> 类型。将来等 <a href="https://github.com/rust-lang/rfcs/pull/2071" target="_blank" rel="noopener noreferrer"><em>named existential types</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 完全实现时，方法说不定就可行了。</p> <h4 id="使用-bootinfoframeallocator"><a href="#使用-bootinfoframeallocator" class="header-anchor">#</a> 使用 <code>BootInfoFrameAllocator</code></h4> <p>我们可以在 <code>kernel_main</code> 函数里用 <code>BootInfoFrameAllocator</code> 替换掉 <code>EmptyFrameAllocator</code>：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// in src/main.rs</span>

<span class="token keyword">fn</span> <span class="token function-definition function">kernel_main</span><span class="token punctuation">(</span>boot_info<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">BootInfo</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token namespace">blog_os<span class="token punctuation">::</span>memory<span class="token punctuation">::</span></span><span class="token class-name">BootInfoFrameAllocator</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> frame_allocator <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">{</span>
        <span class="token class-name">BootInfoFrameAllocator</span><span class="token punctuation">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>boot_info<span class="token punctuation">.</span>memory_map<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>…<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>借用这个启动信息版页帧分配器，屏幕上再次呈现白底黑字的 <em>&quot;New!&quot;</em> 字样，说明映射成功了。背地里，<code>map_to</code> 方法用以下方式创建缺失的页表：</p> <ul><li>从传入的 <code>frame_allocator</code> 申请一个可用的页帧</li> <li>清空页帧，创建出一个全新的空页表</li> <li>将上一次页表项指向这个页帧</li> <li>继续往下创建下一级页表</li></ul> <p>虽然 <code>create_example_mapping</code> 只作示例，但是我们现在可以为任意页面创建映射。这对于后续文章的分配内存或者实现多线程是不可或缺的。</p> <p>到此为止，如 <a href="#create-example-mapping-%E5%87%BD%E6%95%B0">前面</a> 解释的那样，我们应该再次删除 <code>create_example_mapping</code> 函数，以避免无意调用触发未定义行为。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>本文讲述了访问页表物理页帧的不同方式，包括一对一映射，映射整个物理内存，临时映射和递归映射页表。出于简单、可移植和强大功能的考虑，我们选择映射整个物理内存。</p> <p>无法访问页表的情况下，我们的内核无法映射到物理内存，所以我们需要引导器的支持。<code>bootloader</code> 启用可选的 cargo 特性可以支持创建我们需要的映射。它会以 <code>&amp;BootInfo</code> 参数的形式把要求的信息传给我们内核的入口函数。</p> <p>对于代码实现，我们首先人为地遍历页表实现一个转换函数，然后使用 <code>x86_64</code> 包的 <code>MappedPageTable</code> 类型。我们也学到了如何在页表中创建新映射以及如何在引导器传入的内存映射表上创建必要的 <code>FrameAllocator</code>。</p> <h2 id="下篇预告"><a href="#下篇预告" class="header-anchor">#</a> 下篇预告</h2> <p>下篇文章将会为我们的内核创建堆内存区域，允许我们 <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html" target="_blank" rel="noopener noreferrer">分配内存<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和使用多种 <a href="https://doc.rust-lang.org/alloc/collections/index.html" target="_blank" rel="noopener noreferrer">集合类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#简介" class="sidebar-link reco-side-简介" data-v-b57cc07c>简介</a></li><li class="level-2" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#访问页表" class="sidebar-link reco-side-访问页表" data-v-b57cc07c>访问页表</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#一一映射" class="sidebar-link reco-side-一一映射" data-v-b57cc07c>一一映射</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#从固定偏移量开始映射" class="sidebar-link reco-side-从固定偏移量开始映射" data-v-b57cc07c>从固定偏移量开始映射</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#映射完整的物理内存" class="sidebar-link reco-side-映射完整的物理内存" data-v-b57cc07c>映射完整的物理内存</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#临时映射" class="sidebar-link reco-side-临时映射" data-v-b57cc07c>临时映射</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#递归式页表" class="sidebar-link reco-side-递归式页表" data-v-b57cc07c>递归式页表</a></li><li class="level-2" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#引导器支持" class="sidebar-link reco-side-引导器支持" data-v-b57cc07c>引导器支持</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#启动信息" class="sidebar-link reco-side-启动信息" data-v-b57cc07c>启动信息</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#entry-point-宏" class="sidebar-link reco-side-entry-point-宏" data-v-b57cc07c>entry_point 宏</a></li><li class="level-2" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#实现" class="sidebar-link reco-side-实现" data-v-b57cc07c>实现</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#访问页表-2" class="sidebar-link reco-side-访问页表-2" data-v-b57cc07c>访问页表</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#转换地址" class="sidebar-link reco-side-转换地址" data-v-b57cc07c>转换地址</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#使用-offsetpagetable" class="sidebar-link reco-side-使用-offsetpagetable" data-v-b57cc07c>使用 OffsetPageTable</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#创建新的映射" class="sidebar-link reco-side-创建新的映射" data-v-b57cc07c>创建新的映射</a></li><li class="level-3" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#分配页帧" class="sidebar-link reco-side-分配页帧" data-v-b57cc07c>分配页帧</a></li><li class="level-2" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#总结" class="sidebar-link reco-side-总结" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/blog-os/blog-os-09-paging-implementation/#下篇预告" class="sidebar-link reco-side-下篇预告" data-v-b57cc07c>下篇预告</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.2124bf24.js" defer></script><script src="/assets/js/3.944fac0d.js" defer></script><script src="/assets/js/1.c30a1333.js" defer></script><script src="/assets/js/4.908240c5.js" defer></script>
  </body>
</html>
